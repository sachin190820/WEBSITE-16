/*! For license information please see main.a5444344e9dc6714c7c4.js.LICENSE.txt */
!function(t) {
    var e = {};
    function n(i) {
        if (e[i])
            return e[i].exports;
        var r = e[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return t[i].call(r.exports, r, r.exports, n),
        r.l = !0,
        r.exports
    }
    n.m = t,
    n.c = e,
    n.d = function(t, e, i) {
        n.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: i
        })
    }
    ,
    n.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }
    ,
    n.t = function(t, e) {
        if (1 & e && (t = n(t)),
        8 & e)
            return t;
        if (4 & e && "object" == typeof t && t && t.__esModule)
            return t;
        var i = Object.create(null);
        if (n.r(i),
        Object.defineProperty(i, "default", {
            enumerable: !0,
            value: t
        }),
        2 & e && "string" != typeof t)
            for (var r in t)
                n.d(i, r, function(e) {
                    return t[e]
                }
                .bind(null, r));
        return i
    }
    ,
    n.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        }
        : function() {
            return t
        }
        ;
        return n.d(e, "a", e),
        e
    }
    ,
    n.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }
    ,
    n.p = "/",
    n(n.s = 10)
}([function(t, e) {
    function n() {}
    n.prototype = {
        on: function(t, e, n) {
            var i = this.e || (this.e = {});
            return (i[t] || (i[t] = [])).push({
                fn: e,
                ctx: n
            }),
            this
        },
        once: function(t, e, n) {
            var i = this;
            function r() {
                i.off(t, r),
                e.apply(n, arguments)
            }
            return r._ = e,
            this.on(t, r, n)
        },
        emit: function(t) {
            for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++)
                n[i].fn.apply(n[i].ctx, e);
            return this
        },
        off: function(t, e) {
            var n = this.e || (this.e = {})
              , i = n[t]
              , r = [];
            if (i && e)
                for (var o = 0, s = i.length; o < s; o++)
                    i[o].fn !== e && i[o].fn._ !== e && r.push(i[o]);
            return r.length ? n[t] = r : delete n[t],
            this
        }
    },
    t.exports = n
}
, function(t, e, n) {
    "use strict";
    var i = n(4)
      , r = n(0)
      , o = n(5).Lethargy
      , s = n(6)
      , a = (n(7),
    n(8))
      , l = "virtualscroll";
    t.exports = f;
    var c = 37
      , u = 38
      , h = 39
      , d = 40
      , p = 32;
    function f(t) {
        a(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown"),
        this.el = window,
        t && t.el && (this.el = t.el,
        delete t.el),
        this.options = i({
            mouseMultiplier: 1,
            touchMultiplier: 2,
            firefoxMultiplier: 15,
            keyStep: 120,
            preventTouch: !1,
            unpreventTouchClass: "vs-touchmove-allowed",
            limitInertia: !1,
            useKeyboard: !0,
            useTouch: !0
        }, t),
        this.options.limitInertia && (this._lethargy = new o),
        this._emitter = new r,
        this._event = {
            y: 0,
            x: 0,
            deltaX: 0,
            deltaY: 0
        },
        this.touchStartX = null,
        this.touchStartY = null,
        this.bodyTouchAction = null,
        void 0 !== this.options.passive && (this.listenerOptions = {
            passive: this.options.passive
        })
    }
    f.prototype._notify = function(t) {
        var e = this._event;
        e.x += e.deltaX,
        e.y += e.deltaY,
        this._emitter.emit(l, {
            x: e.x,
            y: e.y,
            deltaX: e.deltaX,
            deltaY: e.deltaY,
            originalEvent: t
        })
    }
    ,
    f.prototype._onWheel = function(t) {
        var e = this.options;
        if (!this._lethargy || !1 !== this._lethargy.check(t)) {
            var n = this._event;
            n.deltaX = t.wheelDeltaX || -1 * t.deltaX,
            n.deltaY = t.wheelDeltaY || -1 * t.deltaY,
            s.isFirefox && 1 == t.deltaMode && (n.deltaX *= e.firefoxMultiplier,
            n.deltaY *= e.firefoxMultiplier),
            n.deltaX *= e.mouseMultiplier,
            n.deltaY *= e.mouseMultiplier,
            this._notify(t)
        }
    }
    ,
    f.prototype._onMouseWheel = function(t) {
        if (!this.options.limitInertia || !1 !== this._lethargy.check(t)) {
            var e = this._event;
            e.deltaX = t.wheelDeltaX ? t.wheelDeltaX : 0,
            e.deltaY = t.wheelDeltaY ? t.wheelDeltaY : t.wheelDelta,
            this._notify(t)
        }
    }
    ,
    f.prototype._onTouchStart = function(t) {
        var e = t.targetTouches ? t.targetTouches[0] : t;
        this.touchStartX = e.pageX,
        this.touchStartY = e.pageY
    }
    ,
    f.prototype._onTouchMove = function(t) {
        var e = this.options;
        e.preventTouch && !t.target.classList.contains(e.unpreventTouchClass) && t.preventDefault();
        var n = this._event
          , i = t.targetTouches ? t.targetTouches[0] : t;
        n.deltaX = (i.pageX - this.touchStartX) * e.touchMultiplier,
        n.deltaY = (i.pageY - this.touchStartY) * e.touchMultiplier,
        this.touchStartX = i.pageX,
        this.touchStartY = i.pageY,
        this._notify(t)
    }
    ,
    f.prototype._onKeyDown = function(t) {
        var e = this._event;
        e.deltaX = e.deltaY = 0;
        var n = window.innerHeight - 40;
        switch (t.keyCode) {
        case c:
        case u:
            e.deltaY = this.options.keyStep;
            break;
        case h:
        case d:
            e.deltaY = -this.options.keyStep;
            break;
        case p && t.shiftKey:
            e.deltaY = n;
            break;
        case p:
            e.deltaY = -n;
            break;
        default:
            return
        }
        this._notify(t)
    }
    ,
    f.prototype._bind = function() {
        s.hasWheelEvent && this.el.addEventListener("wheel", this._onWheel, this.listenerOptions),
        s.hasMouseWheelEvent && this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions),
        s.hasTouch && this.options.useTouch && (this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions),
        this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions)),
        s.hasPointer && s.hasTouchWin && (this.bodyTouchAction = document.body.style.msTouchAction,
        document.body.style.msTouchAction = "none",
        this.el.addEventListener("MSPointerDown", this._onTouchStart, !0),
        this.el.addEventListener("MSPointerMove", this._onTouchMove, !0)),
        s.hasKeyDown && this.options.useKeyboard && document.addEventListener("keydown", this._onKeyDown)
    }
    ,
    f.prototype._unbind = function() {
        s.hasWheelEvent && this.el.removeEventListener("wheel", this._onWheel),
        s.hasMouseWheelEvent && this.el.removeEventListener("mousewheel", this._onMouseWheel),
        s.hasTouch && (this.el.removeEventListener("touchstart", this._onTouchStart),
        this.el.removeEventListener("touchmove", this._onTouchMove)),
        s.hasPointer && s.hasTouchWin && (document.body.style.msTouchAction = this.bodyTouchAction,
        this.el.removeEventListener("MSPointerDown", this._onTouchStart, !0),
        this.el.removeEventListener("MSPointerMove", this._onTouchMove, !0)),
        s.hasKeyDown && this.options.useKeyboard && document.removeEventListener("keydown", this._onKeyDown)
    }
    ,
    f.prototype.on = function(t, e) {
        this._emitter.on(l, t, e);
        var n = this._emitter.e;
        n && n[l] && 1 === n[l].length && this._bind()
    }
    ,
    f.prototype.off = function(t, e) {
        this._emitter.off(l, t, e);
        var n = this._emitter.e;
        (!n[l] || n[l].length <= 0) && this._unbind()
    }
    ,
    f.prototype.reset = function() {
        var t = this._event;
        t.x = 0,
        t.y = 0
    }
    ,
    f.prototype.destroy = function() {
        this._emitter.off(),
        this._unbind()
    }
}
, function(t, e) {
    t.exports = function(t) {
        t = t || {};
        var e = document.createElement(t.selector);
        if (t.attr)
            for (var n in t.attr)
                t.attr.hasOwnProperty(n) && e.setAttribute(n, t.attr[n]);
        return "a" == t.selector && t.link && (e.href = t.link,
        t.target && e.setAttribute("target", t.target)),
        "img" == t.selector && t.src && (e.src = t.src,
        t.lazyload && (e.style.opacity = 0,
        e.onload = function() {
            e.style.opacity = 1
        }
        )),
        t.id && (e.id = t.id),
        t.styles && (e.className = t.styles),
        t.html && (e.innerHTML = t.html),
        t.children && e.appendChild(t.children),
        e
    }
}
, function(t, e, n) {
    t.exports = function() {
        "use strict";
        function t(t, e) {
            const n = new XMLHttpRequest;
            n.open("GET", t, !0),
            n.responseType = "blob";
            const i = this.getItemByUrl(t);
            i.xhr = n,
            n.onprogress = t=>{
                if (!t.lengthComputable)
                    return !1;
                i.completion = parseInt(t.loaded / t.total * 100),
                i.downloaded = t.loaded,
                i.total = t.total,
                this.updateProgressBar(i)
            }
            ,
            n.onload = t=>{
                const r = t.target.response.type
                  , o = t.target.responseURL;
                if (i.fileName = o.substring(o.lastIndexOf("/") + 1),
                i.type = r,
                i.status = n.status,
                404 == n.status)
                    i.blobUrl = i.size = null,
                    i.error = !0,
                    this.onerror(i);
                else {
                    const e = new Blob([t.target.response],{
                        type: r
                    });
                    i.blobUrl = URL.createObjectURL(e),
                    i.size = e.size,
                    i.error = !1
                }
                e(i)
            }
            ,
            n.send()
        }
        function e(t) {
            let e = 0
              , n = this.stepped ? 100 * this.state.length : 0
              , i = 0;
            for (const t of this.state)
                t.completion && i++,
                this.stepped ? t.completion && (e += t.completion) : this._readyForComputation ? (e += t.downloaded,
                n += t.total) : e = n = 0;
            this._readyForComputation = i == this.state.length;
            const r = parseInt(e / n * 100);
            isNaN(r) || this.onprogress({
                progress: r,
                item: t
            })
        }
        function n(t) {
            for (var e of this.state)
                if (e.url == t)
                    return e
        }
        function i(t) {
            return new Promise((e,n)=>{
                this.loaded = t.length;
                for (let n of t)
                    this.state.push({
                        url: n
                    }),
                    this.preloadOne(n, t=>{
                        this.onfetched(t),
                        this.loaded--,
                        0 == this.loaded && (this.oncomplete(this.state),
                        e(this.state))
                    }
                    )
            }
            )
        }
        function r() {
            for (var t of this.state)
                t.completion < 100 && (t.xhr.abort(),
                t.status = 0);
            return this.oncancel(this.state),
            this.state
        }
        function o(o) {
            return {
                state: [],
                loaded: !1,
                stepped: o && o.stepped || !0,
                onprogress: ()=>{}
                ,
                oncomplete: ()=>{}
                ,
                onfetched: ()=>{}
                ,
                onerror: ()=>{}
                ,
                oncancel: ()=>{}
                ,
                fetch: i,
                updateProgressBar: e,
                preloadOne: t,
                getItemByUrl: n,
                cancel: r
            }
        }
        return o
    }()
}
, function(t, e, n) {
    "use strict";
    var i = Object.getOwnPropertySymbols
      , r = Object.prototype.hasOwnProperty
      , o = Object.prototype.propertyIsEnumerable;
    function s(t) {
        if (null == t)
            throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(t)
    }
    t.exports = function() {
        try {
            if (!Object.assign)
                return !1;
            var t = new String("abc");
            if (t[5] = "de",
            "5" === Object.getOwnPropertyNames(t)[0])
                return !1;
            for (var e = {}, n = 0; n < 10; n++)
                e["_" + String.fromCharCode(n)] = n;
            if ("0123456789" !== Object.getOwnPropertyNames(e).map((function(t) {
                return e[t]
            }
            )).join(""))
                return !1;
            var i = {};
            return "abcdefghijklmnopqrst".split("").forEach((function(t) {
                i[t] = t
            }
            )),
            "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, i)).join("")
        } catch (t) {
            return !1
        }
    }() ? Object.assign : function(t, e) {
        for (var n, a, l = s(t), c = 1; c < arguments.length; c++) {
            for (var u in n = Object(arguments[c]))
                r.call(n, u) && (l[u] = n[u]);
            if (i) {
                a = i(n);
                for (var h = 0; h < a.length; h++)
                    o.call(n, a[h]) && (l[a[h]] = n[a[h]])
            }
        }
        return l
    }
}
, function(t, e, n) {
    (function() {
        (null !== e ? e : this).Lethargy = function() {
            function t(t, e, n, i) {
                this.stability = null != t ? Math.abs(t) : 8,
                this.sensitivity = null != e ? 1 + Math.abs(e) : 100,
                this.tolerance = null != n ? 1 + Math.abs(n) : 1.1,
                this.delay = null != i ? i : 150,
                this.lastUpDeltas = function() {
                    var t, e, n;
                    for (n = [],
                    t = 1,
                    e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--)
                        n.push(null);
                    return n
                }
                .call(this),
                this.lastDownDeltas = function() {
                    var t, e, n;
                    for (n = [],
                    t = 1,
                    e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--)
                        n.push(null);
                    return n
                }
                .call(this),
                this.deltasTimestamp = function() {
                    var t, e, n;
                    for (n = [],
                    t = 1,
                    e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--)
                        n.push(null);
                    return n
                }
                .call(this)
            }
            return t.prototype.check = function(t) {
                var e;
                return null != (t = t.originalEvent || t).wheelDelta ? e = t.wheelDelta : null != t.deltaY ? e = -40 * t.deltaY : null == t.detail && 0 !== t.detail || (e = -40 * t.detail),
                this.deltasTimestamp.push(Date.now()),
                this.deltasTimestamp.shift(),
                e > 0 ? (this.lastUpDeltas.push(e),
                this.lastUpDeltas.shift(),
                this.isInertia(1)) : (this.lastDownDeltas.push(e),
                this.lastDownDeltas.shift(),
                this.isInertia(-1))
            }
            ,
            t.prototype.isInertia = function(t) {
                var e, n, i, r, o, s, a;
                return null === (e = -1 === t ? this.lastDownDeltas : this.lastUpDeltas)[0] ? t : !(this.deltasTimestamp[2 * this.stability - 2] + this.delay > Date.now() && e[0] === e[2 * this.stability - 1]) && (i = e.slice(0, this.stability),
                n = e.slice(this.stability, 2 * this.stability),
                a = i.reduce((function(t, e) {
                    return t + e
                }
                )),
                o = n.reduce((function(t, e) {
                    return t + e
                }
                )),
                s = a / i.length,
                r = o / n.length,
                Math.abs(s) < Math.abs(r * this.tolerance) && this.sensitivity < Math.abs(r) && t)
            }
            ,
            t.prototype.showLastUpDeltas = function() {
                return this.lastUpDeltas
            }
            ,
            t.prototype.showLastDownDeltas = function() {
                return this.lastDownDeltas
            }
            ,
            t
        }()
    }
    ).call(this)
}
, function(t, e, n) {
    "use strict";
    t.exports = {
        hasWheelEvent: "onwheel"in document,
        hasMouseWheelEvent: "onmousewheel"in document,
        hasTouch: "ontouchstart"in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
        hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
        hasPointer: !!window.navigator.msPointerEnabled,
        hasKeyDown: "onkeydown"in document,
        isFirefox: navigator.userAgent.indexOf("Firefox") > -1
    }
}
, function(t, e, n) {
    "use strict";
    t.exports = function(t) {
        return JSON.parse(JSON.stringify(t))
    }
}
, function(t, e, n) {
    "use strict";
    var i = Object.prototype.toString
      , r = Object.prototype.hasOwnProperty;
    function o(t, e) {
        return function() {
            return t.apply(e, arguments)
        }
    }
    t.exports = function(t) {
        if (!t)
            return console.warn("bindAll requires at least one argument.");
        var e = Array.prototype.slice.call(arguments, 1);
        if (0 === e.length)
            for (var n in t)
                r.call(t, n) && "function" == typeof t[n] && "[object Function]" == i.call(t[n]) && e.push(n);
        for (var s = 0; s < e.length; s++) {
            var a = e[s];
            t[a] = o(t[a], t)
        }
    }
}
, , function(t, e, n) {
    "use strict";
    n.r(e);
    var i = function(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
        return e.querySelector(t)
    }
      , r = function(t) {
        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
        return o(e.querySelectorAll(t))
    }
      , o = function(t) {
        return Array.prototype.slice.call(t, 0)
    };
    function s(t) {
        for (var e = [].slice.call(arguments, 1), n = 0; n < e.length; n++) {
            var i = e[n];
            t[i] = a(t[i], t)
        }
    }
    function a(t, e) {
        return function() {
            return t.apply(e, arguments)
        }
    }
    function l(t, e, n, i, r) {
        var o = t.length
          , s = !0 === r && {
            passive: !0
        };
        if (0 !== o)
            for (var a = 0; a < o; a++)
                t[a][e + "EventListener"](n, i, s);
        else
            t[e + "EventListener"](n, i, s)
    }
    var c = function(t) {
        var e = t.getBoundingClientRect();
        return {
            bottom: e.bottom,
            left: e.left,
            height: e.height,
            right: e.right,
            top: e.top,
            width: e.width,
            x: e.x,
            y: e.y
        }
    }
      , u = function() {
        var t = window
          , e = "inner";
        return "innerWidth"in window || (e = "client",
        t = document.documentElement || document.body),
        {
            width: t["".concat(e, "Width")],
            height: t["".concat(e, "Height")]
        }
    }
      , h = function() {
        return {
            XS: window.innerWidth <= 500,
            S: window.innerWidth <= 749,
            S_UP: window.innerWidth >= 501,
            M: window.innerWidth <= 1023,
            M_UP: window.innerWidth >= 750,
            L: window.innerWidth >= 1024
        }
    }
      , d = {
        uA: navigator.userAgent.toLowerCase(),
        aV: navigator.appVersion.toLowerCase(),
        get isWindowsMobile() {
            return /windows phone|iemobile|wpdesktop/.test(this.uA)
        },
        get isMobileOpera() {
            return /opera mini/i.test(this.uA)
        },
        get isIOS() {
            return /iphone|ipad|ipod/i.test(this.uA)
        },
        get isIpad() {
            return !this.isWindowsMobile && /ipad/i.test(this.uA) && this.isIOS
        },
        get isIphone() {
            return !this.isWindowsMobile && /iphone/i.test(this.uA) && this.isIOS
        },
        get isMobileAndroid() {
            return !this.isWindowsMobile && /android.*mobile/.test(this.uA)
        },
        get isTabletAndroid() {
            return !this.isWindowsMobile && !this.isMobileAndroid && /android/i.test(this.uA)
        },
        get isAndroid() {
            return this.isMobileAndroid || this.isTabletAndroid
        },
        get isPhone() {
            return this.isMobileAndroid || this.isIOS && !this.isIpad || this.isWindowsMobile
        },
        get isTablet() {
            return this.isTabletAndroid || this.isIpad
        },
        get isDevice() {
            return this.isPhone || this.isTablet
        },
        get isFirefox() {
            return this.uA.indexOf("firefox") > -1
        },
        get isSafari() {
            return !!this.uA.match(/version\/[\d\.]+.*safari/)
        },
        get isOpera() {
            return this.uA.indexOf("opr") > -1
        },
        get isIE11() {
            return !window.ActiveXObject && "ActiveXObject"in window
        },
        get isIE() {
            return this.aV.indexOf("msie") > -1 || this.isIE11 || this.aV.indexOf("edge") > -1
        },
        get isEdge() {
            return this.uA.indexOf("edge") > -1
        },
        get isWindows() {
            return -1 !== ["Win32", "Win64", "Windows", "WinCE"].indexOf(window.navigator.platform)
        },
        get isChrome() {
            return null !== window.chrome && void 0 !== window.chrome && "google inc." == navigator.vendor.toLowerCase() && !this.isOpera && !this.isEdge
        },
        get isMac() {
            return navigator.platform.toLowerCase().indexOf("mac") > -1
        },
        get isDesktop() {
            return !this.isPhone && !this.isTablet
        },
        get isTouch() {
            return "ontouchstart"in window
        },
        get sniff() {
            return {
                isWindowsMobile: this.isWindowsMobile,
                isMobileOpera: this.isMobileOpera,
                isIOS: this.isIOS,
                isIpad: this.isIpad,
                isIphone: this.isIphone,
                isMobileAndroid: this.isMobileAndroid,
                isTabletAndroid: this.isTabletAndroid,
                isAndroid: this.isAndroid,
                isFirefox: this.isFirefox,
                isSafari: this.isSafari,
                isOpera: this.isOpera,
                isIE11: this.isIE11,
                isIE: this.isIE,
                isEdge: this.isEdge,
                isChrome: this.isChrome,
                isMac: this.isMac,
                isPhone: this.isPhone,
                isTablet: this.isTablet,
                isDevice: this.isDevice,
                isDesktop: this.isDesktop,
                isWindows: this.isWindows,
                isTouch: this.isTouch
            }
        },
        update: function() {
            Object.assign(this, {
                uA: navigator.userAgent.toLowerCase(),
                aV: navigator.appVersion.toLowerCase()
            })
        }
    }
      , p = function(t, e, n) {
        return t * (1 - n) + e * n
    }
      , f = function(t, e, n) {
        return Math.min(Math.max(t, e), n)
    };
    const m = 100
      , g = 301
      , v = 302
      , y = 306
      , _ = 307
      , x = 1e3
      , b = 1001
      , w = 1002
      , M = 1003
      , S = 1004
      , E = 1005
      , D = 1006
      , T = 1008
      , A = 1009
      , C = 1012
      , L = 1014
      , P = 1015
      , R = 1016
      , O = 1020
      , F = 1022
      , N = 1023
      , I = 1026
      , B = 1027
      , k = 2300
      , z = 2301
      , U = 2302
      , H = 2400
      , G = 2401
      , V = 2402
      , j = 2500
      , W = 3e3
      , q = 3001
      , X = 3007
      , Y = 3002
      , Z = 7680
      , J = 35044
      , Q = 35048
      , K = "300 es";
    function $() {}
    Object.assign($.prototype, {
        addEventListener: function(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []),
            -1 === n[t].indexOf(e) && n[t].push(e)
        },
        hasEventListener: function(t, e) {
            if (void 0 === this._listeners)
                return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e)
        },
        removeEventListener: function(t, e) {
            if (void 0 === this._listeners)
                return;
            const n = this._listeners[t];
            if (void 0 !== n) {
                const t = n.indexOf(e);
                -1 !== t && n.splice(t, 1)
            }
        },
        dispatchEvent: function(t) {
            if (void 0 === this._listeners)
                return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
                t.target = this;
                const n = e.slice(0);
                for (let e = 0, i = n.length; e < i; e++)
                    n[e].call(this, t)
            }
        }
    });
    const tt = [];
    for (let t = 0; t < 256; t++)
        tt[t] = (t < 16 ? "0" : "") + t.toString(16);
    let et = 1234567;
    const nt = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            const t = 4294967295 * Math.random() | 0
              , e = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (tt[255 & t] + tt[t >> 8 & 255] + tt[t >> 16 & 255] + tt[t >> 24 & 255] + "-" + tt[255 & e] + tt[e >> 8 & 255] + "-" + tt[e >> 16 & 15 | 64] + tt[e >> 24 & 255] + "-" + tt[63 & n | 128] + tt[n >> 8 & 255] + "-" + tt[n >> 16 & 255] + tt[n >> 24 & 255] + tt[255 & i] + tt[i >> 8 & 255] + tt[i >> 16 & 255] + tt[i >> 24 & 255]).toUpperCase()
        },
        clamp: function(t, e, n) {
            return Math.max(e, Math.min(n, t))
        },
        euclideanModulo: function(t, e) {
            return (t % e + e) % e
        },
        mapLinear: function(t, e, n, i, r) {
            return i + (t - e) * (r - i) / (n - e)
        },
        lerp: function(t, e, n) {
            return (1 - n) * t + n * e
        },
        smoothstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
        },
        smootherstep: function(t, e, n) {
            return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
        },
        randInt: function(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        },
        randFloat: function(t, e) {
            return t + Math.random() * (e - t)
        },
        randFloatSpread: function(t) {
            return t * (.5 - Math.random())
        },
        seededRandom: function(t) {
            return void 0 !== t && (et = t % 2147483647),
            et = 16807 * et % 2147483647,
            (et - 1) / 2147483646
        },
        degToRad: function(t) {
            return t * nt.DEG2RAD
        },
        radToDeg: function(t) {
            return t * nt.RAD2DEG
        },
        isPowerOfTwo: function(t) {
            return 0 == (t & t - 1) && 0 !== t
        },
        ceilPowerOfTwo: function(t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        },
        floorPowerOfTwo: function(t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        },
        setQuaternionFromProperEuler: function(t, e, n, i, r) {
            const o = Math.cos
              , s = Math.sin
              , a = o(n / 2)
              , l = s(n / 2)
              , c = o((e + i) / 2)
              , u = s((e + i) / 2)
              , h = o((e - i) / 2)
              , d = s((e - i) / 2)
              , p = o((i - e) / 2)
              , f = s((i - e) / 2);
            switch (r) {
            case "XYX":
                t.set(a * u, l * h, l * d, a * c);
                break;
            case "YZY":
                t.set(l * d, a * u, l * h, a * c);
                break;
            case "ZXZ":
                t.set(l * h, l * d, a * u, a * c);
                break;
            case "XZX":
                t.set(a * u, l * f, l * p, a * c);
                break;
            case "YXY":
                t.set(l * p, a * u, l * f, a * c);
                break;
            case "ZYZ":
                t.set(l * f, l * p, a * u, a * c);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
            }
        }
    };
    class it {
        constructor(t=0, e=0) {
            Object.defineProperty(this, "isVector2", {
                value: !0
            }),
            this.x = t,
            this.y = e
        }
        get width() {
            return this.x
        }
        set width(t) {
            this.x = t
        }
        get height() {
            return this.y
        }
        set height(t) {
            this.y = t
        }
        set(t, e) {
            return this.x = t,
            this.y = e,
            this
        }
        setScalar(t) {
            return this.x = t,
            this.y = t,
            this
        }
        setX(t) {
            return this.x = t,
            this
        }
        setY(t) {
            return this.y = t,
            this
        }
        setComponent(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y)
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this
        }
        add(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this)
        }
        addScalar(t) {
            return this.x += t,
            this.y += t,
            this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this
        }
        sub(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this)
        }
        subScalar(t) {
            return this.x -= t,
            this.y -= t,
            this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this
        }
        multiply(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this
        }
        multiplyScalar(t) {
            return this.x *= t,
            this.y *= t,
            this
        }
        divide(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        applyMatrix3(t) {
            const e = this.x
              , n = this.y
              , i = t.elements;
            return this.x = i[0] * e + i[3] * n + i[6],
            this.y = i[1] * e + i[4] * n + i[7],
            this
        }
        min(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y
        }
        cross(t) {
            return this.x * t.y - this.y * t.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x
              , n = this.y - t.y;
            return e * e + n * n
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n,
            this.y = t.y + (e.y - t.y) * n,
            this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y
        }
        fromArray(t, e=0) {
            return this.x = t[e],
            this.y = t[e + 1],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.x,
            t[e + 1] = this.y,
            t
        }
        fromBufferAttribute(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this
        }
        rotateAround(t, e) {
            const n = Math.cos(e)
              , i = Math.sin(e)
              , r = this.x - t.x
              , o = this.y - t.y;
            return this.x = r * n - o * i + t.x,
            this.y = r * i + o * n + t.y,
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this
        }
    }
    class rt {
        constructor() {
            Object.defineProperty(this, "isMatrix3", {
                value: !0
            }),
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }
        set(t, e, n, i, r, o, s, a, l) {
            const c = this.elements;
            return c[0] = t,
            c[1] = i,
            c[2] = s,
            c[3] = e,
            c[4] = r,
            c[5] = a,
            c[6] = n,
            c[7] = o,
            c[8] = l,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        }
        clone() {
            return (new this.constructor).fromArray(this.elements)
        }
        copy(t) {
            const e = this.elements
              , n = t.elements;
            return e[0] = n[0],
            e[1] = n[1],
            e[2] = n[2],
            e[3] = n[3],
            e[4] = n[4],
            e[5] = n[5],
            e[6] = n[6],
            e[7] = n[7],
            e[8] = n[8],
            this
        }
        extractBasis(t, e, n) {
            return t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
        }
        setFromMatrix4(t) {
            const e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
        }
        multiply(t) {
            return this.multiplyMatrices(this, t)
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
            const n = t.elements
              , i = e.elements
              , r = this.elements
              , o = n[0]
              , s = n[3]
              , a = n[6]
              , l = n[1]
              , c = n[4]
              , u = n[7]
              , h = n[2]
              , d = n[5]
              , p = n[8]
              , f = i[0]
              , m = i[3]
              , g = i[6]
              , v = i[1]
              , y = i[4]
              , _ = i[7]
              , x = i[2]
              , b = i[5]
              , w = i[8];
            return r[0] = o * f + s * v + a * x,
            r[3] = o * m + s * y + a * b,
            r[6] = o * g + s * _ + a * w,
            r[1] = l * f + c * v + u * x,
            r[4] = l * m + c * y + u * b,
            r[7] = l * g + c * _ + u * w,
            r[2] = h * f + d * v + p * x,
            r[5] = h * m + d * y + p * b,
            r[8] = h * g + d * _ + p * w,
            this
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t,
            e[3] *= t,
            e[6] *= t,
            e[1] *= t,
            e[4] *= t,
            e[7] *= t,
            e[2] *= t,
            e[5] *= t,
            e[8] *= t,
            this
        }
        determinant() {
            const t = this.elements
              , e = t[0]
              , n = t[1]
              , i = t[2]
              , r = t[3]
              , o = t[4]
              , s = t[5]
              , a = t[6]
              , l = t[7]
              , c = t[8];
            return e * o * c - e * s * l - n * r * c + n * s * a + i * r * l - i * o * a
        }
        invert() {
            const t = this.elements
              , e = t[0]
              , n = t[1]
              , i = t[2]
              , r = t[3]
              , o = t[4]
              , s = t[5]
              , a = t[6]
              , l = t[7]
              , c = t[8]
              , u = c * o - s * l
              , h = s * a - c * r
              , d = l * r - o * a
              , p = e * u + n * h + i * d;
            if (0 === p)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return t[0] = u * f,
            t[1] = (i * l - c * n) * f,
            t[2] = (s * n - i * o) * f,
            t[3] = h * f,
            t[4] = (c * e - i * a) * f,
            t[5] = (i * r - s * e) * f,
            t[6] = d * f,
            t[7] = (n * a - l * e) * f,
            t[8] = (o * e - n * r) * f,
            this
        }
        transpose() {
            let t;
            const e = this.elements;
            return t = e[1],
            e[1] = e[3],
            e[3] = t,
            t = e[2],
            e[2] = e[6],
            e[6] = t,
            t = e[5],
            e[5] = e[7],
            e[7] = t,
            this
        }
        getNormalMatrix(t) {
            return this.setFromMatrix4(t).copy(this).invert().transpose()
        }
        transposeIntoArray(t) {
            const e = this.elements;
            return t[0] = e[0],
            t[1] = e[3],
            t[2] = e[6],
            t[3] = e[1],
            t[4] = e[4],
            t[5] = e[7],
            t[6] = e[2],
            t[7] = e[5],
            t[8] = e[8],
            this
        }
        setUvTransform(t, e, n, i, r, o, s) {
            const a = Math.cos(r)
              , l = Math.sin(r);
            return this.set(n * a, n * l, -n * (a * o + l * s) + o + t, -i * l, i * a, -i * (-l * o + a * s) + s + e, 0, 0, 1),
            this
        }
        scale(t, e) {
            const n = this.elements;
            return n[0] *= t,
            n[3] *= t,
            n[6] *= t,
            n[1] *= e,
            n[4] *= e,
            n[7] *= e,
            this
        }
        rotate(t) {
            const e = Math.cos(t)
              , n = Math.sin(t)
              , i = this.elements
              , r = i[0]
              , o = i[3]
              , s = i[6]
              , a = i[1]
              , l = i[4]
              , c = i[7];
            return i[0] = e * r + n * a,
            i[3] = e * o + n * l,
            i[6] = e * s + n * c,
            i[1] = -n * r + e * a,
            i[4] = -n * o + e * l,
            i[7] = -n * s + e * c,
            this
        }
        translate(t, e) {
            const n = this.elements;
            return n[0] += t * n[2],
            n[3] += t * n[5],
            n[6] += t * n[8],
            n[1] += e * n[2],
            n[4] += e * n[5],
            n[7] += e * n[8],
            this
        }
        equals(t) {
            const e = this.elements
              , n = t.elements;
            for (let t = 0; t < 9; t++)
                if (e[t] !== n[t])
                    return !1;
            return !0
        }
        fromArray(t, e=0) {
            for (let n = 0; n < 9; n++)
                this.elements[n] = t[n + e];
            return this
        }
        toArray(t=[], e=0) {
            const n = this.elements;
            return t[e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t
        }
    }
    let ot;
    const st = {
        getDataURL: function(t) {
            if (/^data:/i.test(t.src))
                return t.src;
            if ("undefined" == typeof HTMLCanvasElement)
                return t.src;
            let e;
            if (t instanceof HTMLCanvasElement)
                e = t;
            else {
                void 0 === ot && (ot = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                ot.width = t.width,
                ot.height = t.height;
                const n = ot.getContext("2d");
                t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height),
                e = ot
            }
            return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
        }
    };
    let at = 0;
    function lt(t=lt.DEFAULT_IMAGE, e=lt.DEFAULT_MAPPING, n=1001, i=1001, r=1006, o=1008, s=1023, a=1009, l=1, c=3e3) {
        Object.defineProperty(this, "id", {
            value: at++
        }),
        this.uuid = nt.generateUUID(),
        this.name = "",
        this.image = t,
        this.mipmaps = [],
        this.mapping = e,
        this.wrapS = n,
        this.wrapT = i,
        this.magFilter = r,
        this.minFilter = o,
        this.anisotropy = l,
        this.format = s,
        this.internalFormat = null,
        this.type = a,
        this.offset = new it(0,0),
        this.repeat = new it(1,1),
        this.center = new it(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new rt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = c,
        this.version = 0,
        this.onUpdate = null
    }
    function ct(t) {
        return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? st.getDataURL(t) : t.data ? {
            data: Array.prototype.slice.call(t.data),
            width: t.width,
            height: t.height,
            type: t.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."),
        {})
    }
    lt.DEFAULT_IMAGE = void 0,
    lt.DEFAULT_MAPPING = 300,
    lt.prototype = Object.assign(Object.create($.prototype), {
        constructor: lt,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name,
            this.image = t.image,
            this.mipmaps = t.mipmaps.slice(0),
            this.mapping = t.mapping,
            this.wrapS = t.wrapS,
            this.wrapT = t.wrapT,
            this.magFilter = t.magFilter,
            this.minFilter = t.minFilter,
            this.anisotropy = t.anisotropy,
            this.format = t.format,
            this.internalFormat = t.internalFormat,
            this.type = t.type,
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            this.rotation = t.rotation,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrix.copy(t.matrix),
            this.generateMipmaps = t.generateMipmaps,
            this.premultiplyAlpha = t.premultiplyAlpha,
            this.flipY = t.flipY,
            this.unpackAlignment = t.unpackAlignment,
            this.encoding = t.encoding,
            this
        },
        toJSON: function(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
                return t.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                const i = this.image;
                if (void 0 === i.uuid && (i.uuid = nt.generateUUID()),
                !e && void 0 === t.images[i.uuid]) {
                    let e;
                    if (Array.isArray(i)) {
                        e = [];
                        for (let t = 0, n = i.length; t < n; t++)
                            i[t].isDataTexture ? e.push(ct(i[t].image)) : e.push(ct(i[t]))
                    } else
                        e = ct(i);
                    t.images[i.uuid] = {
                        uuid: i.uuid,
                        url: e
                    }
                }
                n.image = i.uuid
            }
            return e || (t.textures[this.uuid] = n),
            n
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (300 !== this.mapping)
                return t;
            if (t.applyMatrix3(this.matrix),
            t.x < 0 || t.x > 1)
                switch (this.wrapS) {
                case x:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case b:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case w:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                }
            if (t.y < 0 || t.y > 1)
                switch (this.wrapT) {
                case x:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case b:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case w:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                }
            return this.flipY && (t.y = 1 - t.y),
            t
        }
    }),
    Object.defineProperty(lt.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    });
    class ut {
        constructor(t=0, e=0, n=0, i=1) {
            Object.defineProperty(this, "isVector4", {
                value: !0
            }),
            this.x = t,
            this.y = e,
            this.z = n,
            this.w = i
        }
        get width() {
            return this.z
        }
        set width(t) {
            this.z = t
        }
        get height() {
            return this.w
        }
        set height(t) {
            this.w = t
        }
        set(t, e, n, i) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this.w = i,
            this
        }
        setScalar(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this.w = t,
            this
        }
        setX(t) {
            return this.x = t,
            this
        }
        setY(t) {
            return this.y = t,
            this
        }
        setZ(t) {
            return this.z = t,
            this
        }
        setW(t) {
            return this.w = t,
            this
        }
        setComponent(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this.w = void 0 !== t.w ? t.w : 1,
            this
        }
        add(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this.w += t.w,
            this)
        }
        addScalar(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this.w += t,
            this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this.w = t.w + e.w,
            this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this.w += t.w * e,
            this
        }
        sub(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this.w -= t.w,
            this)
        }
        subScalar(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this.w -= t,
            this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this.w = t.w - e.w,
            this
        }
        multiplyScalar(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this.w *= t,
            this
        }
        applyMatrix4(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = this.w
              , o = t.elements;
            return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r,
            this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r,
            this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r,
            this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r,
            this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = t.x / e,
            this.y = t.y / e,
            this.z = t.z / e),
            this
        }
        setAxisAngleFromRotationMatrix(t) {
            let e, n, i, r;
            const o = .01
              , s = .1
              , a = t.elements
              , l = a[0]
              , c = a[4]
              , u = a[8]
              , h = a[1]
              , d = a[5]
              , p = a[9]
              , f = a[2]
              , m = a[6]
              , g = a[10];
            if (Math.abs(c - h) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
                if (Math.abs(c + h) < s && Math.abs(u + f) < s && Math.abs(p + m) < s && Math.abs(l + d + g - 3) < s)
                    return this.set(1, 0, 0, 0),
                    this;
                e = Math.PI;
                const t = (l + 1) / 2
                  , a = (d + 1) / 2
                  , v = (g + 1) / 2
                  , y = (c + h) / 4
                  , _ = (u + f) / 4
                  , x = (p + m) / 4;
                return t > a && t > v ? t < o ? (n = 0,
                i = .707106781,
                r = .707106781) : (n = Math.sqrt(t),
                i = y / n,
                r = _ / n) : a > v ? a < o ? (n = .707106781,
                i = 0,
                r = .707106781) : (i = Math.sqrt(a),
                n = y / i,
                r = x / i) : v < o ? (n = .707106781,
                i = .707106781,
                r = 0) : (r = Math.sqrt(v),
                n = _ / r,
                i = x / r),
                this.set(n, i, r, e),
                this
            }
            let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
            return Math.abs(v) < .001 && (v = 1),
            this.x = (m - p) / v,
            this.y = (u - f) / v,
            this.z = (h - c) / v,
            this.w = Math.acos((l + d + g - 1) / 2),
            this
        }
        min(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this.w = Math.min(this.w, t.w),
            this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this.w = Math.max(this.w, t.w),
            this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this.w = Math.max(t.w, Math.min(e.w, this.w)),
            this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this.z = Math.max(t, Math.min(e, this.z)),
            this.w = Math.max(t, Math.min(e, this.w)),
            this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this.w += (t.w - this.w) * e,
            this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n,
            this.y = t.y + (e.y - t.y) * n,
            this.z = t.z + (e.z - t.z) * n,
            this.w = t.w + (e.w - t.w) * n,
            this
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        }
        fromArray(t, e=0) {
            return this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this.w = t[e + 3],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t[e + 3] = this.w,
            t
        }
        fromBufferAttribute(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this.w = t.getW(e),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this.w = Math.random(),
            this
        }
    }
    function ht(t, e, n) {
        this.width = t,
        this.height = e,
        this.scissor = new ut(0,0,t,e),
        this.scissorTest = !1,
        this.viewport = new ut(0,0,t,e),
        n = n || {},
        this.texture = new lt(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
        this.texture.image = {},
        this.texture.image.width = t,
        this.texture.image.height = e,
        this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
        this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : D,
        this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
        this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer,
        this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
    }
    function dt(t, e, n) {
        ht.call(this, t, e, n),
        this.samples = 4
    }
    ht.prototype = Object.assign(Object.create($.prototype), {
        constructor: ht,
        isWebGLRenderTarget: !0,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t,
            this.height = e,
            this.texture.image.width = t,
            this.texture.image.height = e,
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width,
            this.height = t.height,
            this.viewport.copy(t.viewport),
            this.texture = t.texture.clone(),
            this.depthBuffer = t.depthBuffer,
            this.stencilBuffer = t.stencilBuffer,
            this.depthTexture = t.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    dt.prototype = Object.assign(Object.create(ht.prototype), {
        constructor: dt,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(t) {
            return ht.prototype.copy.call(this, t),
            this.samples = t.samples,
            this
        }
    });
    class pt {
        constructor(t=0, e=0, n=0, i=1) {
            Object.defineProperty(this, "isQuaternion", {
                value: !0
            }),
            this._x = t,
            this._y = e,
            this._z = n,
            this._w = i
        }
        static slerp(t, e, n, i) {
            return n.copy(t).slerp(e, i)
        }
        static slerpFlat(t, e, n, i, r, o, s) {
            let a = n[i + 0]
              , l = n[i + 1]
              , c = n[i + 2]
              , u = n[i + 3];
            const h = r[o + 0]
              , d = r[o + 1]
              , p = r[o + 2]
              , f = r[o + 3];
            if (u !== f || a !== h || l !== d || c !== p) {
                let t = 1 - s;
                const e = a * h + l * d + c * p + u * f
                  , n = e >= 0 ? 1 : -1
                  , i = 1 - e * e;
                if (i > Number.EPSILON) {
                    const r = Math.sqrt(i)
                      , o = Math.atan2(r, e * n);
                    t = Math.sin(t * o) / r,
                    s = Math.sin(s * o) / r
                }
                const r = s * n;
                if (a = a * t + h * r,
                l = l * t + d * r,
                c = c * t + p * r,
                u = u * t + f * r,
                t === 1 - s) {
                    const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
                    a *= t,
                    l *= t,
                    c *= t,
                    u *= t
                }
            }
            t[e] = a,
            t[e + 1] = l,
            t[e + 2] = c,
            t[e + 3] = u
        }
        static multiplyQuaternionsFlat(t, e, n, i, r, o) {
            const s = n[i]
              , a = n[i + 1]
              , l = n[i + 2]
              , c = n[i + 3]
              , u = r[o]
              , h = r[o + 1]
              , d = r[o + 2]
              , p = r[o + 3];
            return t[e] = s * p + c * u + a * d - l * h,
            t[e + 1] = a * p + c * h + l * u - s * d,
            t[e + 2] = l * p + c * d + s * h - a * u,
            t[e + 3] = c * p - s * u - a * h - l * d,
            t
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x = t,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y = t,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(t) {
            this._z = t,
            this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(t) {
            this._w = t,
            this._onChangeCallback()
        }
        set(t, e, n, i) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._w = i,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        }
        copy(t) {
            return this._x = t.x,
            this._y = t.y,
            this._z = t.z,
            this._w = t.w,
            this._onChangeCallback(),
            this
        }
        setFromEuler(t, e) {
            if (!t || !t.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            const n = t._x
              , i = t._y
              , r = t._z
              , o = t._order
              , s = Math.cos
              , a = Math.sin
              , l = s(n / 2)
              , c = s(i / 2)
              , u = s(r / 2)
              , h = a(n / 2)
              , d = a(i / 2)
              , p = a(r / 2);
            switch (o) {
            case "XYZ":
                this._x = h * c * u + l * d * p,
                this._y = l * d * u - h * c * p,
                this._z = l * c * p + h * d * u,
                this._w = l * c * u - h * d * p;
                break;
            case "YXZ":
                this._x = h * c * u + l * d * p,
                this._y = l * d * u - h * c * p,
                this._z = l * c * p - h * d * u,
                this._w = l * c * u + h * d * p;
                break;
            case "ZXY":
                this._x = h * c * u - l * d * p,
                this._y = l * d * u + h * c * p,
                this._z = l * c * p + h * d * u,
                this._w = l * c * u - h * d * p;
                break;
            case "ZYX":
                this._x = h * c * u - l * d * p,
                this._y = l * d * u + h * c * p,
                this._z = l * c * p - h * d * u,
                this._w = l * c * u + h * d * p;
                break;
            case "YZX":
                this._x = h * c * u + l * d * p,
                this._y = l * d * u + h * c * p,
                this._z = l * c * p - h * d * u,
                this._w = l * c * u - h * d * p;
                break;
            case "XZY":
                this._x = h * c * u - l * d * p,
                this._y = l * d * u - h * c * p,
                this._z = l * c * p + h * d * u,
                this._w = l * c * u + h * d * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
            }
            return !1 !== e && this._onChangeCallback(),
            this
        }
        setFromAxisAngle(t, e) {
            const n = e / 2
              , i = Math.sin(n);
            return this._x = t.x * i,
            this._y = t.y * i,
            this._z = t.z * i,
            this._w = Math.cos(n),
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(t) {
            const e = t.elements
              , n = e[0]
              , i = e[4]
              , r = e[8]
              , o = e[1]
              , s = e[5]
              , a = e[9]
              , l = e[2]
              , c = e[6]
              , u = e[10]
              , h = n + s + u;
            if (h > 0) {
                const t = .5 / Math.sqrt(h + 1);
                this._w = .25 / t,
                this._x = (c - a) * t,
                this._y = (r - l) * t,
                this._z = (o - i) * t
            } else if (n > s && n > u) {
                const t = 2 * Math.sqrt(1 + n - s - u);
                this._w = (c - a) / t,
                this._x = .25 * t,
                this._y = (i + o) / t,
                this._z = (r + l) / t
            } else if (s > u) {
                const t = 2 * Math.sqrt(1 + s - n - u);
                this._w = (r - l) / t,
                this._x = (i + o) / t,
                this._y = .25 * t,
                this._z = (a + c) / t
            } else {
                const t = 2 * Math.sqrt(1 + u - n - s);
                this._w = (o - i) / t,
                this._x = (r + l) / t,
                this._y = (a + c) / t,
                this._z = .25 * t
            }
            return this._onChangeCallback(),
            this
        }
        setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return n < 1e-6 ? (n = 0,
            Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y,
            this._y = t.x,
            this._z = 0,
            this._w = n) : (this._x = 0,
            this._y = -t.z,
            this._z = t.y,
            this._w = n)) : (this._x = t.y * e.z - t.z * e.y,
            this._y = t.z * e.x - t.x * e.z,
            this._z = t.x * e.y - t.y * e.x,
            this._w = n),
            this.normalize()
        }
        angleTo(t) {
            return 2 * Math.acos(Math.abs(nt.clamp(this.dot(t), -1, 1)))
        }
        rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n)
                return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i),
            this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this._onChangeCallback(),
            this
        }
        dot(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let t = this.length();
            return 0 === t ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (t = 1 / t,
            this._x = this._x * t,
            this._y = this._y * t,
            this._z = this._z * t,
            this._w = this._w * t),
            this._onChangeCallback(),
            this
        }
        multiply(t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        }
        premultiply(t) {
            return this.multiplyQuaternions(t, this)
        }
        multiplyQuaternions(t, e) {
            const n = t._x
              , i = t._y
              , r = t._z
              , o = t._w
              , s = e._x
              , a = e._y
              , l = e._z
              , c = e._w;
            return this._x = n * c + o * s + i * l - r * a,
            this._y = i * c + o * a + r * s - n * l,
            this._z = r * c + o * l + n * a - i * s,
            this._w = o * c - n * s - i * a - r * l,
            this._onChangeCallback(),
            this
        }
        slerp(t, e) {
            if (0 === e)
                return this;
            if (1 === e)
                return this.copy(t);
            const n = this._x
              , i = this._y
              , r = this._z
              , o = this._w;
            let s = o * t._w + n * t._x + i * t._y + r * t._z;
            if (s < 0 ? (this._w = -t._w,
            this._x = -t._x,
            this._y = -t._y,
            this._z = -t._z,
            s = -s) : this.copy(t),
            s >= 1)
                return this._w = o,
                this._x = n,
                this._y = i,
                this._z = r,
                this;
            const a = 1 - s * s;
            if (a <= Number.EPSILON) {
                const t = 1 - e;
                return this._w = t * o + e * this._w,
                this._x = t * n + e * this._x,
                this._y = t * i + e * this._y,
                this._z = t * r + e * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this
            }
            const l = Math.sqrt(a)
              , c = Math.atan2(l, s)
              , u = Math.sin((1 - e) * c) / l
              , h = Math.sin(e * c) / l;
            return this._w = o * u + this._w * h,
            this._x = n * u + this._x * h,
            this._y = i * u + this._y * h,
            this._z = r * u + this._z * h,
            this._onChangeCallback(),
            this
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        }
        fromArray(t, e=0) {
            return this._x = t[e],
            this._y = t[e + 1],
            this._z = t[e + 2],
            this._w = t[e + 3],
            this._onChangeCallback(),
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._w,
            t
        }
        fromBufferAttribute(t, e) {
            return this._x = t.getX(e),
            this._y = t.getY(e),
            this._z = t.getZ(e),
            this._w = t.getW(e),
            this
        }
        _onChange(t) {
            return this._onChangeCallback = t,
            this
        }
        _onChangeCallback() {}
    }
    class ft {
        constructor(t=0, e=0, n=0) {
            Object.defineProperty(this, "isVector3", {
                value: !0
            }),
            this.x = t,
            this.y = e,
            this.z = n
        }
        set(t, e, n) {
            return void 0 === n && (n = this.z),
            this.x = t,
            this.y = e,
            this.z = n,
            this
        }
        setScalar(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this
        }
        setX(t) {
            return this.x = t,
            this
        }
        setY(t) {
            return this.y = t,
            this
        }
        setZ(t) {
            return this.z = t,
            this
        }
        setComponent(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        }
        getComponent(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z)
        }
        copy(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this
        }
        add(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(t, e)) : (this.x += t.x,
            this.y += t.y,
            this.z += t.z,
            this)
        }
        addScalar(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this
        }
        addVectors(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this
        }
        addScaledVector(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this
        }
        sub(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(t, e)) : (this.x -= t.x,
            this.y -= t.y,
            this.z -= t.z,
            this)
        }
        subScalar(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this
        }
        subVectors(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this
        }
        multiply(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(t, e)) : (this.x *= t.x,
            this.y *= t.y,
            this.z *= t.z,
            this)
        }
        multiplyScalar(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this
        }
        multiplyVectors(t, e) {
            return this.x = t.x * e.x,
            this.y = t.y * e.y,
            this.z = t.z * e.z,
            this
        }
        applyEuler(t) {
            return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(gt.setFromEuler(t))
        }
        applyAxisAngle(t, e) {
            return this.applyQuaternion(gt.setFromAxisAngle(t, e))
        }
        applyMatrix3(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * i,
            this.y = r[1] * e + r[4] * n + r[7] * i,
            this.z = r[2] * e + r[5] * n + r[8] * i,
            this
        }
        applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize()
        }
        applyMatrix4(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = t.elements
              , o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o,
            this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o,
            this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o,
            this
        }
        applyQuaternion(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = t.x
              , o = t.y
              , s = t.z
              , a = t.w
              , l = a * e + o * i - s * n
              , c = a * n + s * e - r * i
              , u = a * i + r * n - o * e
              , h = -r * e - o * n - s * i;
            return this.x = l * a + h * -r + c * -s - u * -o,
            this.y = c * a + h * -o + u * -r - l * -s,
            this.z = u * a + h * -s + l * -o - c * -r,
            this
        }
        project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        }
        unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
        }
        transformDirection(t) {
            const e = this.x
              , n = this.y
              , i = this.z
              , r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * i,
            this.y = r[1] * e + r[5] * n + r[9] * i,
            this.z = r[2] * e + r[6] * n + r[10] * i,
            this.normalize()
        }
        divide(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this.z /= t.z,
            this
        }
        divideScalar(t) {
            return this.multiplyScalar(1 / t)
        }
        min(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this
        }
        max(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this
        }
        clamp(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this
        }
        clampScalar(t, e) {
            return this.x = Math.max(t, Math.min(e, this.x)),
            this.y = Math.max(t, Math.min(e, this.y)),
            this.z = Math.max(t, Math.min(e, this.z)),
            this
        }
        clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        }
        dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(t) {
            return this.normalize().multiplyScalar(t)
        }
        lerp(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this
        }
        lerpVectors(t, e, n) {
            return this.x = t.x + (e.x - t.x) * n,
            this.y = t.y + (e.y - t.y) * n,
            this.z = t.z + (e.z - t.z) * n,
            this
        }
        cross(t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(t, e)) : this.crossVectors(this, t)
        }
        crossVectors(t, e) {
            const n = t.x
              , i = t.y
              , r = t.z
              , o = e.x
              , s = e.y
              , a = e.z;
            return this.x = i * a - r * s,
            this.y = r * o - n * a,
            this.z = n * s - i * o,
            this
        }
        projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e)
                return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n)
        }
        projectOnPlane(t) {
            return mt.copy(this).projectOnVector(t),
            this.sub(mt)
        }
        reflect(t) {
            return this.sub(mt.copy(t).multiplyScalar(2 * this.dot(t)))
        }
        angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e)
                return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(nt.clamp(n, -1, 1))
        }
        distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t))
        }
        distanceToSquared(t) {
            const e = this.x - t.x
              , n = this.y - t.y
              , i = this.z - t.z;
            return e * e + n * n + i * i
        }
        manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        }
        setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        }
        setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t;
            return this.x = i * Math.sin(n),
            this.y = Math.cos(e) * t,
            this.z = i * Math.cos(n),
            this
        }
        setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        }
        setFromCylindricalCoords(t, e, n) {
            return this.x = t * Math.sin(e),
            this.y = n,
            this.z = t * Math.cos(e),
            this
        }
        setFromMatrixPosition(t) {
            const e = t.elements;
            return this.x = e[12],
            this.y = e[13],
            this.z = e[14],
            this
        }
        setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length()
              , n = this.setFromMatrixColumn(t, 1).length()
              , i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e,
            this.y = n,
            this.z = i,
            this
        }
        setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e)
        }
        setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e)
        }
        equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        }
        fromArray(t, e=0) {
            return this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t
        }
        fromBufferAttribute(t, e, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this
        }
    }
    const mt = new ft
      , gt = new pt;
    class vt {
        constructor(t, e) {
            Object.defineProperty(this, "isBox3", {
                value: !0
            }),
            this.min = void 0 !== t ? t : new ft(1 / 0,1 / 0,1 / 0),
            this.max = void 0 !== e ? e : new ft(-1 / 0,-1 / 0,-1 / 0)
        }
        set(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        }
        setFromArray(t) {
            let e = 1 / 0
              , n = 1 / 0
              , i = 1 / 0
              , r = -1 / 0
              , o = -1 / 0
              , s = -1 / 0;
            for (let a = 0, l = t.length; a < l; a += 3) {
                const l = t[a]
                  , c = t[a + 1]
                  , u = t[a + 2];
                l < e && (e = l),
                c < n && (n = c),
                u < i && (i = u),
                l > r && (r = l),
                c > o && (o = c),
                u > s && (s = u)
            }
            return this.min.set(e, n, i),
            this.max.set(r, o, s),
            this
        }
        setFromBufferAttribute(t) {
            let e = 1 / 0
              , n = 1 / 0
              , i = 1 / 0
              , r = -1 / 0
              , o = -1 / 0
              , s = -1 / 0;
            for (let a = 0, l = t.count; a < l; a++) {
                const l = t.getX(a)
                  , c = t.getY(a)
                  , u = t.getZ(a);
                l < e && (e = l),
                c < n && (n = c),
                u < i && (i = u),
                l > r && (r = l),
                c > o && (o = c),
                u > s && (s = u)
            }
            return this.min.set(e, n, i),
            this.max.set(r, o, s),
            this
        }
        setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        }
        setFromCenterAndSize(t, e) {
            const n = xt.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n),
            this.max.copy(t).add(n),
            this
        }
        setFromObject(t) {
            return this.makeEmpty(),
            this.expandByObject(t)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"),
            t = new ft),
            this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(t) {
            return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"),
            t = new ft),
            this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        }
        expandByPoint(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        }
        expandByVector(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        }
        expandByScalar(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        }
        expandByObject(t) {
            t.updateWorldMatrix(!1, !1);
            const e = t.geometry;
            void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(),
            bt.copy(e.boundingBox),
            bt.applyMatrix4(t.matrixWorld),
            this.union(bt));
            const n = t.children;
            for (let t = 0, e = n.length; t < e; t++)
                this.expandByObject(n[t]);
            return this
        }
        containsPoint(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        }
        containsBox(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        }
        getParameter(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"),
            e = new ft),
            e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        }
        intersectsSphere(t) {
            return this.clampPoint(t.center, xt),
            xt.distanceToSquared(t.center) <= t.radius * t.radius
        }
        intersectsPlane(t) {
            let e, n;
            return t.normal.x > 0 ? (e = t.normal.x * this.min.x,
            n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x,
            n = t.normal.x * this.min.x),
            t.normal.y > 0 ? (e += t.normal.y * this.min.y,
            n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y,
            n += t.normal.y * this.min.y),
            t.normal.z > 0 ? (e += t.normal.z * this.min.z,
            n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z,
            n += t.normal.z * this.min.z),
            e <= -t.constant && n >= -t.constant
        }
        intersectsTriangle(t) {
            if (this.isEmpty())
                return !1;
            this.getCenter(At),
            Ct.subVectors(this.max, At),
            wt.subVectors(t.a, At),
            Mt.subVectors(t.b, At),
            St.subVectors(t.c, At),
            Et.subVectors(Mt, wt),
            Dt.subVectors(St, Mt),
            Tt.subVectors(wt, St);
            let e = [0, -Et.z, Et.y, 0, -Dt.z, Dt.y, 0, -Tt.z, Tt.y, Et.z, 0, -Et.x, Dt.z, 0, -Dt.x, Tt.z, 0, -Tt.x, -Et.y, Et.x, 0, -Dt.y, Dt.x, 0, -Tt.y, Tt.x, 0];
            return !!yt(e, wt, Mt, St, Ct) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            !!yt(e, wt, Mt, St, Ct) && (Lt.crossVectors(Et, Dt),
            e = [Lt.x, Lt.y, Lt.z],
            yt(e, wt, Mt, St, Ct)))
        }
        clampPoint(t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"),
            e = new ft),
            e.copy(t).clamp(this.min, this.max)
        }
        distanceToPoint(t) {
            return xt.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        getBoundingSphere(t) {
            return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
            this.getCenter(t.center),
            t.radius = .5 * this.getSize(xt).length(),
            t
        }
        intersect(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
        }
        union(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        }
        applyMatrix4(t) {
            return this.isEmpty() || (_t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            _t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            _t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            _t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            _t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            _t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            _t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            _t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(_t)),
            this
        }
        translate(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        }
        equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }
    function yt(t, e, n, i, r) {
        for (let o = 0, s = t.length - 3; o <= s; o += 3) {
            Pt.fromArray(t, o);
            const s = r.x * Math.abs(Pt.x) + r.y * Math.abs(Pt.y) + r.z * Math.abs(Pt.z)
              , a = e.dot(Pt)
              , l = n.dot(Pt)
              , c = i.dot(Pt);
            if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > s)
                return !1
        }
        return !0
    }
    const _t = [new ft, new ft, new ft, new ft, new ft, new ft, new ft, new ft]
      , xt = new ft
      , bt = new vt
      , wt = new ft
      , Mt = new ft
      , St = new ft
      , Et = new ft
      , Dt = new ft
      , Tt = new ft
      , At = new ft
      , Ct = new ft
      , Lt = new ft
      , Pt = new ft
      , Rt = new vt;
    class Ot {
        constructor(t, e) {
            this.center = void 0 !== t ? t : new ft,
            this.radius = void 0 !== e ? e : -1
        }
        set(t, e) {
            return this.center.copy(t),
            this.radius = e,
            this
        }
        setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : Rt.setFromPoints(t).getCenter(n);
            let i = 0;
            for (let e = 0, r = t.length; e < r; e++)
                i = Math.max(i, n.distanceToSquared(t[e]));
            return this.radius = Math.sqrt(i),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.center.copy(t.center),
            this.radius = t.radius,
            this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0),
            this.radius = -1,
            this
        }
        containsPoint(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius
        }
        intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        }
        intersectsBox(t) {
            return t.intersectsSphere(this)
        }
        intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            e = new ft),
            e.copy(t),
            n > this.radius * this.radius && (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
            e
        }
        getBoundingBox(t) {
            return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
            t = new vt),
            this.isEmpty() ? (t.makeEmpty(),
            t) : (t.set(this.center, this.center),
            t.expandByScalar(this.radius),
            t)
        }
        applyMatrix4(t) {
            return this.center.applyMatrix4(t),
            this.radius = this.radius * t.getMaxScaleOnAxis(),
            this
        }
        translate(t) {
            return this.center.add(t),
            this
        }
        equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    }
    const Ft = new ft
      , Nt = new ft
      , It = new ft
      , Bt = new ft
      , kt = new ft
      , zt = new ft
      , Ut = new ft;
    class Ht {
        constructor(t, e) {
            this.origin = void 0 !== t ? t : new ft,
            this.direction = void 0 !== e ? e : new ft(0,0,-1)
        }
        set(t, e) {
            return this.origin.copy(t),
            this.direction.copy(e),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.origin.copy(t.origin),
            this.direction.copy(t.direction),
            this
        }
        at(t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"),
            e = new ft),
            e.copy(this.direction).multiplyScalar(t).add(this.origin)
        }
        lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(),
            this
        }
        recast(t) {
            return this.origin.copy(this.at(t, Ft)),
            this
        }
        closestPointToPoint(t, e) {
            void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
            e = new ft),
            e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
        }
        distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        }
        distanceSqToPoint(t) {
            const e = Ft.subVectors(t, this.origin).dot(this.direction);
            return e < 0 ? this.origin.distanceToSquared(t) : (Ft.copy(this.direction).multiplyScalar(e).add(this.origin),
            Ft.distanceToSquared(t))
        }
        distanceSqToSegment(t, e, n, i) {
            Nt.copy(t).add(e).multiplyScalar(.5),
            It.copy(e).sub(t).normalize(),
            Bt.copy(this.origin).sub(Nt);
            const r = .5 * t.distanceTo(e)
              , o = -this.direction.dot(It)
              , s = Bt.dot(this.direction)
              , a = -Bt.dot(It)
              , l = Bt.lengthSq()
              , c = Math.abs(1 - o * o);
            let u, h, d, p;
            if (c > 0)
                if (u = o * a - s,
                h = o * s - a,
                p = r * c,
                u >= 0)
                    if (h >= -p)
                        if (h <= p) {
                            const t = 1 / c;
                            u *= t,
                            h *= t,
                            d = u * (u + o * h + 2 * s) + h * (o * u + h + 2 * a) + l
                        } else
                            h = r,
                            u = Math.max(0, -(o * h + s)),
                            d = -u * u + h * (h + 2 * a) + l;
                    else
                        h = -r,
                        u = Math.max(0, -(o * h + s)),
                        d = -u * u + h * (h + 2 * a) + l;
                else
                    h <= -p ? (u = Math.max(0, -(-o * r + s)),
                    h = u > 0 ? -r : Math.min(Math.max(-r, -a), r),
                    d = -u * u + h * (h + 2 * a) + l) : h <= p ? (u = 0,
                    h = Math.min(Math.max(-r, -a), r),
                    d = h * (h + 2 * a) + l) : (u = Math.max(0, -(o * r + s)),
                    h = u > 0 ? r : Math.min(Math.max(-r, -a), r),
                    d = -u * u + h * (h + 2 * a) + l);
            else
                h = o > 0 ? -r : r,
                u = Math.max(0, -(o * h + s)),
                d = -u * u + h * (h + 2 * a) + l;
            return n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
            i && i.copy(It).multiplyScalar(h).add(Nt),
            d
        }
        intersectSphere(t, e) {
            Ft.subVectors(t.center, this.origin);
            const n = Ft.dot(this.direction)
              , i = Ft.dot(Ft) - n * n
              , r = t.radius * t.radius;
            if (i > r)
                return null;
            const o = Math.sqrt(r - i)
              , s = n - o
              , a = n + o;
            return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e)
        }
        intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        }
        distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e)
                return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null
        }
        intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e)
        }
        intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            if (0 === e)
                return !0;
            return t.normal.dot(this.direction) * e < 0
        }
        intersectBox(t, e) {
            let n, i, r, o, s, a;
            const l = 1 / this.direction.x
              , c = 1 / this.direction.y
              , u = 1 / this.direction.z
              , h = this.origin;
            return l >= 0 ? (n = (t.min.x - h.x) * l,
            i = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l,
            i = (t.min.x - h.x) * l),
            c >= 0 ? (r = (t.min.y - h.y) * c,
            o = (t.max.y - h.y) * c) : (r = (t.max.y - h.y) * c,
            o = (t.min.y - h.y) * c),
            n > o || r > i ? null : ((r > n || n != n) && (n = r),
            (o < i || i != i) && (i = o),
            u >= 0 ? (s = (t.min.z - h.z) * u,
            a = (t.max.z - h.z) * u) : (s = (t.max.z - h.z) * u,
            a = (t.min.z - h.z) * u),
            n > a || s > i ? null : ((s > n || n != n) && (n = s),
            (a < i || i != i) && (i = a),
            i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        }
        intersectsBox(t) {
            return null !== this.intersectBox(t, Ft)
        }
        intersectTriangle(t, e, n, i, r) {
            kt.subVectors(e, t),
            zt.subVectors(n, t),
            Ut.crossVectors(kt, zt);
            let o, s = this.direction.dot(Ut);
            if (s > 0) {
                if (i)
                    return null;
                o = 1
            } else {
                if (!(s < 0))
                    return null;
                o = -1,
                s = -s
            }
            Bt.subVectors(this.origin, t);
            const a = o * this.direction.dot(zt.crossVectors(Bt, zt));
            if (a < 0)
                return null;
            const l = o * this.direction.dot(kt.cross(Bt));
            if (l < 0)
                return null;
            if (a + l > s)
                return null;
            const c = -o * Bt.dot(Ut);
            return c < 0 ? null : this.at(c / s, r)
        }
        applyMatrix4(t) {
            return this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
        }
        equals(t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    }
    class Gt {
        constructor() {
            Object.defineProperty(this, "isMatrix4", {
                value: !0
            }),
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }
        set(t, e, n, i, r, o, s, a, l, c, u, h, d, p, f, m) {
            const g = this.elements;
            return g[0] = t,
            g[4] = e,
            g[8] = n,
            g[12] = i,
            g[1] = r,
            g[5] = o,
            g[9] = s,
            g[13] = a,
            g[2] = l,
            g[6] = c,
            g[10] = u,
            g[14] = h,
            g[3] = d,
            g[7] = p,
            g[11] = f,
            g[15] = m,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        clone() {
            return (new Gt).fromArray(this.elements)
        }
        copy(t) {
            const e = this.elements
              , n = t.elements;
            return e[0] = n[0],
            e[1] = n[1],
            e[2] = n[2],
            e[3] = n[3],
            e[4] = n[4],
            e[5] = n[5],
            e[6] = n[6],
            e[7] = n[7],
            e[8] = n[8],
            e[9] = n[9],
            e[10] = n[10],
            e[11] = n[11],
            e[12] = n[12],
            e[13] = n[13],
            e[14] = n[14],
            e[15] = n[15],
            this
        }
        copyPosition(t) {
            const e = this.elements
              , n = t.elements;
            return e[12] = n[12],
            e[13] = n[13],
            e[14] = n[14],
            this
        }
        extractBasis(t, e, n) {
            return t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
        }
        makeBasis(t, e, n) {
            return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
            this
        }
        extractRotation(t) {
            const e = this.elements
              , n = t.elements
              , i = 1 / Vt.setFromMatrixColumn(t, 0).length()
              , r = 1 / Vt.setFromMatrixColumn(t, 1).length()
              , o = 1 / Vt.setFromMatrixColumn(t, 2).length();
            return e[0] = n[0] * i,
            e[1] = n[1] * i,
            e[2] = n[2] * i,
            e[3] = 0,
            e[4] = n[4] * r,
            e[5] = n[5] * r,
            e[6] = n[6] * r,
            e[7] = 0,
            e[8] = n[8] * o,
            e[9] = n[9] * o,
            e[10] = n[10] * o,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        }
        makeRotationFromEuler(t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            const e = this.elements
              , n = t.x
              , i = t.y
              , r = t.z
              , o = Math.cos(n)
              , s = Math.sin(n)
              , a = Math.cos(i)
              , l = Math.sin(i)
              , c = Math.cos(r)
              , u = Math.sin(r);
            if ("XYZ" === t.order) {
                const t = o * c
                  , n = o * u
                  , i = s * c
                  , r = s * u;
                e[0] = a * c,
                e[4] = -a * u,
                e[8] = l,
                e[1] = n + i * l,
                e[5] = t - r * l,
                e[9] = -s * a,
                e[2] = r - t * l,
                e[6] = i + n * l,
                e[10] = o * a
            } else if ("YXZ" === t.order) {
                const t = a * c
                  , n = a * u
                  , i = l * c
                  , r = l * u;
                e[0] = t + r * s,
                e[4] = i * s - n,
                e[8] = o * l,
                e[1] = o * u,
                e[5] = o * c,
                e[9] = -s,
                e[2] = n * s - i,
                e[6] = r + t * s,
                e[10] = o * a
            } else if ("ZXY" === t.order) {
                const t = a * c
                  , n = a * u
                  , i = l * c
                  , r = l * u;
                e[0] = t - r * s,
                e[4] = -o * u,
                e[8] = i + n * s,
                e[1] = n + i * s,
                e[5] = o * c,
                e[9] = r - t * s,
                e[2] = -o * l,
                e[6] = s,
                e[10] = o * a
            } else if ("ZYX" === t.order) {
                const t = o * c
                  , n = o * u
                  , i = s * c
                  , r = s * u;
                e[0] = a * c,
                e[4] = i * l - n,
                e[8] = t * l + r,
                e[1] = a * u,
                e[5] = r * l + t,
                e[9] = n * l - i,
                e[2] = -l,
                e[6] = s * a,
                e[10] = o * a
            } else if ("YZX" === t.order) {
                const t = o * a
                  , n = o * l
                  , i = s * a
                  , r = s * l;
                e[0] = a * c,
                e[4] = r - t * u,
                e[8] = i * u + n,
                e[1] = u,
                e[5] = o * c,
                e[9] = -s * c,
                e[2] = -l * c,
                e[6] = n * u + i,
                e[10] = t - r * u
            } else if ("XZY" === t.order) {
                const t = o * a
                  , n = o * l
                  , i = s * a
                  , r = s * l;
                e[0] = a * c,
                e[4] = -u,
                e[8] = l * c,
                e[1] = t * u + r,
                e[5] = o * c,
                e[9] = n * u - i,
                e[2] = i * u - n,
                e[6] = s * c,
                e[10] = r * u + t
            }
            return e[3] = 0,
            e[7] = 0,
            e[11] = 0,
            e[12] = 0,
            e[13] = 0,
            e[14] = 0,
            e[15] = 1,
            this
        }
        makeRotationFromQuaternion(t) {
            return this.compose(Wt, t, qt)
        }
        lookAt(t, e, n) {
            const i = this.elements;
            return Zt.subVectors(t, e),
            0 === Zt.lengthSq() && (Zt.z = 1),
            Zt.normalize(),
            Xt.crossVectors(n, Zt),
            0 === Xt.lengthSq() && (1 === Math.abs(n.z) ? Zt.x += 1e-4 : Zt.z += 1e-4,
            Zt.normalize(),
            Xt.crossVectors(n, Zt)),
            Xt.normalize(),
            Yt.crossVectors(Zt, Xt),
            i[0] = Xt.x,
            i[4] = Yt.x,
            i[8] = Zt.x,
            i[1] = Xt.y,
            i[5] = Yt.y,
            i[9] = Zt.y,
            i[2] = Xt.z,
            i[6] = Yt.z,
            i[10] = Zt.z,
            this
        }
        multiply(t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        }
        premultiply(t) {
            return this.multiplyMatrices(t, this)
        }
        multiplyMatrices(t, e) {
            const n = t.elements
              , i = e.elements
              , r = this.elements
              , o = n[0]
              , s = n[4]
              , a = n[8]
              , l = n[12]
              , c = n[1]
              , u = n[5]
              , h = n[9]
              , d = n[13]
              , p = n[2]
              , f = n[6]
              , m = n[10]
              , g = n[14]
              , v = n[3]
              , y = n[7]
              , _ = n[11]
              , x = n[15]
              , b = i[0]
              , w = i[4]
              , M = i[8]
              , S = i[12]
              , E = i[1]
              , D = i[5]
              , T = i[9]
              , A = i[13]
              , C = i[2]
              , L = i[6]
              , P = i[10]
              , R = i[14]
              , O = i[3]
              , F = i[7]
              , N = i[11]
              , I = i[15];
            return r[0] = o * b + s * E + a * C + l * O,
            r[4] = o * w + s * D + a * L + l * F,
            r[8] = o * M + s * T + a * P + l * N,
            r[12] = o * S + s * A + a * R + l * I,
            r[1] = c * b + u * E + h * C + d * O,
            r[5] = c * w + u * D + h * L + d * F,
            r[9] = c * M + u * T + h * P + d * N,
            r[13] = c * S + u * A + h * R + d * I,
            r[2] = p * b + f * E + m * C + g * O,
            r[6] = p * w + f * D + m * L + g * F,
            r[10] = p * M + f * T + m * P + g * N,
            r[14] = p * S + f * A + m * R + g * I,
            r[3] = v * b + y * E + _ * C + x * O,
            r[7] = v * w + y * D + _ * L + x * F,
            r[11] = v * M + y * T + _ * P + x * N,
            r[15] = v * S + y * A + _ * R + x * I,
            this
        }
        multiplyScalar(t) {
            const e = this.elements;
            return e[0] *= t,
            e[4] *= t,
            e[8] *= t,
            e[12] *= t,
            e[1] *= t,
            e[5] *= t,
            e[9] *= t,
            e[13] *= t,
            e[2] *= t,
            e[6] *= t,
            e[10] *= t,
            e[14] *= t,
            e[3] *= t,
            e[7] *= t,
            e[11] *= t,
            e[15] *= t,
            this
        }
        determinant() {
            const t = this.elements
              , e = t[0]
              , n = t[4]
              , i = t[8]
              , r = t[12]
              , o = t[1]
              , s = t[5]
              , a = t[9]
              , l = t[13]
              , c = t[2]
              , u = t[6]
              , h = t[10]
              , d = t[14];
            return t[3] * (+r * a * u - i * l * u - r * s * h + n * l * h + i * s * d - n * a * d) + t[7] * (+e * a * d - e * l * h + r * o * h - i * o * d + i * l * c - r * a * c) + t[11] * (+e * l * u - e * s * d - r * o * u + n * o * d + r * s * c - n * l * c) + t[15] * (-i * s * c - e * a * u + e * s * h + i * o * u - n * o * h + n * a * c)
        }
        transpose() {
            const t = this.elements;
            let e;
            return e = t[1],
            t[1] = t[4],
            t[4] = e,
            e = t[2],
            t[2] = t[8],
            t[8] = e,
            e = t[6],
            t[6] = t[9],
            t[9] = e,
            e = t[3],
            t[3] = t[12],
            t[12] = e,
            e = t[7],
            t[7] = t[13],
            t[13] = e,
            e = t[11],
            t[11] = t[14],
            t[14] = e,
            this
        }
        setPosition(t, e, n) {
            const i = this.elements;
            return t.isVector3 ? (i[12] = t.x,
            i[13] = t.y,
            i[14] = t.z) : (i[12] = t,
            i[13] = e,
            i[14] = n),
            this
        }
        invert() {
            const t = this.elements
              , e = t[0]
              , n = t[1]
              , i = t[2]
              , r = t[3]
              , o = t[4]
              , s = t[5]
              , a = t[6]
              , l = t[7]
              , c = t[8]
              , u = t[9]
              , h = t[10]
              , d = t[11]
              , p = t[12]
              , f = t[13]
              , m = t[14]
              , g = t[15]
              , v = u * m * l - f * h * l + f * a * d - s * m * d - u * a * g + s * h * g
              , y = p * h * l - c * m * l - p * a * d + o * m * d + c * a * g - o * h * g
              , _ = c * f * l - p * u * l + p * s * d - o * f * d - c * s * g + o * u * g
              , x = p * u * a - c * f * a - p * s * h + o * f * h + c * s * m - o * u * m
              , b = e * v + n * y + i * _ + r * x;
            if (0 === b)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / b;
            return t[0] = v * w,
            t[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * w,
            t[2] = (s * m * r - f * a * r + f * i * l - n * m * l - s * i * g + n * a * g) * w,
            t[3] = (u * a * r - s * h * r - u * i * l + n * h * l + s * i * d - n * a * d) * w,
            t[4] = y * w,
            t[5] = (c * m * r - p * h * r + p * i * d - e * m * d - c * i * g + e * h * g) * w,
            t[6] = (p * a * r - o * m * r - p * i * l + e * m * l + o * i * g - e * a * g) * w,
            t[7] = (o * h * r - c * a * r + c * i * l - e * h * l - o * i * d + e * a * d) * w,
            t[8] = _ * w,
            t[9] = (p * u * r - c * f * r - p * n * d + e * f * d + c * n * g - e * u * g) * w,
            t[10] = (o * f * r - p * s * r + p * n * l - e * f * l - o * n * g + e * s * g) * w,
            t[11] = (c * s * r - o * u * r - c * n * l + e * u * l + o * n * d - e * s * d) * w,
            t[12] = x * w,
            t[13] = (c * f * i - p * u * i + p * n * h - e * f * h - c * n * m + e * u * m) * w,
            t[14] = (p * s * i - o * f * i - p * n * a + e * f * a + o * n * m - e * s * m) * w,
            t[15] = (o * u * i - c * s * i + c * n * a - e * u * a - o * n * h + e * s * h) * w,
            this
        }
        scale(t) {
            const e = this.elements
              , n = t.x
              , i = t.y
              , r = t.z;
            return e[0] *= n,
            e[4] *= i,
            e[8] *= r,
            e[1] *= n,
            e[5] *= i,
            e[9] *= r,
            e[2] *= n,
            e[6] *= i,
            e[10] *= r,
            e[3] *= n,
            e[7] *= i,
            e[11] *= r,
            this
        }
        getMaxScaleOnAxis() {
            const t = this.elements
              , e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]
              , n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6]
              , i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i))
        }
        makeTranslation(t, e, n) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
            this
        }
        makeRotationX(t) {
            const e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
            this
        }
        makeRotationY(t) {
            const e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
            this
        }
        makeRotationZ(t) {
            const e = Math.cos(t)
              , n = Math.sin(t);
            return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        makeRotationAxis(t, e) {
            const n = Math.cos(e)
              , i = Math.sin(e)
              , r = 1 - n
              , o = t.x
              , s = t.y
              , a = t.z
              , l = r * o
              , c = r * s;
            return this.set(l * o + n, l * s - i * a, l * a + i * s, 0, l * s + i * a, c * s + n, c * a - i * o, 0, l * a - i * s, c * a + i * o, r * a * a + n, 0, 0, 0, 0, 1),
            this
        }
        makeScale(t, e, n) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
            this
        }
        makeShear(t, e, n) {
            return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
            this
        }
        compose(t, e, n) {
            const i = this.elements
              , r = e._x
              , o = e._y
              , s = e._z
              , a = e._w
              , l = r + r
              , c = o + o
              , u = s + s
              , h = r * l
              , d = r * c
              , p = r * u
              , f = o * c
              , m = o * u
              , g = s * u
              , v = a * l
              , y = a * c
              , _ = a * u
              , x = n.x
              , b = n.y
              , w = n.z;
            return i[0] = (1 - (f + g)) * x,
            i[1] = (d + _) * x,
            i[2] = (p - y) * x,
            i[3] = 0,
            i[4] = (d - _) * b,
            i[5] = (1 - (h + g)) * b,
            i[6] = (m + v) * b,
            i[7] = 0,
            i[8] = (p + y) * w,
            i[9] = (m - v) * w,
            i[10] = (1 - (h + f)) * w,
            i[11] = 0,
            i[12] = t.x,
            i[13] = t.y,
            i[14] = t.z,
            i[15] = 1,
            this
        }
        decompose(t, e, n) {
            const i = this.elements;
            let r = Vt.set(i[0], i[1], i[2]).length();
            const o = Vt.set(i[4], i[5], i[6]).length()
              , s = Vt.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
            t.x = i[12],
            t.y = i[13],
            t.z = i[14],
            jt.copy(this);
            const a = 1 / r
              , l = 1 / o
              , c = 1 / s;
            return jt.elements[0] *= a,
            jt.elements[1] *= a,
            jt.elements[2] *= a,
            jt.elements[4] *= l,
            jt.elements[5] *= l,
            jt.elements[6] *= l,
            jt.elements[8] *= c,
            jt.elements[9] *= c,
            jt.elements[10] *= c,
            e.setFromRotationMatrix(jt),
            n.x = r,
            n.y = o,
            n.z = s,
            this
        }
        makePerspective(t, e, n, i, r, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            const s = this.elements
              , a = 2 * r / (e - t)
              , l = 2 * r / (n - i)
              , c = (e + t) / (e - t)
              , u = (n + i) / (n - i)
              , h = -(o + r) / (o - r)
              , d = -2 * o * r / (o - r);
            return s[0] = a,
            s[4] = 0,
            s[8] = c,
            s[12] = 0,
            s[1] = 0,
            s[5] = l,
            s[9] = u,
            s[13] = 0,
            s[2] = 0,
            s[6] = 0,
            s[10] = h,
            s[14] = d,
            s[3] = 0,
            s[7] = 0,
            s[11] = -1,
            s[15] = 0,
            this
        }
        makeOrthographic(t, e, n, i, r, o) {
            const s = this.elements
              , a = 1 / (e - t)
              , l = 1 / (n - i)
              , c = 1 / (o - r)
              , u = (e + t) * a
              , h = (n + i) * l
              , d = (o + r) * c;
            return s[0] = 2 * a,
            s[4] = 0,
            s[8] = 0,
            s[12] = -u,
            s[1] = 0,
            s[5] = 2 * l,
            s[9] = 0,
            s[13] = -h,
            s[2] = 0,
            s[6] = 0,
            s[10] = -2 * c,
            s[14] = -d,
            s[3] = 0,
            s[7] = 0,
            s[11] = 0,
            s[15] = 1,
            this
        }
        equals(t) {
            const e = this.elements
              , n = t.elements;
            for (let t = 0; t < 16; t++)
                if (e[t] !== n[t])
                    return !1;
            return !0
        }
        fromArray(t, e=0) {
            for (let n = 0; n < 16; n++)
                this.elements[n] = t[n + e];
            return this
        }
        toArray(t=[], e=0) {
            const n = this.elements;
            return t[e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t[e + 9] = n[9],
            t[e + 10] = n[10],
            t[e + 11] = n[11],
            t[e + 12] = n[12],
            t[e + 13] = n[13],
            t[e + 14] = n[14],
            t[e + 15] = n[15],
            t
        }
    }
    const Vt = new ft
      , jt = new Gt
      , Wt = new ft(0,0,0)
      , qt = new ft(1,1,1)
      , Xt = new ft
      , Yt = new ft
      , Zt = new ft;
    class Jt {
        constructor(t=0, e=0, n=0, i=Jt.DefaultOrder) {
            Object.defineProperty(this, "isEuler", {
                value: !0
            }),
            this._x = t,
            this._y = e,
            this._z = n,
            this._order = i
        }
        get x() {
            return this._x
        }
        set x(t) {
            this._x = t,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(t) {
            this._y = t,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(t) {
            this._z = t,
            this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(t) {
            this._order = t,
            this._onChangeCallback()
        }
        set(t, e, n, i) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._order = i || this._order,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        }
        copy(t) {
            return this._x = t._x,
            this._y = t._y,
            this._z = t._z,
            this._order = t._order,
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(t, e, n) {
            const i = nt.clamp
              , r = t.elements
              , o = r[0]
              , s = r[4]
              , a = r[8]
              , l = r[1]
              , c = r[5]
              , u = r[9]
              , h = r[2]
              , d = r[6]
              , p = r[10];
            switch (e = e || this._order) {
            case "XYZ":
                this._y = Math.asin(i(a, -1, 1)),
                Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, p),
                this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(d, c),
                this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-i(u, -1, 1)),
                Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, p),
                this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, o),
                this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(i(d, -1, 1)),
                Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p),
                this._z = Math.atan2(-s, c)) : (this._y = 0,
                this._z = Math.atan2(l, o));
                break;
            case "ZYX":
                this._y = Math.asin(-i(h, -1, 1)),
                Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p),
                this._z = Math.atan2(l, o)) : (this._x = 0,
                this._z = Math.atan2(-s, c));
                break;
            case "YZX":
                this._z = Math.asin(i(l, -1, 1)),
                Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c),
                this._y = Math.atan2(-h, o)) : (this._x = 0,
                this._y = Math.atan2(a, p));
                break;
            case "XZY":
                this._z = Math.asin(-i(s, -1, 1)),
                Math.abs(s) < .9999999 ? (this._x = Math.atan2(d, c),
                this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-u, p),
                this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
            }
            return this._order = e,
            !1 !== n && this._onChangeCallback(),
            this
        }
        setFromQuaternion(t, e, n) {
            return Qt.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(Qt, e, n)
        }
        setFromVector3(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        }
        reorder(t) {
            return Kt.setFromEuler(this),
            this.setFromQuaternion(Kt, t)
        }
        equals(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        }
        fromArray(t) {
            return this._x = t[0],
            this._y = t[1],
            this._z = t[2],
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._order,
            t
        }
        toVector3(t) {
            return t ? t.set(this._x, this._y, this._z) : new ft(this._x,this._y,this._z)
        }
        _onChange(t) {
            return this._onChangeCallback = t,
            this
        }
        _onChangeCallback() {}
    }
    Jt.DefaultOrder = "XYZ",
    Jt.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    const Qt = new Gt
      , Kt = new pt;
    class $t {
        constructor() {
            this.mask = 1
        }
        set(t) {
            this.mask = 1 << t | 0
        }
        enable(t) {
            this.mask |= 1 << t | 0
        }
        enableAll() {
            this.mask = -1
        }
        toggle(t) {
            this.mask ^= 1 << t | 0
        }
        disable(t) {
            this.mask &= ~(1 << t | 0)
        }
        disableAll() {
            this.mask = 0
        }
        test(t) {
            return 0 != (this.mask & t.mask)
        }
    }
    let te = 0;
    const ee = new ft
      , ne = new pt
      , ie = new Gt
      , re = new ft
      , oe = new ft
      , se = new ft
      , ae = new pt
      , le = new ft(1,0,0)
      , ce = new ft(0,1,0)
      , ue = new ft(0,0,1)
      , he = {
        type: "added"
    }
      , de = {
        type: "removed"
    };
    function pe() {
        Object.defineProperty(this, "id", {
            value: te++
        }),
        this.uuid = nt.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = pe.DefaultUp.clone();
        const t = new ft
          , e = new Jt
          , n = new pt
          , i = new ft(1,1,1);
        e._onChange((function() {
            n.setFromEuler(e, !1)
        }
        )),
        n._onChange((function() {
            e.setFromQuaternion(n, void 0, !1)
        }
        )),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new Gt
            },
            normalMatrix: {
                value: new rt
            }
        }),
        this.matrix = new Gt,
        this.matrixWorld = new Gt,
        this.matrixAutoUpdate = pe.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new $t,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    pe.DefaultUp = new ft(0,1,0),
    pe.DefaultMatrixAutoUpdate = !0,
    pe.prototype = Object.assign(Object.create($.prototype), {
        constructor: pe,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix4: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(t) {
            return this.quaternion.premultiply(t),
            this
        },
        setRotationFromAxisAngle: function(t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        },
        setRotationFromEuler: function(t) {
            this.quaternion.setFromEuler(t, !0)
        },
        setRotationFromMatrix: function(t) {
            this.quaternion.setFromRotationMatrix(t)
        },
        setRotationFromQuaternion: function(t) {
            this.quaternion.copy(t)
        },
        rotateOnAxis: function(t, e) {
            return ne.setFromAxisAngle(t, e),
            this.quaternion.multiply(ne),
            this
        },
        rotateOnWorldAxis: function(t, e) {
            return ne.setFromAxisAngle(t, e),
            this.quaternion.premultiply(ne),
            this
        },
        rotateX: function(t) {
            return this.rotateOnAxis(le, t)
        },
        rotateY: function(t) {
            return this.rotateOnAxis(ce, t)
        },
        rotateZ: function(t) {
            return this.rotateOnAxis(ue, t)
        },
        translateOnAxis: function(t, e) {
            return ee.copy(t).applyQuaternion(this.quaternion),
            this.position.add(ee.multiplyScalar(e)),
            this
        },
        translateX: function(t) {
            return this.translateOnAxis(le, t)
        },
        translateY: function(t) {
            return this.translateOnAxis(ce, t)
        },
        translateZ: function(t) {
            return this.translateOnAxis(ue, t)
        },
        localToWorld: function(t) {
            return t.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function(t) {
            return t.applyMatrix4(ie.copy(this.matrixWorld).invert())
        },
        lookAt: function(t, e, n) {
            t.isVector3 ? re.copy(t) : re.set(t, e, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1),
            oe.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? ie.lookAt(oe, re, this.up) : ie.lookAt(re, oe, this.up),
            this.quaternion.setFromRotationMatrix(ie),
            i && (ie.extractRotation(i.matrixWorld),
            ne.setFromRotationMatrix(ie),
            this.quaternion.premultiply(ne.invert()))
        },
        add: function(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t),
            this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t),
            t.parent = this,
            this.children.push(t),
            t.dispatchEvent(he)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t),
            this)
        },
        remove: function(t) {
            if (arguments.length > 1) {
                for (let t = 0; t < arguments.length; t++)
                    this.remove(arguments[t]);
                return this
            }
            const e = this.children.indexOf(t);
            return -1 !== e && (t.parent = null,
            this.children.splice(e, 1),
            t.dispatchEvent(de)),
            this
        },
        clear: function() {
            for (let t = 0; t < this.children.length; t++) {
                const e = this.children[t];
                e.parent = null,
                e.dispatchEvent(de)
            }
            return this.children.length = 0,
            this
        },
        attach: function(t) {
            return this.updateWorldMatrix(!0, !1),
            ie.copy(this.matrixWorld).invert(),
            null !== t.parent && (t.parent.updateWorldMatrix(!0, !1),
            ie.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(ie),
            t.updateWorldMatrix(!1, !1),
            this.add(t),
            this
        },
        getObjectById: function(t) {
            return this.getObjectByProperty("id", t)
        },
        getObjectByName: function(t) {
            return this.getObjectByProperty("name", t)
        },
        getObjectByProperty: function(t, e) {
            if (this[t] === e)
                return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
                const i = this.children[n].getObjectByProperty(t, e);
                if (void 0 !== i)
                    return i
            }
        },
        getWorldPosition: function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
            t = new ft),
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
            t = new pt),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(oe, t, se),
            t
        },
        getWorldScale: function(t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
            t = new ft),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(oe, ae, t),
            t
        },
        getWorldDirection: function(t) {
            void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
            t = new ft),
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        },
        raycast: function() {},
        traverse: function(t) {
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++)
                e[n].traverse(t)
        },
        traverseVisible: function(t) {
            if (!1 === this.visible)
                return;
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++)
                e[n].traverseVisible(t)
        },
        traverseAncestors: function(t) {
            const e = this.parent;
            null !== e && (t(e),
            e.traverseAncestors(t))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            t = !0);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++)
                e[n].updateMatrixWorld(t)
        },
        updateWorldMatrix: function(t, e) {
            const n = this.parent;
            if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === e) {
                const t = this.children;
                for (let e = 0, n = t.length; e < n; e++)
                    t[e].updateWorldMatrix(!1, !0)
            }
        },
        toJSON: function(t) {
            const e = void 0 === t || "string" == typeof t
              , n = {};
            e && (t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {}
            },
            n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const i = {};
            function r(e, n) {
                return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                n.uuid
            }
            if (i.uuid = this.uuid,
            i.type = this.type,
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
            i.layers = this.layers.mask,
            i.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh && (i.type = "InstancedMesh",
            i.count = this.count,
            i.instanceMatrix = this.instanceMatrix.toJSON()),
            this.isMesh || this.isLine || this.isPoints) {
                i.geometry = r(t.geometries, this.geometry);
                const e = this.geometry.parameters;
                if (void 0 !== e && void 0 !== e.shapes) {
                    const n = e.shapes;
                    if (Array.isArray(n))
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            r(t.shapes, i)
                        }
                    else
                        r(t.shapes, n)
                }
            }
            if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
            i.bindMatrix = this.bindMatrix.toArray(),
            void 0 !== this.skeleton && (r(t.skeletons, this.skeleton),
            i.skeleton = this.skeleton.uuid)),
            void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    const e = [];
                    for (let n = 0, i = this.material.length; n < i; n++)
                        e.push(r(t.materials, this.material[n]));
                    i.material = e
                } else
                    i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
                i.children = [];
                for (let e = 0; e < this.children.length; e++)
                    i.children.push(this.children[e].toJSON(t).object)
            }
            if (this.animations.length > 0) {
                i.animations = [];
                for (let e = 0; e < this.animations.length; e++) {
                    const n = this.animations[e];
                    i.animations.push(r(t.animations, n))
                }
            }
            if (e) {
                const e = o(t.geometries)
                  , i = o(t.materials)
                  , r = o(t.textures)
                  , s = o(t.images)
                  , a = o(t.shapes)
                  , l = o(t.skeletons)
                  , c = o(t.animations);
                e.length > 0 && (n.geometries = e),
                i.length > 0 && (n.materials = i),
                r.length > 0 && (n.textures = r),
                s.length > 0 && (n.images = s),
                a.length > 0 && (n.shapes = a),
                l.length > 0 && (n.skeletons = l),
                c.length > 0 && (n.animations = c)
            }
            return n.object = i,
            n;
            function o(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    delete i.metadata,
                    e.push(i)
                }
                return e
            }
        },
        clone: function(t) {
            return (new this.constructor).copy(this, t)
        },
        copy: function(t, e=!0) {
            if (this.name = t.name,
            this.up.copy(t.up),
            this.position.copy(t.position),
            this.rotation.order = t.rotation.order,
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate,
            this.layers.mask = t.layers.mask,
            this.visible = t.visible,
            this.castShadow = t.castShadow,
            this.receiveShadow = t.receiveShadow,
            this.frustumCulled = t.frustumCulled,
            this.renderOrder = t.renderOrder,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            !0 === e)
                for (let e = 0; e < t.children.length; e++) {
                    const n = t.children[e];
                    this.add(n.clone())
                }
            return this
        }
    });
    const fe = new ft
      , me = new ft
      , ge = new rt;
    class ve {
        constructor(t, e) {
            Object.defineProperty(this, "isPlane", {
                value: !0
            }),
            this.normal = void 0 !== t ? t : new ft(1,0,0),
            this.constant = void 0 !== e ? e : 0
        }
        set(t, e) {
            return this.normal.copy(t),
            this.constant = e,
            this
        }
        setComponents(t, e, n, i) {
            return this.normal.set(t, e, n),
            this.constant = i,
            this
        }
        setFromNormalAndCoplanarPoint(t, e) {
            return this.normal.copy(t),
            this.constant = -e.dot(this.normal),
            this
        }
        setFromCoplanarPoints(t, e, n) {
            const i = fe.subVectors(n, e).cross(me.subVectors(t, e)).normalize();
            return this.setFromNormalAndCoplanarPoint(i, t),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.normal.copy(t.normal),
            this.constant = t.constant,
            this
        }
        normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t),
            this.constant *= t,
            this
        }
        negate() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        }
        distanceToPoint(t) {
            return this.normal.dot(t) + this.constant
        }
        distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius
        }
        projectPoint(t, e) {
            return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"),
            e = new ft),
            e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        }
        intersectLine(t, e) {
            void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"),
            e = new ft);
            const n = t.delta(fe)
              , i = this.normal.dot(n);
            if (0 === i)
                return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
            const r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
        }
        intersectsLine(t) {
            const e = this.distanceToPoint(t.start)
              , n = this.distanceToPoint(t.end);
            return e < 0 && n > 0 || n < 0 && e > 0
        }
        intersectsBox(t) {
            return t.intersectsPlane(this)
        }
        intersectsSphere(t) {
            return t.intersectsPlane(this)
        }
        coplanarPoint(t) {
            return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
            t = new ft),
            t.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(t, e) {
            const n = e || ge.getNormalMatrix(t)
              , i = this.coplanarPoint(fe).applyMatrix4(t)
              , r = this.normal.applyMatrix3(n).normalize();
            return this.constant = -i.dot(r),
            this
        }
        translate(t) {
            return this.constant -= t.dot(this.normal),
            this
        }
        equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    }
    const ye = new ft
      , _e = new ft
      , xe = new ft
      , be = new ft
      , we = new ft
      , Me = new ft
      , Se = new ft
      , Ee = new ft
      , De = new ft
      , Te = new ft;
    class Ae {
        constructor(t, e, n) {
            this.a = void 0 !== t ? t : new ft,
            this.b = void 0 !== e ? e : new ft,
            this.c = void 0 !== n ? n : new ft
        }
        static getNormal(t, e, n, i) {
            void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"),
            i = new ft),
            i.subVectors(n, e),
            ye.subVectors(t, e),
            i.cross(ye);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
        }
        static getBarycoord(t, e, n, i, r) {
            ye.subVectors(i, e),
            _e.subVectors(n, e),
            xe.subVectors(t, e);
            const o = ye.dot(ye)
              , s = ye.dot(_e)
              , a = ye.dot(xe)
              , l = _e.dot(_e)
              , c = _e.dot(xe)
              , u = o * l - s * s;
            if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
            r = new ft),
            0 === u)
                return r.set(-2, -1, -1);
            const h = 1 / u
              , d = (l * a - s * c) * h
              , p = (o * c - s * a) * h;
            return r.set(1 - d - p, p, d)
        }
        static containsPoint(t, e, n, i) {
            return this.getBarycoord(t, e, n, i, be),
            be.x >= 0 && be.y >= 0 && be.x + be.y <= 1
        }
        static getUV(t, e, n, i, r, o, s, a) {
            return this.getBarycoord(t, e, n, i, be),
            a.set(0, 0),
            a.addScaledVector(r, be.x),
            a.addScaledVector(o, be.y),
            a.addScaledVector(s, be.z),
            a
        }
        static isFrontFacing(t, e, n, i) {
            return ye.subVectors(n, e),
            _e.subVectors(t, e),
            ye.cross(_e).dot(i) < 0
        }
        set(t, e, n) {
            return this.a.copy(t),
            this.b.copy(e),
            this.c.copy(n),
            this
        }
        setFromPointsAndIndices(t, e, n, i) {
            return this.a.copy(t[e]),
            this.b.copy(t[n]),
            this.c.copy(t[i]),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.a.copy(t.a),
            this.b.copy(t.b),
            this.c.copy(t.c),
            this
        }
        getArea() {
            return ye.subVectors(this.c, this.b),
            _e.subVectors(this.a, this.b),
            .5 * ye.cross(_e).length()
        }
        getMidpoint(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
            t = new ft),
            t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(t) {
            return Ae.getNormal(this.a, this.b, this.c, t)
        }
        getPlane(t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            t = new ve),
            t.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(t, e) {
            return Ae.getBarycoord(t, this.a, this.b, this.c, e)
        }
        getUV(t, e, n, i, r) {
            return Ae.getUV(t, this.a, this.b, this.c, e, n, i, r)
        }
        containsPoint(t) {
            return Ae.containsPoint(t, this.a, this.b, this.c)
        }
        isFrontFacing(t) {
            return Ae.isFrontFacing(this.a, this.b, this.c, t)
        }
        intersectsBox(t) {
            return t.intersectsTriangle(this)
        }
        closestPointToPoint(t, e) {
            void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
            e = new ft);
            const n = this.a
              , i = this.b
              , r = this.c;
            let o, s;
            we.subVectors(i, n),
            Me.subVectors(r, n),
            Ee.subVectors(t, n);
            const a = we.dot(Ee)
              , l = Me.dot(Ee);
            if (a <= 0 && l <= 0)
                return e.copy(n);
            De.subVectors(t, i);
            const c = we.dot(De)
              , u = Me.dot(De);
            if (c >= 0 && u <= c)
                return e.copy(i);
            const h = a * u - c * l;
            if (h <= 0 && a >= 0 && c <= 0)
                return o = a / (a - c),
                e.copy(n).addScaledVector(we, o);
            Te.subVectors(t, r);
            const d = we.dot(Te)
              , p = Me.dot(Te);
            if (p >= 0 && d <= p)
                return e.copy(r);
            const f = d * l - a * p;
            if (f <= 0 && l >= 0 && p <= 0)
                return s = l / (l - p),
                e.copy(n).addScaledVector(Me, s);
            const m = c * p - d * u;
            if (m <= 0 && u - c >= 0 && d - p >= 0)
                return Se.subVectors(r, i),
                s = (u - c) / (u - c + (d - p)),
                e.copy(i).addScaledVector(Se, s);
            const g = 1 / (m + f + h);
            return o = f * g,
            s = h * g,
            e.copy(n).addScaledVector(we, o).addScaledVector(Me, s)
        }
        equals(t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }
    const Ce = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }
      , Le = {
        h: 0,
        s: 0,
        l: 0
    }
      , Pe = {
        h: 0,
        s: 0,
        l: 0
    };
    function Re(t, e, n) {
        return n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
    }
    function Oe(t) {
        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
    }
    function Fe(t) {
        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
    }
    class Ne {
        constructor(t, e, n) {
            return Object.defineProperty(this, "isColor", {
                value: !0
            }),
            void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
        }
        set(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
            this
        }
        setScalar(t) {
            return this.r = t,
            this.g = t,
            this.b = t,
            this
        }
        setHex(t) {
            return t = Math.floor(t),
            this.r = (t >> 16 & 255) / 255,
            this.g = (t >> 8 & 255) / 255,
            this.b = (255 & t) / 255,
            this
        }
        setRGB(t, e, n) {
            return this.r = t,
            this.g = e,
            this.b = n,
            this
        }
        setHSL(t, e, n) {
            if (t = nt.euclideanModulo(t, 1),
            e = nt.clamp(e, 0, 1),
            n = nt.clamp(n, 0, 1),
            0 === e)
                this.r = this.g = this.b = n;
            else {
                const i = n <= .5 ? n * (1 + e) : n + e - n * e
                  , r = 2 * n - i;
                this.r = Re(r, i, t + 1 / 3),
                this.g = Re(r, i, t),
                this.b = Re(r, i, t - 1 / 3)
            }
            return this
        }
        setStyle(t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            let n;
            if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                let t;
                const i = n[1]
                  , r = n[2];
                switch (i) {
                case "rgb":
                case "rgba":
                    if (t = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                        return this.r = Math.min(255, parseInt(t[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(t[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(t[3], 10)) / 255,
                        e(t[4]),
                        this;
                    if (t = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))
                        return this.r = Math.min(100, parseInt(t[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(t[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(t[3], 10)) / 100,
                        e(t[4]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (t = /^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                        const n = parseFloat(t[1]) / 360
                          , i = parseInt(t[2], 10) / 100
                          , r = parseInt(t[3], 10) / 100;
                        return e(t[4]),
                        this.setHSL(n, i, r)
                    }
                }
            } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                const t = n[1]
                  , e = t.length;
                if (3 === e)
                    return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255,
                    this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255,
                    this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255,
                    this;
                if (6 === e)
                    return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255,
                    this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255,
                    this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255,
                    this
            }
            return t && t.length > 0 ? this.setColorName(t) : this
        }
        setColorName(t) {
            const e = Ce[t];
            return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t),
            this
        }
        clone() {
            return new this.constructor(this.r,this.g,this.b)
        }
        copy(t) {
            return this.r = t.r,
            this.g = t.g,
            this.b = t.b,
            this
        }
        copyGammaToLinear(t, e=2) {
            return this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        }
        copyLinearToGamma(t, e=2) {
            const n = e > 0 ? 1 / e : 1;
            return this.r = Math.pow(t.r, n),
            this.g = Math.pow(t.g, n),
            this.b = Math.pow(t.b, n),
            this
        }
        convertGammaToLinear(t) {
            return this.copyGammaToLinear(this, t),
            this
        }
        convertLinearToGamma(t) {
            return this.copyLinearToGamma(this, t),
            this
        }
        copySRGBToLinear(t) {
            return this.r = Oe(t.r),
            this.g = Oe(t.g),
            this.b = Oe(t.b),
            this
        }
        copyLinearToSRGB(t) {
            return this.r = Fe(t.r),
            this.g = Fe(t.g),
            this.b = Fe(t.b),
            this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this),
            this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this),
            this
        }
        getHex() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        }
        getHexString() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }
        getHSL(t) {
            void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"),
            t = {
                h: 0,
                s: 0,
                l: 0
            });
            const e = this.r
              , n = this.g
              , i = this.b
              , r = Math.max(e, n, i)
              , o = Math.min(e, n, i);
            let s, a;
            const l = (o + r) / 2;
            if (o === r)
                s = 0,
                a = 0;
            else {
                const t = r - o;
                switch (a = l <= .5 ? t / (r + o) : t / (2 - r - o),
                r) {
                case e:
                    s = (n - i) / t + (n < i ? 6 : 0);
                    break;
                case n:
                    s = (i - e) / t + 2;
                    break;
                case i:
                    s = (e - n) / t + 4
                }
                s /= 6
            }
            return t.h = s,
            t.s = a,
            t.l = l,
            t
        }
        getStyle() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }
        offsetHSL(t, e, n) {
            return this.getHSL(Le),
            Le.h += t,
            Le.s += e,
            Le.l += n,
            this.setHSL(Le.h, Le.s, Le.l),
            this
        }
        add(t) {
            return this.r += t.r,
            this.g += t.g,
            this.b += t.b,
            this
        }
        addColors(t, e) {
            return this.r = t.r + e.r,
            this.g = t.g + e.g,
            this.b = t.b + e.b,
            this
        }
        addScalar(t) {
            return this.r += t,
            this.g += t,
            this.b += t,
            this
        }
        sub(t) {
            return this.r = Math.max(0, this.r - t.r),
            this.g = Math.max(0, this.g - t.g),
            this.b = Math.max(0, this.b - t.b),
            this
        }
        multiply(t) {
            return this.r *= t.r,
            this.g *= t.g,
            this.b *= t.b,
            this
        }
        multiplyScalar(t) {
            return this.r *= t,
            this.g *= t,
            this.b *= t,
            this
        }
        lerp(t, e) {
            return this.r += (t.r - this.r) * e,
            this.g += (t.g - this.g) * e,
            this.b += (t.b - this.b) * e,
            this
        }
        lerpHSL(t, e) {
            this.getHSL(Le),
            t.getHSL(Pe);
            const n = nt.lerp(Le.h, Pe.h, e)
              , i = nt.lerp(Le.s, Pe.s, e)
              , r = nt.lerp(Le.l, Pe.l, e);
            return this.setHSL(n, i, r),
            this
        }
        equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        }
        fromArray(t, e=0) {
            return this.r = t[e],
            this.g = t[e + 1],
            this.b = t[e + 2],
            this
        }
        toArray(t=[], e=0) {
            return t[e] = this.r,
            t[e + 1] = this.g,
            t[e + 2] = this.b,
            t
        }
        fromBufferAttribute(t, e) {
            return this.r = t.getX(e),
            this.g = t.getY(e),
            this.b = t.getZ(e),
            !0 === t.normalized && (this.r /= 255,
            this.g /= 255,
            this.b /= 255),
            this
        }
        toJSON() {
            return this.getHex()
        }
    }
    Ne.NAMES = Ce,
    Ne.prototype.r = 1,
    Ne.prototype.g = 1,
    Ne.prototype.b = 1;
    class Ie {
        constructor(t, e, n, i, r, o=0) {
            this.a = t,
            this.b = e,
            this.c = n,
            this.normal = i && i.isVector3 ? i : new ft,
            this.vertexNormals = Array.isArray(i) ? i : [],
            this.color = r && r.isColor ? r : new Ne,
            this.vertexColors = Array.isArray(r) ? r : [],
            this.materialIndex = o
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            this.a = t.a,
            this.b = t.b,
            this.c = t.c,
            this.normal.copy(t.normal),
            this.color.copy(t.color),
            this.materialIndex = t.materialIndex;
            for (let e = 0, n = t.vertexNormals.length; e < n; e++)
                this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (let e = 0, n = t.vertexColors.length; e < n; e++)
                this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    }
    let Be = 0;
    function ke() {
        Object.defineProperty(this, "id", {
            value: Be++
        }),
        this.uuid = nt.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.blending = 1,
        this.side = 0,
        this.flatShading = !1,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = 204,
        this.blendDst = 205,
        this.blendEquation = m,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = 3,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = 519,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = Z,
        this.stencilZFail = Z,
        this.stencilZPass = Z,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0
    }
    function ze(t) {
        ke.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.setValues(t)
    }
    ke.prototype = Object.assign(Object.create($.prototype), {
        constructor: ke,
        isMaterial: !0,
        onBeforeCompile: function() {},
        customProgramCacheKey: function() {
            return this.onBeforeCompile.toString()
        },
        setValues: function(t) {
            if (void 0 !== t)
                for (const e in t) {
                    const n = t[e];
                    if (void 0 === n) {
                        console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                        continue
                    }
                    if ("shading" === e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                        this.flatShading = 1 === n;
                        continue
                    }
                    const i = this[e];
                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                }
        },
        toJSON: function(t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function i(t) {
                const e = [];
                for (const n in t) {
                    const i = t[n];
                    delete i.metadata,
                    e.push(i)
                }
                return e
            }
            if (n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid,
            n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid),
            this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid,
            n.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid,
            n.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid,
            n.normalMapType = this.normalMapType,
            n.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid,
            n.displacementScale = this.displacementScale,
            n.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid,
            n.reflectivity = this.reflectivity,
            n.refractionRatio = this.refractionRatio,
            void 0 !== this.combine && (n.combine = this.combine),
            void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)),
            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.size && (n.size = this.size),
            void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            0 !== this.side && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            n.depthFunc = this.depthFunc,
            n.depthTest = this.depthTest,
            n.depthWrite = this.depthWrite,
            n.stencilWrite = this.stencilWrite,
            n.stencilWriteMask = this.stencilWriteMask,
            n.stencilFunc = this.stencilFunc,
            n.stencilRef = this.stencilRef,
            n.stencilFuncMask = this.stencilFuncMask,
            n.stencilFail = this.stencilFail,
            n.stencilZFail = this.stencilZFail,
            n.stencilZPass = this.stencilZPass,
            this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.morphNormals && (n.morphNormals = !0),
            !0 === this.skinning && (n.skinning = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            e) {
                const e = i(t.textures)
                  , r = i(t.images);
                e.length > 0 && (n.textures = e),
                r.length > 0 && (n.images = r)
            }
            return n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name,
            this.fog = t.fog,
            this.blending = t.blending,
            this.side = t.side,
            this.flatShading = t.flatShading,
            this.vertexColors = t.vertexColors,
            this.opacity = t.opacity,
            this.transparent = t.transparent,
            this.blendSrc = t.blendSrc,
            this.blendDst = t.blendDst,
            this.blendEquation = t.blendEquation,
            this.blendSrcAlpha = t.blendSrcAlpha,
            this.blendDstAlpha = t.blendDstAlpha,
            this.blendEquationAlpha = t.blendEquationAlpha,
            this.depthFunc = t.depthFunc,
            this.depthTest = t.depthTest,
            this.depthWrite = t.depthWrite,
            this.stencilWriteMask = t.stencilWriteMask,
            this.stencilFunc = t.stencilFunc,
            this.stencilRef = t.stencilRef,
            this.stencilFuncMask = t.stencilFuncMask,
            this.stencilFail = t.stencilFail,
            this.stencilZFail = t.stencilZFail,
            this.stencilZPass = t.stencilZPass,
            this.stencilWrite = t.stencilWrite;
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
                const t = e.length;
                n = new Array(t);
                for (let i = 0; i !== t; ++i)
                    n[i] = e[i].clone()
            }
            return this.clippingPlanes = n,
            this.clipIntersection = t.clipIntersection,
            this.clipShadows = t.clipShadows,
            this.shadowSide = t.shadowSide,
            this.colorWrite = t.colorWrite,
            this.precision = t.precision,
            this.polygonOffset = t.polygonOffset,
            this.polygonOffsetFactor = t.polygonOffsetFactor,
            this.polygonOffsetUnits = t.polygonOffsetUnits,
            this.dithering = t.dithering,
            this.alphaTest = t.alphaTest,
            this.premultipliedAlpha = t.premultipliedAlpha,
            this.visible = t.visible,
            this.toneMapped = t.toneMapped,
            this.userData = JSON.parse(JSON.stringify(t.userData)),
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(ke.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    ze.prototype = Object.create(ke.prototype),
    ze.prototype.constructor = ze,
    ze.prototype.isMeshBasicMaterial = !0,
    ze.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this
    }
    ;
    const Ue = new ft
      , He = new it;
    function Ge(t, e, n) {
        if (Array.isArray(t))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = t,
        this.itemSize = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.normalized = !0 === n,
        this.usage = J,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function Ve(t, e, n) {
        Ge.call(this, new Int8Array(t), e, n)
    }
    function je(t, e, n) {
        Ge.call(this, new Uint8Array(t), e, n)
    }
    function We(t, e, n) {
        Ge.call(this, new Uint8ClampedArray(t), e, n)
    }
    function qe(t, e, n) {
        Ge.call(this, new Int16Array(t), e, n)
    }
    function Xe(t, e, n) {
        Ge.call(this, new Uint16Array(t), e, n)
    }
    function Ye(t, e, n) {
        Ge.call(this, new Int32Array(t), e, n)
    }
    function Ze(t, e, n) {
        Ge.call(this, new Uint32Array(t), e, n)
    }
    function Je(t, e, n) {
        Ge.call(this, new Uint16Array(t), e, n)
    }
    function Qe(t, e, n) {
        Ge.call(this, new Float32Array(t), e, n)
    }
    function Ke(t, e, n) {
        Ge.call(this, new Float64Array(t), e, n)
    }
    Object.defineProperty(Ge.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(Ge.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setUsage: function(t) {
            return this.usage = t,
            this
        },
        copy: function(t) {
            return this.name = t.name,
            this.array = new t.array.constructor(t.array),
            this.itemSize = t.itemSize,
            this.count = t.count,
            this.normalized = t.normalized,
            this.usage = t.usage,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.itemSize,
            n *= e.itemSize;
            for (let i = 0, r = this.itemSize; i < r; i++)
                this.array[t + i] = e.array[n + i];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t),
            this
        },
        copyColorsArray: function(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i),
                r = new Ne),
                e[n++] = r.r,
                e[n++] = r.g,
                e[n++] = r.b
            }
            return this
        },
        copyVector2sArray: function(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i),
                r = new it),
                e[n++] = r.x,
                e[n++] = r.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i),
                r = new ft),
                e[n++] = r.x,
                e[n++] = r.y,
                e[n++] = r.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
                let r = t[i];
                void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i),
                r = new ut),
                e[n++] = r.x,
                e[n++] = r.y,
                e[n++] = r.z,
                e[n++] = r.w
            }
            return this
        },
        applyMatrix3: function(t) {
            if (2 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++)
                    He.fromBufferAttribute(this, e),
                    He.applyMatrix3(t),
                    this.setXY(e, He.x, He.y);
            else if (3 === this.itemSize)
                for (let e = 0, n = this.count; e < n; e++)
                    Ue.fromBufferAttribute(this, e),
                    Ue.applyMatrix3(t),
                    this.setXYZ(e, Ue.x, Ue.y, Ue.z);
            return this
        },
        applyMatrix4: function(t) {
            for (let e = 0, n = this.count; e < n; e++)
                Ue.x = this.getX(e),
                Ue.y = this.getY(e),
                Ue.z = this.getZ(e),
                Ue.applyMatrix4(t),
                this.setXYZ(e, Ue.x, Ue.y, Ue.z);
            return this
        },
        applyNormalMatrix: function(t) {
            for (let e = 0, n = this.count; e < n; e++)
                Ue.x = this.getX(e),
                Ue.y = this.getY(e),
                Ue.z = this.getZ(e),
                Ue.applyNormalMatrix(t),
                this.setXYZ(e, Ue.x, Ue.y, Ue.z);
            return this
        },
        transformDirection: function(t) {
            for (let e = 0, n = this.count; e < n; e++)
                Ue.x = this.getX(e),
                Ue.y = this.getY(e),
                Ue.z = this.getZ(e),
                Ue.transformDirection(t),
                this.setXYZ(e, Ue.x, Ue.y, Ue.z);
            return this
        },
        set: function(t, e=0) {
            return this.array.set(t, e),
            this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e,
            this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e,
            this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e,
            this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e,
            this
        },
        setXY: function(t, e, n) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, i) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this
        },
        setXYZW: function(t, e, n, i, r) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this.array[t + 3] = r,
            this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        },
        toJSON: function() {
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            }
        }
    }),
    Ve.prototype = Object.create(Ge.prototype),
    Ve.prototype.constructor = Ve,
    je.prototype = Object.create(Ge.prototype),
    je.prototype.constructor = je,
    We.prototype = Object.create(Ge.prototype),
    We.prototype.constructor = We,
    qe.prototype = Object.create(Ge.prototype),
    qe.prototype.constructor = qe,
    Xe.prototype = Object.create(Ge.prototype),
    Xe.prototype.constructor = Xe,
    Ye.prototype = Object.create(Ge.prototype),
    Ye.prototype.constructor = Ye,
    Ze.prototype = Object.create(Ge.prototype),
    Ze.prototype.constructor = Ze,
    Je.prototype = Object.create(Ge.prototype),
    Je.prototype.constructor = Je,
    Je.prototype.isFloat16BufferAttribute = !0,
    Qe.prototype = Object.create(Ge.prototype),
    Qe.prototype.constructor = Qe,
    Ke.prototype = Object.create(Ge.prototype),
    Ke.prototype.constructor = Ke;
    class $e {
        constructor() {
            this.vertices = [],
            this.normals = [],
            this.colors = [],
            this.uvs = [],
            this.uvs2 = [],
            this.groups = [],
            this.morphTargets = {},
            this.skinWeights = [],
            this.skinIndices = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.verticesNeedUpdate = !1,
            this.normalsNeedUpdate = !1,
            this.colorsNeedUpdate = !1,
            this.uvsNeedUpdate = !1,
            this.groupsNeedUpdate = !1
        }
        computeGroups(t) {
            const e = [];
            let n, i, r = void 0;
            const o = t.faces;
            for (i = 0; i < o.length; i++) {
                const t = o[i];
                t.materialIndex !== r && (r = t.materialIndex,
                void 0 !== n && (n.count = 3 * i - n.start,
                e.push(n)),
                n = {
                    start: 3 * i,
                    materialIndex: r
                })
            }
            void 0 !== n && (n.count = 3 * i - n.start,
            e.push(n)),
            this.groups = e
        }
        fromGeometry(t) {
            const e = t.faces
              , n = t.vertices
              , i = t.faceVertexUvs
              , r = i[0] && i[0].length > 0
              , o = i[1] && i[1].length > 0
              , s = t.morphTargets
              , a = s.length;
            let l;
            if (a > 0) {
                l = [];
                for (let t = 0; t < a; t++)
                    l[t] = {
                        name: s[t].name,
                        data: []
                    };
                this.morphTargets.position = l
            }
            const c = t.morphNormals
              , u = c.length;
            let h;
            if (u > 0) {
                h = [];
                for (let t = 0; t < u; t++)
                    h[t] = {
                        name: c[t].name,
                        data: []
                    };
                this.morphTargets.normal = h
            }
            const d = t.skinIndices
              , p = t.skinWeights
              , f = d.length === n.length
              , m = p.length === n.length;
            n.length > 0 && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (let t = 0; t < e.length; t++) {
                const g = e[t];
                this.vertices.push(n[g.a], n[g.b], n[g.c]);
                const v = g.vertexNormals;
                if (3 === v.length)
                    this.normals.push(v[0], v[1], v[2]);
                else {
                    const t = g.normal;
                    this.normals.push(t, t, t)
                }
                const y = g.vertexColors;
                if (3 === y.length)
                    this.colors.push(y[0], y[1], y[2]);
                else {
                    const t = g.color;
                    this.colors.push(t, t, t)
                }
                if (!0 === r) {
                    const e = i[0][t];
                    void 0 !== e ? this.uvs.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", t),
                    this.uvs.push(new it, new it, new it))
                }
                if (!0 === o) {
                    const e = i[1][t];
                    void 0 !== e ? this.uvs2.push(e[0], e[1], e[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", t),
                    this.uvs2.push(new it, new it, new it))
                }
                for (let t = 0; t < a; t++) {
                    const e = s[t].vertices;
                    l[t].data.push(e[g.a], e[g.b], e[g.c])
                }
                for (let e = 0; e < u; e++) {
                    const n = c[e].vertexNormals[t];
                    h[e].data.push(n.a, n.b, n.c)
                }
                f && this.skinIndices.push(d[g.a], d[g.b], d[g.c]),
                m && this.skinWeights.push(p[g.a], p[g.b], p[g.c])
            }
            return this.computeGroups(t),
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            this
        }
    }
    function tn(t) {
        if (0 === t.length)
            return -1 / 0;
        let e = t[0];
        for (let n = 1, i = t.length; n < i; ++n)
            t[n] > e && (e = t[n]);
        return e
    }
    const en = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    function nn(t, e) {
        return new en[t](e)
    }
    let rn = 1;
    const on = new Gt
      , sn = new pe
      , an = new ft
      , ln = new vt
      , cn = new vt
      , un = new ft;
    function hn() {
        Object.defineProperty(this, "id", {
            value: rn += 2
        }),
        this.uuid = nt.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    hn.prototype = Object.assign(Object.create($.prototype), {
        constructor: hn,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(t) {
            return Array.isArray(t) ? this.index = new (tn(t) > 65535 ? Ze : Xe)(t,1) : this.index = t,
            this
        },
        getAttribute: function(t) {
            return this.attributes[t]
        },
        setAttribute: function(t, e) {
            return this.attributes[t] = e,
            this
        },
        deleteAttribute: function(t) {
            return delete this.attributes[t],
            this
        },
        hasAttribute: function(t) {
            return void 0 !== this.attributes[t]
        },
        addGroup: function(t, e, n=0) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: n
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(t, e) {
            this.drawRange.start = t,
            this.drawRange.count = e
        },
        applyMatrix4: function(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t),
            e.needsUpdate = !0);
            const n = this.attributes.normal;
            if (void 0 !== n) {
                const e = (new rt).getNormalMatrix(t);
                n.applyNormalMatrix(e),
                n.needsUpdate = !0
            }
            const i = this.attributes.tangent;
            return void 0 !== i && (i.transformDirection(t),
            i.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function(t) {
            return on.makeRotationX(t),
            this.applyMatrix4(on),
            this
        },
        rotateY: function(t) {
            return on.makeRotationY(t),
            this.applyMatrix4(on),
            this
        },
        rotateZ: function(t) {
            return on.makeRotationZ(t),
            this.applyMatrix4(on),
            this
        },
        translate: function(t, e, n) {
            return on.makeTranslation(t, e, n),
            this.applyMatrix4(on),
            this
        },
        scale: function(t, e, n) {
            return on.makeScale(t, e, n),
            this.applyMatrix4(on),
            this
        },
        lookAt: function(t) {
            return sn.lookAt(t),
            sn.updateMatrix(),
            this.applyMatrix4(sn.matrix),
            this
        },
        center: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(an).negate(),
            this.translate(an.x, an.y, an.z),
            this
        },
        setFromObject: function(t) {
            const e = t.geometry;
            if (t.isPoints || t.isLine) {
                const t = new Qe(3 * e.vertices.length,3)
                  , n = new Qe(3 * e.colors.length,3);
                if (this.setAttribute("position", t.copyVector3sArray(e.vertices)),
                this.setAttribute("color", n.copyColorsArray(e.colors)),
                e.lineDistances && e.lineDistances.length === e.vertices.length) {
                    const t = new Qe(e.lineDistances.length,1);
                    this.setAttribute("lineDistance", t.copyArray(e.lineDistances))
                }
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else
                t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        },
        setFromPoints: function(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                e.push(i.x, i.y, i.z || 0)
            }
            return this.setAttribute("position", new Qe(e,3)),
            this
        },
        updateFromObject: function(t) {
            let e = t.geometry;
            if (t.isMesh) {
                let t = e.__directGeometry;
                if (!0 === e.elementsNeedUpdate && (t = void 0,
                e.elementsNeedUpdate = !1),
                void 0 === t)
                    return this.fromGeometry(e);
                t.verticesNeedUpdate = e.verticesNeedUpdate,
                t.normalsNeedUpdate = e.normalsNeedUpdate,
                t.colorsNeedUpdate = e.colorsNeedUpdate,
                t.uvsNeedUpdate = e.uvsNeedUpdate,
                t.groupsNeedUpdate = e.groupsNeedUpdate,
                e.verticesNeedUpdate = !1,
                e.normalsNeedUpdate = !1,
                e.colorsNeedUpdate = !1,
                e.uvsNeedUpdate = !1,
                e.groupsNeedUpdate = !1,
                e = t
            }
            if (!0 === e.verticesNeedUpdate) {
                const t = this.attributes.position;
                void 0 !== t && (t.copyVector3sArray(e.vertices),
                t.needsUpdate = !0),
                e.verticesNeedUpdate = !1
            }
            if (!0 === e.normalsNeedUpdate) {
                const t = this.attributes.normal;
                void 0 !== t && (t.copyVector3sArray(e.normals),
                t.needsUpdate = !0),
                e.normalsNeedUpdate = !1
            }
            if (!0 === e.colorsNeedUpdate) {
                const t = this.attributes.color;
                void 0 !== t && (t.copyColorsArray(e.colors),
                t.needsUpdate = !0),
                e.colorsNeedUpdate = !1
            }
            if (e.uvsNeedUpdate) {
                const t = this.attributes.uv;
                void 0 !== t && (t.copyVector2sArray(e.uvs),
                t.needsUpdate = !0),
                e.uvsNeedUpdate = !1
            }
            if (e.lineDistancesNeedUpdate) {
                const t = this.attributes.lineDistance;
                void 0 !== t && (t.copyArray(e.lineDistances),
                t.needsUpdate = !0),
                e.lineDistancesNeedUpdate = !1
            }
            return e.groupsNeedUpdate && (e.computeGroups(t.geometry),
            this.groups = e.groups,
            e.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(t) {
            return t.__directGeometry = (new $e).fromGeometry(t),
            this.fromDirectGeometry(t.__directGeometry)
        },
        fromDirectGeometry: function(t) {
            const e = new Float32Array(3 * t.vertices.length);
            if (this.setAttribute("position", new Ge(e,3).copyVector3sArray(t.vertices)),
            t.normals.length > 0) {
                const e = new Float32Array(3 * t.normals.length);
                this.setAttribute("normal", new Ge(e,3).copyVector3sArray(t.normals))
            }
            if (t.colors.length > 0) {
                const e = new Float32Array(3 * t.colors.length);
                this.setAttribute("color", new Ge(e,3).copyColorsArray(t.colors))
            }
            if (t.uvs.length > 0) {
                const e = new Float32Array(2 * t.uvs.length);
                this.setAttribute("uv", new Ge(e,2).copyVector2sArray(t.uvs))
            }
            if (t.uvs2.length > 0) {
                const e = new Float32Array(2 * t.uvs2.length);
                this.setAttribute("uv2", new Ge(e,2).copyVector2sArray(t.uvs2))
            }
            this.groups = t.groups;
            for (const e in t.morphTargets) {
                const n = []
                  , i = t.morphTargets[e];
                for (let t = 0, e = i.length; t < e; t++) {
                    const e = i[t]
                      , r = new Qe(3 * e.data.length,3);
                    r.name = e.name,
                    n.push(r.copyVector3sArray(e.data))
                }
                this.morphAttributes[e] = n
            }
            if (t.skinIndices.length > 0) {
                const e = new Qe(4 * t.skinIndices.length,4);
                this.setAttribute("skinIndex", e.copyVector4sArray(t.skinIndices))
            }
            if (t.skinWeights.length > 0) {
                const e = new Qe(4 * t.skinWeights.length,4);
                this.setAttribute("skinWeight", e.copyVector4sArray(t.skinWeights))
            }
            return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new vt);
            const t = this.attributes.position
              , e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingBox.set(new ft(-1 / 0,-1 / 0,-1 / 0), new ft(1 / 0,1 / 0,1 / 0));
            if (void 0 !== t) {
                if (this.boundingBox.setFromBufferAttribute(t),
                e)
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        ln.setFromBufferAttribute(n),
                        this.morphTargetsRelative ? (un.addVectors(this.boundingBox.min, ln.min),
                        this.boundingBox.expandByPoint(un),
                        un.addVectors(this.boundingBox.max, ln.max),
                        this.boundingBox.expandByPoint(un)) : (this.boundingBox.expandByPoint(ln.min),
                        this.boundingBox.expandByPoint(ln.max))
                    }
            } else
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Ot);
            const t = this.attributes.position
              , e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingSphere.set(new ft, 1 / 0);
            if (t) {
                const n = this.boundingSphere.center;
                if (ln.setFromBufferAttribute(t),
                e)
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        cn.setFromBufferAttribute(n),
                        this.morphTargetsRelative ? (un.addVectors(ln.min, cn.min),
                        ln.expandByPoint(un),
                        un.addVectors(ln.max, cn.max),
                        ln.expandByPoint(un)) : (ln.expandByPoint(cn.min),
                        ln.expandByPoint(cn.max))
                    }
                ln.getCenter(n);
                let i = 0;
                for (let e = 0, r = t.count; e < r; e++)
                    un.fromBufferAttribute(t, e),
                    i = Math.max(i, n.distanceToSquared(un));
                if (e)
                    for (let r = 0, o = e.length; r < o; r++) {
                        const o = e[r]
                          , s = this.morphTargetsRelative;
                        for (let e = 0, r = o.count; e < r; e++)
                            un.fromBufferAttribute(o, e),
                            s && (an.fromBufferAttribute(t, e),
                            un.add(an)),
                            i = Math.max(i, n.distanceToSquared(un))
                    }
                this.boundingSphere.radius = Math.sqrt(i),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            const t = this.index
              , e = this.getAttribute("position");
            if (void 0 !== e) {
                let n = this.getAttribute("normal");
                if (void 0 === n)
                    n = new Ge(new Float32Array(3 * e.count),3),
                    this.setAttribute("normal", n);
                else
                    for (let t = 0, e = n.count; t < e; t++)
                        n.setXYZ(t, 0, 0, 0);
                const i = new ft
                  , r = new ft
                  , o = new ft
                  , s = new ft
                  , a = new ft
                  , l = new ft
                  , c = new ft
                  , u = new ft;
                if (t)
                    for (let h = 0, d = t.count; h < d; h += 3) {
                        const d = t.getX(h + 0)
                          , p = t.getX(h + 1)
                          , f = t.getX(h + 2);
                        i.fromBufferAttribute(e, d),
                        r.fromBufferAttribute(e, p),
                        o.fromBufferAttribute(e, f),
                        c.subVectors(o, r),
                        u.subVectors(i, r),
                        c.cross(u),
                        s.fromBufferAttribute(n, d),
                        a.fromBufferAttribute(n, p),
                        l.fromBufferAttribute(n, f),
                        s.add(c),
                        a.add(c),
                        l.add(c),
                        n.setXYZ(d, s.x, s.y, s.z),
                        n.setXYZ(p, a.x, a.y, a.z),
                        n.setXYZ(f, l.x, l.y, l.z)
                    }
                else
                    for (let t = 0, s = e.count; t < s; t += 3)
                        i.fromBufferAttribute(e, t + 0),
                        r.fromBufferAttribute(e, t + 1),
                        o.fromBufferAttribute(e, t + 2),
                        c.subVectors(o, r),
                        u.subVectors(i, r),
                        c.cross(u),
                        n.setXYZ(t + 0, c.x, c.y, c.z),
                        n.setXYZ(t + 1, c.x, c.y, c.z),
                        n.setXYZ(t + 2, c.x, c.y, c.z);
                this.normalizeNormals(),
                n.needsUpdate = !0
            }
        },
        merge: function(t, e) {
            if (!t || !t.isBufferGeometry)
                return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
            void 0 === e && (e = 0,
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            const n = this.attributes;
            for (const i in n) {
                if (void 0 === t.attributes[i])
                    continue;
                const r = n[i].array
                  , o = t.attributes[i]
                  , s = o.array
                  , a = o.itemSize * e
                  , l = Math.min(s.length, r.length - a);
                for (let t = 0, e = a; t < l; t++,
                e++)
                    r[e] = s[t]
            }
            return this
        },
        normalizeNormals: function() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++)
                un.fromBufferAttribute(t, e),
                un.normalize(),
                t.setXYZ(e, un.x, un.y, un.z)
        },
        toNonIndexed: function() {
            function t(t, e) {
                const n = t.array
                  , i = t.itemSize
                  , r = t.normalized
                  , o = new n.constructor(e.length * i);
                let s = 0
                  , a = 0;
                for (let t = 0, r = e.length; t < r; t++) {
                    s = e[t] * i;
                    for (let t = 0; t < i; t++)
                        o[a++] = n[s++]
                }
                return new Ge(o,i,r)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
            const e = new hn
              , n = this.index.array
              , i = this.attributes;
            for (const r in i) {
                const o = t(i[r], n);
                e.setAttribute(r, o)
            }
            const r = this.morphAttributes;
            for (const i in r) {
                const o = []
                  , s = r[i];
                for (let e = 0, i = s.length; e < i; e++) {
                    const i = t(s[e], n);
                    o.push(i)
                }
                e.morphAttributes[i] = o
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const o = this.groups;
            for (let t = 0, n = o.length; t < n; t++) {
                const n = o[t];
                e.addGroup(n.start, n.count, n.materialIndex)
            }
            return e
        },
        toJSON: function() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            "" !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 && (t.userData = this.userData),
            void 0 !== this.parameters) {
                const e = this.parameters;
                for (const n in e)
                    void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            t.data = {
                attributes: {}
            };
            const e = this.index;
            null !== e && (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array)
            });
            const n = this.attributes;
            for (const e in n) {
                const i = n[e]
                  , r = i.toJSON(t.data);
                "" !== i.name && (r.name = i.name),
                t.data.attributes[e] = r
            }
            const i = {};
            let r = !1;
            for (const e in this.morphAttributes) {
                const n = this.morphAttributes[e]
                  , o = [];
                for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e]
                      , r = i.toJSON(t.data);
                    "" !== i.name && (r.name = i.name),
                    o.push(r)
                }
                o.length > 0 && (i[e] = o,
                r = !0)
            }
            r && (t.data.morphAttributes = i,
            t.data.morphTargetsRelative = this.morphTargetsRelative);
            const o = this.groups;
            o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
            const s = this.boundingSphere;
            return null !== s && (t.data.boundingSphere = {
                center: s.center.toArray(),
                radius: s.radius
            }),
            t
        },
        clone: function() {
            return (new hn).copy(this)
        },
        copy: function(t) {
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null;
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const i = t.attributes;
            for (const t in i) {
                const n = i[t];
                this.setAttribute(t, n.clone(e))
            }
            const r = t.morphAttributes;
            for (const t in r) {
                const n = []
                  , i = r[t];
                for (let t = 0, r = i.length; t < r; t++)
                    n.push(i[t].clone(e));
                this.morphAttributes[t] = n
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const o = t.groups;
            for (let t = 0, e = o.length; t < e; t++) {
                const e = o[t];
                this.addGroup(e.start, e.count, e.materialIndex)
            }
            const s = t.boundingBox;
            null !== s && (this.boundingBox = s.clone());
            const a = t.boundingSphere;
            return null !== a && (this.boundingSphere = a.clone()),
            this.drawRange.start = t.drawRange.start,
            this.drawRange.count = t.drawRange.count,
            this.userData = t.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    const dn = new Gt
      , pn = new Ht
      , fn = new Ot
      , mn = new ft
      , gn = new ft
      , vn = new ft
      , yn = new ft
      , _n = new ft
      , xn = new ft
      , bn = new ft
      , wn = new ft
      , Mn = new ft
      , Sn = new it
      , En = new it
      , Dn = new it
      , Tn = new ft
      , An = new ft;
    function Cn(t=new hn, e=new ze) {
        pe.call(this),
        this.type = "Mesh",
        this.geometry = t,
        this.material = e,
        this.updateMorphTargets()
    }
    function Ln(t, e, n, i, r, o, s, a) {
        let l;
        if (l = 1 === e.side ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, 2 !== e.side, a),
        null === l)
            return null;
        An.copy(a),
        An.applyMatrix4(t.matrixWorld);
        const c = n.ray.origin.distanceTo(An);
        return c < n.near || c > n.far ? null : {
            distance: c,
            point: An.clone(),
            object: t
        }
    }
    function Pn(t, e, n, i, r, o, s, a, l, c, u, h) {
        mn.fromBufferAttribute(r, c),
        gn.fromBufferAttribute(r, u),
        vn.fromBufferAttribute(r, h);
        const d = t.morphTargetInfluences;
        if (e.morphTargets && o && d) {
            bn.set(0, 0, 0),
            wn.set(0, 0, 0),
            Mn.set(0, 0, 0);
            for (let t = 0, e = o.length; t < e; t++) {
                const e = d[t]
                  , n = o[t];
                0 !== e && (yn.fromBufferAttribute(n, c),
                _n.fromBufferAttribute(n, u),
                xn.fromBufferAttribute(n, h),
                s ? (bn.addScaledVector(yn, e),
                wn.addScaledVector(_n, e),
                Mn.addScaledVector(xn, e)) : (bn.addScaledVector(yn.sub(mn), e),
                wn.addScaledVector(_n.sub(gn), e),
                Mn.addScaledVector(xn.sub(vn), e)))
            }
            mn.add(bn),
            gn.add(wn),
            vn.add(Mn)
        }
        t.isSkinnedMesh && (t.boneTransform(c, mn),
        t.boneTransform(u, gn),
        t.boneTransform(h, vn));
        const p = Ln(t, e, n, i, mn, gn, vn, Tn);
        if (p) {
            a && (Sn.fromBufferAttribute(a, c),
            En.fromBufferAttribute(a, u),
            Dn.fromBufferAttribute(a, h),
            p.uv = Ae.getUV(Tn, mn, gn, vn, Sn, En, Dn, new it)),
            l && (Sn.fromBufferAttribute(l, c),
            En.fromBufferAttribute(l, u),
            Dn.fromBufferAttribute(l, h),
            p.uv2 = Ae.getUV(Tn, mn, gn, vn, Sn, En, Dn, new it));
            const t = new Ie(c,u,h);
            Ae.getNormal(mn, gn, vn, t.normal),
            p.face = t
        }
        return p
    }
    Cn.prototype = Object.assign(Object.create(pe.prototype), {
        constructor: Cn,
        isMesh: !0,
        copy: function(t) {
            return pe.prototype.copy.call(this, t),
            void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
            this.material = t.material,
            this.geometry = t.geometry,
            this
        },
        updateMorphTargets: function() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes
                  , n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function(t, e) {
            const n = this.geometry
              , i = this.material
              , r = this.matrixWorld;
            if (void 0 === i)
                return;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            fn.copy(n.boundingSphere),
            fn.applyMatrix4(r),
            !1 === t.ray.intersectsSphere(fn))
                return;
            if (dn.copy(r).invert(),
            pn.copy(t.ray).applyMatrix4(dn),
            null !== n.boundingBox && !1 === pn.intersectsBox(n.boundingBox))
                return;
            let o;
            if (n.isBufferGeometry) {
                const r = n.index
                  , s = n.attributes.position
                  , a = n.morphAttributes.position
                  , l = n.morphTargetsRelative
                  , c = n.attributes.uv
                  , u = n.attributes.uv2
                  , h = n.groups
                  , d = n.drawRange;
                if (null !== r)
                    if (Array.isArray(i))
                        for (let n = 0, p = h.length; n < p; n++) {
                            const p = h[n]
                              , f = i[p.materialIndex];
                            for (let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count); n < i; n += 3) {
                                const i = r.getX(n)
                                  , h = r.getX(n + 1)
                                  , d = r.getX(n + 2);
                                o = Pn(this, f, t, pn, s, a, l, c, u, i, h, d),
                                o && (o.faceIndex = Math.floor(n / 3),
                                o.face.materialIndex = p.materialIndex,
                                e.push(o))
                            }
                        }
                    else {
                        for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) {
                            const h = r.getX(n)
                              , d = r.getX(n + 1)
                              , p = r.getX(n + 2);
                            o = Pn(this, i, t, pn, s, a, l, c, u, h, d, p),
                            o && (o.faceIndex = Math.floor(n / 3),
                            e.push(o))
                        }
                    }
                else if (void 0 !== s)
                    if (Array.isArray(i))
                        for (let n = 0, r = h.length; n < r; n++) {
                            const r = h[n]
                              , p = i[r.materialIndex];
                            for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) {
                                o = Pn(this, p, t, pn, s, a, l, c, u, n, n + 1, n + 2),
                                o && (o.faceIndex = Math.floor(n / 3),
                                o.face.materialIndex = r.materialIndex,
                                e.push(o))
                            }
                        }
                    else {
                        for (let n = Math.max(0, d.start), r = Math.min(s.count, d.start + d.count); n < r; n += 3) {
                            o = Pn(this, i, t, pn, s, a, l, c, u, n, n + 1, n + 2),
                            o && (o.faceIndex = Math.floor(n / 3),
                            e.push(o))
                        }
                    }
            } else if (n.isGeometry) {
                const r = Array.isArray(i)
                  , s = n.vertices
                  , a = n.faces;
                let l;
                const c = n.faceVertexUvs[0];
                c.length > 0 && (l = c);
                for (let n = 0, c = a.length; n < c; n++) {
                    const c = a[n]
                      , u = r ? i[c.materialIndex] : i;
                    if (void 0 === u)
                        continue;
                    const h = s[c.a]
                      , d = s[c.b]
                      , p = s[c.c];
                    if (o = Ln(this, u, t, pn, h, d, p, Tn),
                    o) {
                        if (l && l[n]) {
                            const t = l[n];
                            Sn.copy(t[0]),
                            En.copy(t[1]),
                            Dn.copy(t[2]),
                            o.uv = Ae.getUV(Tn, h, d, p, Sn, En, Dn, new it)
                        }
                        o.face = c,
                        o.faceIndex = n,
                        e.push(o)
                    }
                }
            }
        }
    });
    class Rn extends hn {
        constructor(t=1, e=1, n=1, i=1, r=1, o=1) {
            super(),
            this.type = "BoxBufferGeometry",
            this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: o
            };
            const s = this;
            i = Math.floor(i),
            r = Math.floor(r),
            o = Math.floor(o);
            const a = []
              , l = []
              , c = []
              , u = [];
            let h = 0
              , d = 0;
            function p(t, e, n, i, r, o, p, f, m, g, v) {
                const y = o / m
                  , _ = p / g
                  , x = o / 2
                  , b = p / 2
                  , w = f / 2
                  , M = m + 1
                  , S = g + 1;
                let E = 0
                  , D = 0;
                const T = new ft;
                for (let o = 0; o < S; o++) {
                    const s = o * _ - b;
                    for (let a = 0; a < M; a++) {
                        const h = a * y - x;
                        T[t] = h * i,
                        T[e] = s * r,
                        T[n] = w,
                        l.push(T.x, T.y, T.z),
                        T[t] = 0,
                        T[e] = 0,
                        T[n] = f > 0 ? 1 : -1,
                        c.push(T.x, T.y, T.z),
                        u.push(a / m),
                        u.push(1 - o / g),
                        E += 1
                    }
                }
                for (let t = 0; t < g; t++)
                    for (let e = 0; e < m; e++) {
                        const n = h + e + M * t
                          , i = h + e + M * (t + 1)
                          , r = h + (e + 1) + M * (t + 1)
                          , o = h + (e + 1) + M * t;
                        a.push(n, i, o),
                        a.push(i, r, o),
                        D += 6
                    }
                s.addGroup(d, D, v),
                d += D,
                h += E
            }
            p("z", "y", "x", -1, -1, n, e, t, o, r, 0),
            p("z", "y", "x", 1, -1, n, e, -t, o, r, 1),
            p("x", "z", "y", 1, 1, t, n, e, i, o, 2),
            p("x", "z", "y", 1, -1, t, n, -e, i, o, 3),
            p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
            p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
            this.setIndex(a),
            this.setAttribute("position", new Qe(l,3)),
            this.setAttribute("normal", new Qe(c,3)),
            this.setAttribute("uv", new Qe(u,2))
        }
    }
    function On(t) {
        const e = {};
        for (const n in t) {
            e[n] = {};
            for (const i in t[n]) {
                const r = t[n][i];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
            }
        }
        return e
    }
    function Fn(t) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const i = On(t[n]);
            for (const t in i)
                e[t] = i[t]
        }
        return e
    }
    const Nn = {
        clone: On,
        merge: Fn
    };
    function In(t) {
        ke.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(t))
    }
    function Bn() {
        pe.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new Gt,
        this.projectionMatrix = new Gt,
        this.projectionMatrixInverse = new Gt
    }
    function kn(t=50, e=1, n=.1, i=2e3) {
        Bn.call(this),
        this.type = "PerspectiveCamera",
        this.fov = t,
        this.zoom = 1,
        this.near = n,
        this.far = i,
        this.focus = 10,
        this.aspect = e,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    In.prototype = Object.create(ke.prototype),
    In.prototype.constructor = In,
    In.prototype.isShaderMaterial = !0,
    In.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.fragmentShader = t.fragmentShader,
        this.vertexShader = t.vertexShader,
        this.uniforms = On(t.uniforms),
        this.defines = Object.assign({}, t.defines),
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.lights = t.lights,
        this.clipping = t.clipping,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this.extensions = Object.assign({}, t.extensions),
        this.glslVersion = t.glslVersion,
        this
    }
    ,
    In.prototype.toJSON = function(t) {
        const e = ke.prototype.toJSON.call(this, t);
        e.glslVersion = this.glslVersion,
        e.uniforms = {};
        for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture ? e.uniforms[n] = {
                type: "t",
                value: i.toJSON(t).uuid
            } : i && i.isColor ? e.uniforms[n] = {
                type: "c",
                value: i.getHex()
            } : i && i.isVector2 ? e.uniforms[n] = {
                type: "v2",
                value: i.toArray()
            } : i && i.isVector3 ? e.uniforms[n] = {
                type: "v3",
                value: i.toArray()
            } : i && i.isVector4 ? e.uniforms[n] = {
                type: "v4",
                value: i.toArray()
            } : i && i.isMatrix3 ? e.uniforms[n] = {
                type: "m3",
                value: i.toArray()
            } : i && i.isMatrix4 ? e.uniforms[n] = {
                type: "m4",
                value: i.toArray()
            } : e.uniforms[n] = {
                value: i
            }
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
        e.vertexShader = this.vertexShader,
        e.fragmentShader = this.fragmentShader;
        const n = {};
        for (const t in this.extensions)
            !0 === this.extensions[t] && (n[t] = !0);
        return Object.keys(n).length > 0 && (e.extensions = n),
        e
    }
    ,
    Bn.prototype = Object.assign(Object.create(pe.prototype), {
        constructor: Bn,
        isCamera: !0,
        copy: function(t, e) {
            return pe.prototype.copy.call(this, t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(t) {
            void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
            t = new ft),
            this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        },
        updateMatrixWorld: function(t) {
            pe.prototype.updateMatrixWorld.call(this, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        },
        updateWorldMatrix: function(t, e) {
            pe.prototype.updateWorldMatrix.call(this, t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    kn.prototype = Object.assign(Object.create(Bn.prototype), {
        constructor: kn,
        isPerspectiveCamera: !0,
        copy: function(t, e) {
            return Bn.prototype.copy.call(this, t, e),
            this.fov = t.fov,
            this.zoom = t.zoom,
            this.near = t.near,
            this.far = t.far,
            this.focus = t.focus,
            this.aspect = t.aspect,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this.filmGauge = t.filmGauge,
            this.filmOffset = t.filmOffset,
            this
        },
        setFocalLength: function(t) {
            const e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * nt.RAD2DEG * Math.atan(e),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            const t = Math.tan(.5 * nt.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * nt.RAD2DEG * Math.atan(Math.tan(.5 * nt.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, n, i, r, o) {
            this.aspect = t / e,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            const t = this.near;
            let e = t * Math.tan(.5 * nt.DEG2RAD * this.fov) / this.zoom
              , n = 2 * e
              , i = this.aspect * n
              , r = -.5 * i;
            const o = this.view;
            if (null !== this.view && this.view.enabled) {
                const t = o.fullWidth
                  , s = o.fullHeight;
                r += o.offsetX * i / t,
                e -= o.offsetY * n / s,
                i *= o.width / t,
                n *= o.height / s
            }
            const s = this.filmOffset;
            0 !== s && (r += t * s / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        },
        toJSON: function(t) {
            const e = pe.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov,
            e.object.zoom = this.zoom,
            e.object.near = this.near,
            e.object.far = this.far,
            e.object.focus = this.focus,
            e.object.aspect = this.aspect,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e.object.filmGauge = this.filmGauge,
            e.object.filmOffset = this.filmOffset,
            e
        }
    });
    const zn = 90;
    function Un(t, e, n) {
        if (pe.call(this),
        this.type = "CubeCamera",
        !0 !== n.isWebGLCubeRenderTarget)
            return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        this.renderTarget = n;
        const i = new kn(zn,1,t,e);
        i.layers = this.layers,
        i.up.set(0, -1, 0),
        i.lookAt(new ft(1,0,0)),
        this.add(i);
        const r = new kn(zn,1,t,e);
        r.layers = this.layers,
        r.up.set(0, -1, 0),
        r.lookAt(new ft(-1,0,0)),
        this.add(r);
        const o = new kn(zn,1,t,e);
        o.layers = this.layers,
        o.up.set(0, 0, 1),
        o.lookAt(new ft(0,1,0)),
        this.add(o);
        const s = new kn(zn,1,t,e);
        s.layers = this.layers,
        s.up.set(0, 0, -1),
        s.lookAt(new ft(0,-1,0)),
        this.add(s);
        const a = new kn(zn,1,t,e);
        a.layers = this.layers,
        a.up.set(0, -1, 0),
        a.lookAt(new ft(0,0,1)),
        this.add(a);
        const l = new kn(zn,1,t,e);
        l.layers = this.layers,
        l.up.set(0, -1, 0),
        l.lookAt(new ft(0,0,-1)),
        this.add(l),
        this.update = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const c = t.xr.enabled
              , u = t.getRenderTarget();
            t.xr.enabled = !1;
            const h = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            t.setRenderTarget(n, 0),
            t.render(e, i),
            t.setRenderTarget(n, 1),
            t.render(e, r),
            t.setRenderTarget(n, 2),
            t.render(e, o),
            t.setRenderTarget(n, 3),
            t.render(e, s),
            t.setRenderTarget(n, 4),
            t.render(e, a),
            n.texture.generateMipmaps = h,
            t.setRenderTarget(n, 5),
            t.render(e, l),
            t.setRenderTarget(u),
            t.xr.enabled = c
        }
    }
    function Hn(t, e, n, i, r, o, s, a, l, c) {
        t = void 0 !== t ? t : [],
        e = void 0 !== e ? e : g,
        s = void 0 !== s ? s : F,
        lt.call(this, t, e, n, i, r, o, s, a, l, c),
        this.flipY = !1,
        this._needsFlipEnvMap = !0
    }
    function Gn(t, e, n) {
        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
        e = n),
        ht.call(this, t, t, e),
        e = e || {},
        this.texture = new Hn(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),
        this.texture._needsFlipEnvMap = !1
    }
    function Vn(t, e, n, i, r, o, s, a, l, c, u, h) {
        lt.call(this, null, o, s, a, l, c, i, r, u, h),
        this.image = {
            data: t || null,
            width: e || 1,
            height: n || 1
        },
        this.magFilter = void 0 !== l ? l : M,
        this.minFilter = void 0 !== c ? c : M,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.needsUpdate = !0
    }
    Un.prototype = Object.create(pe.prototype),
    Un.prototype.constructor = Un,
    Hn.prototype = Object.create(lt.prototype),
    Hn.prototype.constructor = Hn,
    Hn.prototype.isCubeTexture = !0,
    Object.defineProperty(Hn.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    }),
    Gn.prototype = Object.create(ht.prototype),
    Gn.prototype.constructor = Gn,
    Gn.prototype.isWebGLCubeRenderTarget = !0,
    Gn.prototype.fromEquirectangularTexture = function(t, e) {
        this.texture.type = e.type,
        this.texture.format = N,
        this.texture.encoding = e.encoding,
        this.texture.generateMipmaps = e.generateMipmaps,
        this.texture.minFilter = e.minFilter,
        this.texture.magFilter = e.magFilter;
        const n = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: "\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",
            fragmentShader: "\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t"
        }
          , i = new Rn(5,5,5)
          , r = new In({
            name: "CubemapFromEquirect",
            uniforms: On(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: 1,
            blending: 0
        });
        r.uniforms.tEquirect.value = e;
        const o = new Cn(i,r)
          , s = e.minFilter;
        e.minFilter === T && (e.minFilter = D);
        return new Un(1,10,this).update(t, o),
        e.minFilter = s,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    ,
    Gn.prototype.clear = function(t, e, n, i) {
        const r = t.getRenderTarget();
        for (let r = 0; r < 6; r++)
            t.setRenderTarget(this, r),
            t.clear(e, n, i);
        t.setRenderTarget(r)
    }
    ,
    Vn.prototype = Object.create(lt.prototype),
    Vn.prototype.constructor = Vn,
    Vn.prototype.isDataTexture = !0;
    const jn = new Ot
      , Wn = new ft;
    class qn {
        constructor(t, e, n, i, r, o) {
            this.planes = [void 0 !== t ? t : new ve, void 0 !== e ? e : new ve, void 0 !== n ? n : new ve, void 0 !== i ? i : new ve, void 0 !== r ? r : new ve, void 0 !== o ? o : new ve]
        }
        set(t, e, n, i, r, o) {
            const s = this.planes;
            return s[0].copy(t),
            s[1].copy(e),
            s[2].copy(n),
            s[3].copy(i),
            s[4].copy(r),
            s[5].copy(o),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
                e[n].copy(t.planes[n]);
            return this
        }
        setFromProjectionMatrix(t) {
            const e = this.planes
              , n = t.elements
              , i = n[0]
              , r = n[1]
              , o = n[2]
              , s = n[3]
              , a = n[4]
              , l = n[5]
              , c = n[6]
              , u = n[7]
              , h = n[8]
              , d = n[9]
              , p = n[10]
              , f = n[11]
              , m = n[12]
              , g = n[13]
              , v = n[14]
              , y = n[15];
            return e[0].setComponents(s - i, u - a, f - h, y - m).normalize(),
            e[1].setComponents(s + i, u + a, f + h, y + m).normalize(),
            e[2].setComponents(s + r, u + l, f + d, y + g).normalize(),
            e[3].setComponents(s - r, u - l, f - d, y - g).normalize(),
            e[4].setComponents(s - o, u - c, f - p, y - v).normalize(),
            e[5].setComponents(s + o, u + c, f + p, y + v).normalize(),
            this
        }
        intersectsObject(t) {
            const e = t.geometry;
            return null === e.boundingSphere && e.computeBoundingSphere(),
            jn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(jn)
        }
        intersectsSprite(t) {
            return jn.center.set(0, 0, 0),
            jn.radius = .7071067811865476,
            jn.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(jn)
        }
        intersectsSphere(t) {
            const e = this.planes
              , n = t.center
              , i = -t.radius;
            for (let t = 0; t < 6; t++) {
                if (e[t].distanceToPoint(n) < i)
                    return !1
            }
            return !0
        }
        intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
                const i = e[n];
                if (Wn.x = i.normal.x > 0 ? t.max.x : t.min.x,
                Wn.y = i.normal.y > 0 ? t.max.y : t.min.y,
                Wn.z = i.normal.z > 0 ? t.max.z : t.min.z,
                i.distanceToPoint(Wn) < 0)
                    return !1
            }
            return !0
        }
        containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
                if (e[n].distanceToPoint(t) < 0)
                    return !1;
            return !0
        }
    }
    function Xn() {
        let t = null
          , e = !1
          , n = null
          , i = null;
        function r(e, o) {
            n(e, o),
            i = t.requestAnimationFrame(r)
        }
        return {
            start: function() {
                !0 !== e && null !== n && (i = t.requestAnimationFrame(r),
                e = !0)
            },
            stop: function() {
                t.cancelAnimationFrame(i),
                e = !1
            },
            setAnimationLoop: function(t) {
                n = t
            },
            setContext: function(e) {
                t = e
            }
        }
    }
    function Yn(t, e) {
        const n = e.isWebGL2
          , i = new WeakMap;
        return {
            get: function(t) {
                return t.isInterleavedBufferAttribute && (t = t.data),
                i.get(t)
            },
            remove: function(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                const n = i.get(e);
                n && (t.deleteBuffer(n.buffer),
                i.delete(e))
            },
            update: function(e, r) {
                if (e.isGLBufferAttribute) {
                    const t = i.get(e);
                    return void ((!t || t.version < e.version) && i.set(e, {
                        buffer: e.buffer,
                        type: e.type,
                        bytesPerElement: e.elementSize,
                        version: e.version
                    }))
                }
                e.isInterleavedBufferAttribute && (e = e.data);
                const o = i.get(e);
                void 0 === o ? i.set(e, function(e, i) {
                    const r = e.array
                      , o = e.usage
                      , s = t.createBuffer();
                    t.bindBuffer(i, s),
                    t.bufferData(i, r, o),
                    e.onUploadCallback();
                    let a = 5126;
                    return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : r instanceof Uint8Array && (a = 5121),
                    {
                        buffer: s,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }(e, r)) : o.version < e.version && (!function(e, i, r) {
                    const o = i.array
                      , s = i.updateRange;
                    t.bindBuffer(r, e),
                    -1 === s.count ? t.bufferSubData(r, 0, o) : (n ? t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o, s.offset, s.count) : t.bufferSubData(r, s.offset * o.BYTES_PER_ELEMENT, o.subarray(s.offset, s.offset + s.count)),
                    s.count = -1)
                }(o.buffer, e, r),
                o.version = e.version)
            }
        }
    }
    class Zn extends hn {
        constructor(t=1, e=1, n=1, i=1) {
            super(),
            this.type = "PlaneBufferGeometry",
            this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i
            };
            const r = t / 2
              , o = e / 2
              , s = Math.floor(n)
              , a = Math.floor(i)
              , l = s + 1
              , c = a + 1
              , u = t / s
              , h = e / a
              , d = []
              , p = []
              , f = []
              , m = [];
            for (let t = 0; t < c; t++) {
                const e = t * h - o;
                for (let n = 0; n < l; n++) {
                    const i = n * u - r;
                    p.push(i, -e, 0),
                    f.push(0, 0, 1),
                    m.push(n / s),
                    m.push(1 - t / a)
                }
            }
            for (let t = 0; t < a; t++)
                for (let e = 0; e < s; e++) {
                    const n = e + l * t
                      , i = e + l * (t + 1)
                      , r = e + 1 + l * (t + 1)
                      , o = e + 1 + l * t;
                    d.push(n, i, o),
                    d.push(i, r, o)
                }
            this.setIndex(d),
            this.setAttribute("position", new Qe(p,3)),
            this.setAttribute("normal", new Qe(f,3)),
            this.setAttribute("uv", new Qe(m,2))
        }
    }
    const Jn = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
        transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    }
      , Qn = {
        common: {
            diffuse: {
                value: new Ne(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new rt
            },
            uv2Transform: {
                value: new rt
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new it(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new Ne(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new Ne(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new rt
            }
        },
        sprite: {
            diffuse: {
                value: new Ne(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new it(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new rt
            }
        }
    }
      , Kn = {
        basic: {
            uniforms: Fn([Qn.common, Qn.specularmap, Qn.envmap, Qn.aomap, Qn.lightmap, Qn.fog]),
            vertexShader: Jn.meshbasic_vert,
            fragmentShader: Jn.meshbasic_frag
        },
        lambert: {
            uniforms: Fn([Qn.common, Qn.specularmap, Qn.envmap, Qn.aomap, Qn.lightmap, Qn.emissivemap, Qn.fog, Qn.lights, {
                emissive: {
                    value: new Ne(0)
                }
            }]),
            vertexShader: Jn.meshlambert_vert,
            fragmentShader: Jn.meshlambert_frag
        },
        phong: {
            uniforms: Fn([Qn.common, Qn.specularmap, Qn.envmap, Qn.aomap, Qn.lightmap, Qn.emissivemap, Qn.bumpmap, Qn.normalmap, Qn.displacementmap, Qn.fog, Qn.lights, {
                emissive: {
                    value: new Ne(0)
                },
                specular: {
                    value: new Ne(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Jn.meshphong_vert,
            fragmentShader: Jn.meshphong_frag
        },
        standard: {
            uniforms: Fn([Qn.common, Qn.envmap, Qn.aomap, Qn.lightmap, Qn.emissivemap, Qn.bumpmap, Qn.normalmap, Qn.displacementmap, Qn.roughnessmap, Qn.metalnessmap, Qn.fog, Qn.lights, {
                emissive: {
                    value: new Ne(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Jn.meshphysical_vert,
            fragmentShader: Jn.meshphysical_frag
        },
        toon: {
            uniforms: Fn([Qn.common, Qn.aomap, Qn.lightmap, Qn.emissivemap, Qn.bumpmap, Qn.normalmap, Qn.displacementmap, Qn.gradientmap, Qn.fog, Qn.lights, {
                emissive: {
                    value: new Ne(0)
                }
            }]),
            vertexShader: Jn.meshtoon_vert,
            fragmentShader: Jn.meshtoon_frag
        },
        matcap: {
            uniforms: Fn([Qn.common, Qn.bumpmap, Qn.normalmap, Qn.displacementmap, Qn.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Jn.meshmatcap_vert,
            fragmentShader: Jn.meshmatcap_frag
        },
        points: {
            uniforms: Fn([Qn.points, Qn.fog]),
            vertexShader: Jn.points_vert,
            fragmentShader: Jn.points_frag
        },
        dashed: {
            uniforms: Fn([Qn.common, Qn.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Jn.linedashed_vert,
            fragmentShader: Jn.linedashed_frag
        },
        depth: {
            uniforms: Fn([Qn.common, Qn.displacementmap]),
            vertexShader: Jn.depth_vert,
            fragmentShader: Jn.depth_frag
        },
        normal: {
            uniforms: Fn([Qn.common, Qn.bumpmap, Qn.normalmap, Qn.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Jn.normal_vert,
            fragmentShader: Jn.normal_frag
        },
        sprite: {
            uniforms: Fn([Qn.sprite, Qn.fog]),
            vertexShader: Jn.sprite_vert,
            fragmentShader: Jn.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new rt
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: Jn.background_vert,
            fragmentShader: Jn.background_frag
        },
        cube: {
            uniforms: Fn([Qn.envmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Jn.cube_vert,
            fragmentShader: Jn.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Jn.equirect_vert,
            fragmentShader: Jn.equirect_frag
        },
        distanceRGBA: {
            uniforms: Fn([Qn.common, Qn.displacementmap, {
                referencePosition: {
                    value: new ft
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Jn.distanceRGBA_vert,
            fragmentShader: Jn.distanceRGBA_frag
        },
        shadow: {
            uniforms: Fn([Qn.lights, Qn.fog, {
                color: {
                    value: new Ne(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Jn.shadow_vert,
            fragmentShader: Jn.shadow_frag
        }
    };
    function $n(t, e, n, i, r) {
        const o = new Ne(0);
        let s, a, l = 0, c = null, u = 0, h = null;
        function d(t, e) {
            n.buffers.color.setClear(t.r, t.g, t.b, e, r)
        }
        return {
            getClearColor: function() {
                return o
            },
            setClearColor: function(t, e=1) {
                o.set(t),
                l = e,
                d(o, l)
            },
            getClearAlpha: function() {
                return l
            },
            setClearAlpha: function(t) {
                l = t,
                d(o, l)
            },
            render: function(n, r, p, f) {
                let m = !0 === r.isScene ? r.background : null;
                m && m.isTexture && (m = e.get(m));
                const g = t.xr
                  , v = g.getSession && g.getSession();
                v && "additive" === v.environmentBlendMode && (m = null),
                null === m ? d(o, l) : m && m.isColor && (d(m, 1),
                f = !0),
                (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.mapping === y) ? (void 0 === a && (a = new Cn(new Rn(1,1,1),new In({
                    name: "BackgroundCubeMaterial",
                    uniforms: On(Kn.cube.uniforms),
                    vertexShader: Kn.cube.vertexShader,
                    fragmentShader: Kn.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                a.geometry.deleteAttribute("normal"),
                a.geometry.deleteAttribute("uv"),
                a.onBeforeRender = function(t, e, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld)
                }
                ,
                Object.defineProperty(a.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }),
                i.update(a)),
                m.isWebGLCubeRenderTarget && (m = m.texture),
                a.material.uniforms.envMap.value = m,
                a.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1,
                c === m && u === m.version && h === t.toneMapping || (a.material.needsUpdate = !0,
                c = m,
                u = m.version,
                h = t.toneMapping),
                n.unshift(a, a.geometry, a.material, 0, 0, null)) : m && m.isTexture && (void 0 === s && (s = new Cn(new Zn(2,2),new In({
                    name: "BackgroundMaterial",
                    uniforms: On(Kn.background.uniforms),
                    vertexShader: Kn.background.vertexShader,
                    fragmentShader: Kn.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                s.geometry.deleteAttribute("normal"),
                Object.defineProperty(s.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }),
                i.update(s)),
                s.material.uniforms.t2D.value = m,
                !0 === m.matrixAutoUpdate && m.updateMatrix(),
                s.material.uniforms.uvTransform.value.copy(m.matrix),
                c === m && u === m.version && h === t.toneMapping || (s.material.needsUpdate = !0,
                c = m,
                u = m.version,
                h = t.toneMapping),
                n.unshift(s, s.geometry, s.material, 0, 0, null))
            }
        }
    }
    function ti(t, e, n, i) {
        const r = t.getParameter(34921)
          , o = i.isWebGL2 ? null : e.get("OES_vertex_array_object")
          , s = i.isWebGL2 || null !== o
          , a = {}
          , l = d(null);
        let c = l;
        function u(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : o.bindVertexArrayOES(e)
        }
        function h(e) {
            return i.isWebGL2 ? t.deleteVertexArray(e) : o.deleteVertexArrayOES(e)
        }
        function d(t) {
            const e = []
              , n = []
              , i = [];
            for (let t = 0; t < r; t++)
                e[t] = 0,
                n[t] = 0,
                i[t] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: e,
                enabledAttributes: n,
                attributeDivisors: i,
                object: t,
                attributes: {},
                index: null
            }
        }
        function p() {
            const t = c.newAttributes;
            for (let e = 0, n = t.length; e < n; e++)
                t[e] = 0
        }
        function f(t) {
            m(t, 0)
        }
        function m(n, r) {
            const o = c.newAttributes
              , s = c.enabledAttributes
              , a = c.attributeDivisors;
            if (o[n] = 1,
            0 === s[n] && (t.enableVertexAttribArray(n),
            s[n] = 1),
            a[n] !== r) {
                (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r),
                a[n] = r
            }
        }
        function g() {
            const e = c.newAttributes
              , n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++)
                n[i] !== e[i] && (t.disableVertexAttribArray(i),
                n[i] = 0)
        }
        function v(e, n, r, o, s, a) {
            !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, o, s, a) : t.vertexAttribIPointer(e, n, r, s, a)
        }
        function y() {
            _(),
            c !== l && (c = l,
            u(c.object))
        }
        function _() {
            l.geometry = null,
            l.program = null,
            l.wireframe = !1
        }
        return {
            setup: function(r, l, h, y, _) {
                let x = !1;
                if (s) {
                    const e = function(e, n, r) {
                        const s = !0 === r.wireframe;
                        let l = a[e.id];
                        void 0 === l && (l = {},
                        a[e.id] = l);
                        let c = l[n.id];
                        void 0 === c && (c = {},
                        l[n.id] = c);
                        let u = c[s];
                        void 0 === u && (u = d(i.isWebGL2 ? t.createVertexArray() : o.createVertexArrayOES()),
                        c[s] = u);
                        return u
                    }(y, h, l);
                    c !== e && (c = e,
                    u(c.object)),
                    x = function(t, e) {
                        const n = c.attributes
                          , i = t.attributes;
                        let r = 0;
                        for (const t in i) {
                            const e = n[t]
                              , o = i[t];
                            if (void 0 === e)
                                return !0;
                            if (e.attribute !== o)
                                return !0;
                            if (e.data !== o.data)
                                return !0;
                            r++
                        }
                        return c.attributesNum !== r || c.index !== e
                    }(y, _),
                    x && function(t, e) {
                        const n = {}
                          , i = t.attributes;
                        let r = 0;
                        for (const t in i) {
                            const e = i[t]
                              , o = {};
                            o.attribute = e,
                            e.data && (o.data = e.data),
                            n[t] = o,
                            r++
                        }
                        c.attributes = n,
                        c.attributesNum = r,
                        c.index = e
                    }(y, _)
                } else {
                    const t = !0 === l.wireframe;
                    c.geometry === y.id && c.program === h.id && c.wireframe === t || (c.geometry = y.id,
                    c.program = h.id,
                    c.wireframe = t,
                    x = !0)
                }
                !0 === r.isInstancedMesh && (x = !0),
                null !== _ && n.update(_, 34963),
                x && (!function(r, o, s, a) {
                    if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays"))
                        return;
                    p();
                    const l = a.attributes
                      , c = s.getAttributes()
                      , u = o.defaultAttributeValues;
                    for (const e in c) {
                        const i = c[e];
                        if (i >= 0) {
                            const o = l[e];
                            if (void 0 !== o) {
                                const e = o.normalized
                                  , r = o.itemSize
                                  , s = n.get(o);
                                if (void 0 === s)
                                    continue;
                                const l = s.buffer
                                  , c = s.type
                                  , u = s.bytesPerElement;
                                if (o.isInterleavedBufferAttribute) {
                                    const n = o.data
                                      , s = n.stride
                                      , h = o.offset;
                                    n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute),
                                    void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : f(i),
                                    t.bindBuffer(34962, l),
                                    v(i, r, c, e, s * u, h * u)
                                } else
                                    o.isInstancedBufferAttribute ? (m(i, o.meshPerAttribute),
                                    void 0 === a._maxInstanceCount && (a._maxInstanceCount = o.meshPerAttribute * o.count)) : f(i),
                                    t.bindBuffer(34962, l),
                                    v(i, r, c, e, 0, 0)
                            } else if ("instanceMatrix" === e) {
                                const e = n.get(r.instanceMatrix);
                                if (void 0 === e)
                                    continue;
                                const o = e.buffer
                                  , s = e.type;
                                m(i + 0, 1),
                                m(i + 1, 1),
                                m(i + 2, 1),
                                m(i + 3, 1),
                                t.bindBuffer(34962, o),
                                t.vertexAttribPointer(i + 0, 4, s, !1, 64, 0),
                                t.vertexAttribPointer(i + 1, 4, s, !1, 64, 16),
                                t.vertexAttribPointer(i + 2, 4, s, !1, 64, 32),
                                t.vertexAttribPointer(i + 3, 4, s, !1, 64, 48)
                            } else if ("instanceColor" === e) {
                                const e = n.get(r.instanceColor);
                                if (void 0 === e)
                                    continue;
                                const o = e.buffer
                                  , s = e.type;
                                m(i, 1),
                                t.bindBuffer(34962, o),
                                t.vertexAttribPointer(i, 3, s, !1, 12, 0)
                            } else if (void 0 !== u) {
                                const n = u[e];
                                if (void 0 !== n)
                                    switch (n.length) {
                                    case 2:
                                        t.vertexAttrib2fv(i, n);
                                        break;
                                    case 3:
                                        t.vertexAttrib3fv(i, n);
                                        break;
                                    case 4:
                                        t.vertexAttrib4fv(i, n);
                                        break;
                                    default:
                                        t.vertexAttrib1fv(i, n)
                                    }
                            }
                        }
                    }
                    g()
                }(r, l, h, y),
                null !== _ && t.bindBuffer(34963, n.get(_).buffer))
            },
            reset: y,
            resetDefaultState: _,
            dispose: function() {
                y();
                for (const t in a) {
                    const e = a[t];
                    for (const t in e) {
                        const n = e[t];
                        for (const t in n)
                            h(n[t].object),
                            delete n[t];
                        delete e[t]
                    }
                    delete a[t]
                }
            },
            releaseStatesOfGeometry: function(t) {
                if (void 0 === a[t.id])
                    return;
                const e = a[t.id];
                for (const t in e) {
                    const n = e[t];
                    for (const t in n)
                        h(n[t].object),
                        delete n[t];
                    delete e[t]
                }
                delete a[t.id]
            },
            releaseStatesOfProgram: function(t) {
                for (const e in a) {
                    const n = a[e];
                    if (void 0 === n[t.id])
                        continue;
                    const i = n[t.id];
                    for (const t in i)
                        h(i[t].object),
                        delete i[t];
                    delete n[t.id]
                }
            },
            initAttributes: p,
            enableAttribute: f,
            disableUnusedAttributes: g
        }
    }
    function ei(t, e, n, i) {
        const r = i.isWebGL2;
        let o;
        this.setMode = function(t) {
            o = t
        }
        ,
        this.render = function(e, i) {
            t.drawArrays(o, e, i),
            n.update(i, o, 1)
        }
        ,
        this.renderInstances = function(i, s, a) {
            if (0 === a)
                return;
            let l, c;
            if (r)
                l = t,
                c = "drawArraysInstanced";
            else if (l = e.get("ANGLE_instanced_arrays"),
            c = "drawArraysInstancedANGLE",
            null === l)
                return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[c](o, i, s, a),
            n.update(s, o, a)
        }
    }
    function ni(t, e, n) {
        let i;
        function r(e) {
            if ("highp" === e) {
                if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0)
                    return "highp";
                e = "mediump"
            }
            return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        const o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
        let s = void 0 !== n.precision ? n.precision : "highp";
        const a = r(s);
        a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."),
        s = a);
        const l = !0 === n.logarithmicDepthBuffer
          , c = t.getParameter(34930)
          , u = t.getParameter(35660)
          , h = t.getParameter(3379)
          , d = t.getParameter(34076)
          , p = t.getParameter(34921)
          , f = t.getParameter(36347)
          , m = t.getParameter(36348)
          , g = t.getParameter(36349)
          , v = u > 0
          , y = o || !!e.get("OES_texture_float");
        return {
            isWebGL2: o,
            getMaxAnisotropy: function() {
                if (void 0 !== i)
                    return i;
                const n = e.get("EXT_texture_filter_anisotropic");
                return i = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
                i
            },
            getMaxPrecision: r,
            precision: s,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: u,
            maxTextureSize: h,
            maxCubemapSize: d,
            maxAttributes: p,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: o ? t.getParameter(36183) : 0
        }
    }
    function ii(t) {
        const e = this;
        let n = null
          , i = 0
          , r = !1
          , o = !1;
        const s = new ve
          , a = new rt
          , l = {
            value: null,
            needsUpdate: !1
        };
        function c() {
            l.value !== n && (l.value = n,
            l.needsUpdate = i > 0),
            e.numPlanes = i,
            e.numIntersection = 0
        }
        function u(t, n, i, r) {
            const o = null !== t ? t.length : 0;
            let c = null;
            if (0 !== o) {
                if (c = l.value,
                !0 !== r || null === c) {
                    const e = i + 4 * o
                      , r = n.matrixWorldInverse;
                    a.getNormalMatrix(r),
                    (null === c || c.length < e) && (c = new Float32Array(e));
                    for (let e = 0, n = i; e !== o; ++e,
                    n += 4)
                        s.copy(t[e]).applyMatrix4(r, a),
                        s.normal.toArray(c, n),
                        c[n + 3] = s.constant
                }
                l.value = c,
                l.needsUpdate = !0
            }
            return e.numPlanes = o,
            e.numIntersection = 0,
            c
        }
        this.uniform = l,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(t, e, o) {
            const s = 0 !== t.length || e || 0 !== i || r;
            return r = e,
            n = u(t, o, 0),
            i = t.length,
            s
        }
        ,
        this.beginShadows = function() {
            o = !0,
            u(null)
        }
        ,
        this.endShadows = function() {
            o = !1,
            c()
        }
        ,
        this.setState = function(e, s, a) {
            const h = e.clippingPlanes
              , d = e.clipIntersection
              , p = e.clipShadows
              , f = t.get(e);
            if (!r || null === h || 0 === h.length || o && !p)
                o ? u(null) : c();
            else {
                const t = o ? 0 : i
                  , e = 4 * t;
                let r = f.clippingState || null;
                l.value = r,
                r = u(h, s, e, a);
                for (let t = 0; t !== e; ++t)
                    r[t] = n[t];
                f.clippingState = r,
                this.numIntersection = d ? this.numPlanes : 0,
                this.numPlanes += t
            }
        }
    }
    function ri(t) {
        let e = new WeakMap;
        function n(t, e) {
            return 303 === e ? t.mapping = g : 304 === e && (t.mapping = v),
            t
        }
        function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n),
            r.dispose())
        }
        return {
            get: function(r) {
                if (r && r.isTexture) {
                    const o = r.mapping;
                    if (303 === o || 304 === o) {
                        if (e.has(r)) {
                            return n(e.get(r).texture, r.mapping)
                        }
                        {
                            const o = r.image;
                            if (o && o.height > 0) {
                                const s = t.getRenderList()
                                  , a = t.getRenderTarget()
                                  , l = new Gn(o.height / 2);
                                return l.fromEquirectangularTexture(t, r),
                                e.set(r, l),
                                t.setRenderTarget(a),
                                t.setRenderList(s),
                                r.addEventListener("dispose", i),
                                n(l.texture, r.mapping)
                            }
                            return null
                        }
                    }
                }
                return r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function oi(t) {
        const e = {};
        return {
            has: function(n) {
                if (void 0 !== e[n])
                    return null !== e[n];
                let i;
                switch (n) {
                case "WEBGL_depth_texture":
                    i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = t.getExtension(n)
                }
                return e[n] = i,
                null !== i
            },
            get: function(t) {
                return this.has(t) || console.warn("THREE.WebGLRenderer: " + t + " extension not supported."),
                e[t]
            }
        }
    }
    function si(t, e, n, i) {
        const r = new WeakMap
          , o = new WeakMap;
        function s(t) {
            const a = t.target
              , l = r.get(a);
            null !== l.index && e.remove(l.index);
            for (const t in l.attributes)
                e.remove(l.attributes[t]);
            a.removeEventListener("dispose", s),
            r.delete(a);
            const c = o.get(l);
            c && (e.remove(c),
            o.delete(l)),
            i.releaseStatesOfGeometry(l),
            !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
            n.memory.geometries--
        }
        function a(t) {
            const n = []
              , i = t.index
              , r = t.attributes.position;
            let s = 0;
            if (null !== i) {
                const t = i.array;
                s = i.version;
                for (let e = 0, i = t.length; e < i; e += 3) {
                    const i = t[e + 0]
                      , r = t[e + 1]
                      , o = t[e + 2];
                    n.push(i, r, r, o, o, i)
                }
            } else {
                const t = r.array;
                s = r.version;
                for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                    const t = e + 0
                      , i = e + 1
                      , r = e + 2;
                    n.push(t, i, i, r, r, t)
                }
            }
            const a = new (tn(n) > 65535 ? Ze : Xe)(n,1);
            a.version = s;
            const l = o.get(t);
            l && e.remove(l),
            o.set(t, a)
        }
        return {
            get: function(t, e) {
                let i = r.get(e);
                return i || (e.addEventListener("dispose", s),
                e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new hn).setFromObject(t)),
                i = e._bufferGeometry),
                r.set(e, i),
                n.memory.geometries++,
                i)
            },
            update: function(t) {
                const n = t.attributes;
                for (const t in n)
                    e.update(n[t], 34962);
                const i = t.morphAttributes;
                for (const t in i) {
                    const n = i[t];
                    for (let t = 0, i = n.length; t < i; t++)
                        e.update(n[t], 34962)
                }
            },
            getWireframeAttribute: function(t) {
                const e = o.get(t);
                if (e) {
                    const n = t.index;
                    null !== n && e.version < n.version && a(t)
                } else
                    a(t);
                return o.get(t)
            }
        }
    }
    function ai(t, e, n, i) {
        const r = i.isWebGL2;
        let o, s, a;
        this.setMode = function(t) {
            o = t
        }
        ,
        this.setIndex = function(t) {
            s = t.type,
            a = t.bytesPerElement
        }
        ,
        this.render = function(e, i) {
            t.drawElements(o, i, s, e * a),
            n.update(i, o, 1)
        }
        ,
        this.renderInstances = function(i, l, c) {
            if (0 === c)
                return;
            let u, h;
            if (r)
                u = t,
                h = "drawElementsInstanced";
            else if (u = e.get("ANGLE_instanced_arrays"),
            h = "drawElementsInstancedANGLE",
            null === u)
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            u[h](o, l, s, i * a, c),
            n.update(l, o, c)
        }
    }
    function li(t) {
        const e = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function() {
                e.frame++,
                e.calls = 0,
                e.triangles = 0,
                e.points = 0,
                e.lines = 0
            },
            update: function(t, n, i) {
                switch (e.calls++,
                n) {
                case 4:
                    e.triangles += i * (t / 3);
                    break;
                case 1:
                    e.lines += i * (t / 2);
                    break;
                case 3:
                    e.lines += i * (t - 1);
                    break;
                case 2:
                    e.lines += i * t;
                    break;
                case 0:
                    e.points += i * t;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                }
            }
        }
    }
    function ci(t, e) {
        return t[0] - e[0]
    }
    function ui(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }
    function hi(t) {
        const e = {}
          , n = new Float32Array(8)
          , i = [];
        for (let t = 0; t < 8; t++)
            i[t] = [t, 0];
        return {
            update: function(r, o, s, a) {
                const l = r.morphTargetInfluences
                  , c = void 0 === l ? 0 : l.length;
                let u = e[o.id];
                if (void 0 === u) {
                    u = [];
                    for (let t = 0; t < c; t++)
                        u[t] = [t, 0];
                    e[o.id] = u
                }
                for (let t = 0; t < c; t++) {
                    const e = u[t];
                    e[0] = t,
                    e[1] = l[t]
                }
                u.sort(ui);
                for (let t = 0; t < 8; t++)
                    t < c && u[t][1] ? (i[t][0] = u[t][0],
                    i[t][1] = u[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER,
                    i[t][1] = 0);
                i.sort(ci);
                const h = s.morphTargets && o.morphAttributes.position
                  , d = s.morphNormals && o.morphAttributes.normal;
                let p = 0;
                for (let t = 0; t < 8; t++) {
                    const e = i[t]
                      , r = e[0]
                      , s = e[1];
                    r !== Number.MAX_SAFE_INTEGER && s ? (h && o.getAttribute("morphTarget" + t) !== h[r] && o.setAttribute("morphTarget" + t, h[r]),
                    d && o.getAttribute("morphNormal" + t) !== d[r] && o.setAttribute("morphNormal" + t, d[r]),
                    n[t] = s,
                    p += s) : (h && !0 === o.hasAttribute("morphTarget" + t) && o.deleteAttribute("morphTarget" + t),
                    d && !0 === o.hasAttribute("morphNormal" + t) && o.deleteAttribute("morphNormal" + t),
                    n[t] = 0)
                }
                const f = o.morphTargetsRelative ? 1 : 1 - p;
                a.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
                a.getUniforms().setValue(t, "morphTargetInfluences", n)
            }
        }
    }
    function di(t, e, n, i) {
        let r = new WeakMap;
        function o(t) {
            const e = t.target;
            e.removeEventListener("dispose", o),
            n.remove(e.instanceMatrix),
            null !== e.instanceColor && n.remove(e.instanceColor)
        }
        return {
            update: function(t) {
                const s = i.render.frame
                  , a = t.geometry
                  , l = e.get(t, a);
                return r.get(l) !== s && (a.isGeometry && l.updateFromObject(t),
                e.update(l),
                r.set(l, s)),
                t.isInstancedMesh && (!1 === t.hasEventListener("dispose", o) && t.addEventListener("dispose", o),
                n.update(t.instanceMatrix, 34962),
                null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                l
            },
            dispose: function() {
                r = new WeakMap
            }
        }
    }
    function pi(t=null, e=1, n=1, i=1) {
        lt.call(this, null),
        this.image = {
            data: t,
            width: e,
            height: n,
            depth: i
        },
        this.magFilter = M,
        this.minFilter = M,
        this.wrapR = b,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.needsUpdate = !0
    }
    function fi(t=null, e=1, n=1, i=1) {
        lt.call(this, null),
        this.image = {
            data: t,
            width: e,
            height: n,
            depth: i
        },
        this.magFilter = M,
        this.minFilter = M,
        this.wrapR = b,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.needsUpdate = !0
    }
    Kn.physical = {
        uniforms: Fn([Kn.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new it(1,1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new Ne(0)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            }
        }]),
        vertexShader: Jn.meshphysical_vert,
        fragmentShader: Jn.meshphysical_frag
    },
    pi.prototype = Object.create(lt.prototype),
    pi.prototype.constructor = pi,
    pi.prototype.isDataTexture2DArray = !0,
    fi.prototype = Object.create(lt.prototype),
    fi.prototype.constructor = fi,
    fi.prototype.isDataTexture3D = !0;
    const mi = new lt
      , gi = new pi
      , vi = new fi
      , yi = new Hn
      , _i = []
      , xi = []
      , bi = new Float32Array(16)
      , wi = new Float32Array(9)
      , Mi = new Float32Array(4);
    function Si(t, e, n) {
        const i = t[0];
        if (i <= 0 || i > 0)
            return t;
        const r = e * n;
        let o = _i[r];
        if (void 0 === o && (o = new Float32Array(r),
        _i[r] = o),
        0 !== e) {
            i.toArray(o, 0);
            for (let i = 1, r = 0; i !== e; ++i)
                r += n,
                t[i].toArray(o, r)
        }
        return o
    }
    function Ei(t, e) {
        if (t.length !== e.length)
            return !1;
        for (let n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n])
                return !1;
        return !0
    }
    function Di(t, e) {
        for (let n = 0, i = e.length; n < i; n++)
            t[n] = e[n]
    }
    function Ti(t, e) {
        let n = xi[e];
        void 0 === n && (n = new Int32Array(e),
        xi[e] = n);
        for (let i = 0; i !== e; ++i)
            n[i] = t.allocateTextureUnit();
        return n
    }
    function Ai(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e),
        n[0] = e)
    }
    function Ci(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
            n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y),
            n[0] = e.x,
            n[1] = e.y);
        else {
            if (Ei(n, e))
                return;
            t.uniform2fv(this.addr, e),
            Di(n, e)
        }
    }
    function Li(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
            n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z),
            n[0] = e.x,
            n[1] = e.y,
            n[2] = e.z);
        else if (void 0 !== e.r)
            n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b),
            n[0] = e.r,
            n[1] = e.g,
            n[2] = e.b);
        else {
            if (Ei(n, e))
                return;
            t.uniform3fv(this.addr, e),
            Di(n, e)
        }
    }
    function Pi(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
            n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            n[0] = e.x,
            n[1] = e.y,
            n[2] = e.z,
            n[3] = e.w);
        else {
            if (Ei(n, e))
                return;
            t.uniform4fv(this.addr, e),
            Di(n, e)
        }
    }
    function Ri(t, e) {
        const n = this.cache
          , i = e.elements;
        if (void 0 === i) {
            if (Ei(n, e))
                return;
            t.uniformMatrix2fv(this.addr, !1, e),
            Di(n, e)
        } else {
            if (Ei(n, i))
                return;
            Mi.set(i),
            t.uniformMatrix2fv(this.addr, !1, Mi),
            Di(n, i)
        }
    }
    function Oi(t, e) {
        const n = this.cache
          , i = e.elements;
        if (void 0 === i) {
            if (Ei(n, e))
                return;
            t.uniformMatrix3fv(this.addr, !1, e),
            Di(n, e)
        } else {
            if (Ei(n, i))
                return;
            wi.set(i),
            t.uniformMatrix3fv(this.addr, !1, wi),
            Di(n, i)
        }
    }
    function Fi(t, e) {
        const n = this.cache
          , i = e.elements;
        if (void 0 === i) {
            if (Ei(n, e))
                return;
            t.uniformMatrix4fv(this.addr, !1, e),
            Di(n, e)
        } else {
            if (Ei(n, i))
                return;
            bi.set(i),
            t.uniformMatrix4fv(this.addr, !1, bi),
            Di(n, i)
        }
    }
    function Ni(t, e, n) {
        const i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.safeSetTexture2D(e || mi, r)
    }
    function Ii(t, e, n) {
        const i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.setTexture2DArray(e || gi, r)
    }
    function Bi(t, e, n) {
        const i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.setTexture3D(e || vi, r)
    }
    function ki(t, e, n) {
        const i = this.cache
          , r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r),
        i[0] = r),
        n.safeSetTextureCube(e || yi, r)
    }
    function zi(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e),
        n[0] = e)
    }
    function Ui(t, e) {
        const n = this.cache;
        Ei(n, e) || (t.uniform2iv(this.addr, e),
        Di(n, e))
    }
    function Hi(t, e) {
        const n = this.cache;
        Ei(n, e) || (t.uniform3iv(this.addr, e),
        Di(n, e))
    }
    function Gi(t, e) {
        const n = this.cache;
        Ei(n, e) || (t.uniform4iv(this.addr, e),
        Di(n, e))
    }
    function Vi(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e),
        n[0] = e)
    }
    function ji(t, e) {
        t.uniform1fv(this.addr, e)
    }
    function Wi(t, e) {
        t.uniform1iv(this.addr, e)
    }
    function qi(t, e) {
        t.uniform2iv(this.addr, e)
    }
    function Xi(t, e) {
        t.uniform3iv(this.addr, e)
    }
    function Yi(t, e) {
        t.uniform4iv(this.addr, e)
    }
    function Zi(t, e) {
        const n = Si(e, this.size, 2);
        t.uniform2fv(this.addr, n)
    }
    function Ji(t, e) {
        const n = Si(e, this.size, 3);
        t.uniform3fv(this.addr, n)
    }
    function Qi(t, e) {
        const n = Si(e, this.size, 4);
        t.uniform4fv(this.addr, n)
    }
    function Ki(t, e) {
        const n = Si(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n)
    }
    function $i(t, e) {
        const n = Si(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n)
    }
    function tr(t, e) {
        const n = Si(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n)
    }
    function er(t, e, n) {
        const i = e.length
          , r = Ti(n, i);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== i; ++t)
            n.safeSetTexture2D(e[t] || mi, r[t])
    }
    function nr(t, e, n) {
        const i = e.length
          , r = Ti(n, i);
        t.uniform1iv(this.addr, r);
        for (let t = 0; t !== i; ++t)
            n.safeSetTextureCube(e[t] || yi, r[t])
    }
    function ir(t, e, n) {
        this.id = t,
        this.addr = n,
        this.cache = [],
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return Ai;
            case 35664:
                return Ci;
            case 35665:
                return Li;
            case 35666:
                return Pi;
            case 35674:
                return Ri;
            case 35675:
                return Oi;
            case 35676:
                return Fi;
            case 5124:
            case 35670:
                return zi;
            case 35667:
            case 35671:
                return Ui;
            case 35668:
            case 35672:
                return Hi;
            case 35669:
            case 35673:
                return Gi;
            case 5125:
                return Vi;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Ni;
            case 35679:
            case 36299:
            case 36307:
                return Bi;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return ki;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Ii
            }
        }(e.type)
    }
    function rr(t, e, n) {
        this.id = t,
        this.addr = n,
        this.cache = [],
        this.size = e.size,
        this.setValue = function(t) {
            switch (t) {
            case 5126:
                return ji;
            case 35664:
                return Zi;
            case 35665:
                return Ji;
            case 35666:
                return Qi;
            case 35674:
                return Ki;
            case 35675:
                return $i;
            case 35676:
                return tr;
            case 5124:
            case 35670:
                return Wi;
            case 35667:
            case 35671:
                return qi;
            case 35668:
            case 35672:
                return Xi;
            case 35669:
            case 35673:
                return Yi;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return er;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return nr
            }
        }(e.type)
    }
    function or(t) {
        this.id = t,
        this.seq = [],
        this.map = {}
    }
    rr.prototype.updateCache = function(t) {
        const e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)),
        Di(e, t)
    }
    ,
    or.prototype.setValue = function(t, e, n) {
        const i = this.seq;
        for (let r = 0, o = i.length; r !== o; ++r) {
            const o = i[r];
            o.setValue(t, e[o.id], n)
        }
    }
    ;
    const sr = /(\w+)(\])?(\[|\.)?/g;
    function ar(t, e) {
        t.seq.push(e),
        t.map[e.id] = e
    }
    function lr(t, e, n) {
        const i = t.name
          , r = i.length;
        for (sr.lastIndex = 0; ; ) {
            const o = sr.exec(i)
              , s = sr.lastIndex;
            let a = o[1];
            const l = "]" === o[2]
              , c = o[3];
            if (l && (a |= 0),
            void 0 === c || "[" === c && s + 2 === r) {
                ar(n, void 0 === c ? new ir(a,t,e) : new rr(a,t,e));
                break
            }
            {
                let t = n.map[a];
                void 0 === t && (t = new or(a),
                ar(n, t)),
                n = t
            }
        }
    }
    function cr(t, e) {
        this.seq = [],
        this.map = {};
        const n = t.getProgramParameter(e, 35718);
        for (let i = 0; i < n; ++i) {
            const n = t.getActiveUniform(e, i);
            lr(n, t.getUniformLocation(e, n.name), this)
        }
    }
    function ur(t, e, n) {
        const i = t.createShader(e);
        return t.shaderSource(i, n),
        t.compileShader(i),
        i
    }
    cr.prototype.setValue = function(t, e, n, i) {
        const r = this.map[e];
        void 0 !== r && r.setValue(t, n, i)
    }
    ,
    cr.prototype.setOptional = function(t, e, n) {
        const i = e[n];
        void 0 !== i && this.setValue(t, n, i)
    }
    ,
    cr.upload = function(t, e, n, i) {
        for (let r = 0, o = e.length; r !== o; ++r) {
            const o = e[r]
              , s = n[o.id];
            !1 !== s.needsUpdate && o.setValue(t, s.value, i)
        }
    }
    ,
    cr.seqWithValue = function(t, e) {
        const n = [];
        for (let i = 0, r = t.length; i !== r; ++i) {
            const r = t[i];
            r.id in e && n.push(r)
        }
        return n
    }
    ;
    let hr = 0;
    function dr(t) {
        switch (t) {
        case W:
            return ["Linear", "( value )"];
        case q:
            return ["sRGB", "( value )"];
        case Y:
            return ["RGBE", "( value )"];
        case 3004:
            return ["RGBM", "( value, 7.0 )"];
        case 3005:
            return ["RGBM", "( value, 16.0 )"];
        case 3006:
            return ["RGBD", "( value, 256.0 )"];
        case X:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
            return ["LogLuv", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
            ["Linear", "( value )"]
        }
    }
    function pr(t, e, n) {
        const i = t.getShaderParameter(e, 35713)
          , r = t.getShaderInfoLog(e).trim();
        if (i && "" === r)
            return "";
        return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) {
            const e = t.split("\n");
            for (let t = 0; t < e.length; t++)
                e[t] = t + 1 + ": " + e[t];
            return e.join("\n")
        }(t.getShaderSource(e))
    }
    function fr(t, e) {
        const n = dr(e);
        return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }
    function mr(t, e) {
        const n = dr(e);
        return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }
    function gr(t, e) {
        let n;
        switch (e) {
        case 1:
            n = "Linear";
            break;
        case 2:
            n = "Reinhard";
            break;
        case 3:
            n = "OptimizedCineon";
            break;
        case 4:
            n = "ACESFilmic";
            break;
        case 5:
            n = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
            n = "Linear"
        }
        return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }
    function vr(t) {
        return "" !== t
    }
    function yr(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }
    function _r(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    const xr = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function br(t) {
        return t.replace(xr, wr)
    }
    function wr(t, e) {
        const n = Jn[e];
        if (void 0 === n)
            throw new Error("Can not resolve #include <" + e + ">");
        return br(n)
    }
    const Mr = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
      , Sr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function Er(t) {
        return t.replace(Sr, Tr).replace(Mr, Dr)
    }
    function Dr(t, e, n, i) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
        Tr(t, e, n, i)
    }
    function Tr(t, e, n, i) {
        let r = "";
        for (let t = parseInt(e); t < parseInt(n); t++)
            r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
        return r
    }
    function Ar(t) {
        let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
        return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
        e
    }
    function Cr(t, e, n, i) {
        const r = t.getContext()
          , o = n.defines;
        let s = n.vertexShader
          , a = n.fragmentShader;
        const l = function(t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
            e
        }(n)
          , c = function(t) {
            let e = "ENVMAP_TYPE_CUBE";
            if (t.envMap)
                switch (t.envMapMode) {
                case g:
                case v:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                case y:
                case _:
                    e = "ENVMAP_TYPE_CUBE_UV"
                }
            return e
        }(n)
          , u = function(t) {
            let e = "ENVMAP_MODE_REFLECTION";
            if (t.envMap)
                switch (t.envMapMode) {
                case v:
                case _:
                    e = "ENVMAP_MODE_REFRACTION"
                }
            return e
        }(n)
          , h = function(t) {
            let e = "ENVMAP_BLENDING_NONE";
            if (t.envMap)
                switch (t.combine) {
                case 0:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    e = "ENVMAP_BLENDING_ADD"
                }
            return e
        }(n)
          , d = t.gammaFactor > 0 ? t.gammaFactor : 1
          , p = n.isWebGL2 ? "" : function(t) {
            return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(vr).join("\n")
        }(n)
          , f = function(t) {
            const e = [];
            for (const n in t) {
                const i = t[n];
                !1 !== i && e.push("#define " + n + " " + i)
            }
            return e.join("\n")
        }(o)
          , m = r.createProgram();
        let x, b, w = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial ? (x = [f].filter(vr).join("\n"),
        x.length > 0 && (x += "\n"),
        b = [p, f].filter(vr).join("\n"),
        b.length > 0 && (b += "\n")) : (x = [Ar(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(vr).join("\n"),
        b = [p, Ar(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Jn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? gr("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Jn.encodings_pars_fragment, n.map ? fr("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? fr("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? fr("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? fr("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? fr("lightMapTexelToLinear", n.lightMapEncoding) : "", mr("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(vr).join("\n")),
        s = br(s),
        s = yr(s, n),
        s = _r(s, n),
        a = br(a),
        a = yr(a, n),
        a = _r(a, n),
        s = Er(s),
        a = Er(a),
        n.isWebGL2 && !0 !== n.isRawShaderMaterial && (w = "#version 300 es\n",
        x = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + x,
        b = ["#define varying in", n.glslVersion === K ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === K ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + b);
        const M = w + b + a
          , S = ur(r, 35633, w + x + s)
          , E = ur(r, 35632, M);
        if (r.attachShader(m, S),
        r.attachShader(m, E),
        void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
        r.linkProgram(m),
        t.debug.checkShaderErrors) {
            const t = r.getProgramInfoLog(m).trim()
              , e = r.getShaderInfoLog(S).trim()
              , n = r.getShaderInfoLog(E).trim();
            let i = !0
              , o = !0;
            if (!1 === r.getProgramParameter(m, 35714)) {
                i = !1;
                const e = pr(r, S, "vertex")
                  , n = pr(r, E, "fragment");
                console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, n)
            } else
                "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (o = !1);
            o && (this.diagnostics = {
                runnable: i,
                programLog: t,
                vertexShader: {
                    log: e,
                    prefix: x
                },
                fragmentShader: {
                    log: n,
                    prefix: b
                }
            })
        }
        let D, T;
        return r.deleteShader(S),
        r.deleteShader(E),
        this.getUniforms = function() {
            return void 0 === D && (D = new cr(r,m)),
            D
        }
        ,
        this.getAttributes = function() {
            return void 0 === T && (T = function(t, e) {
                const n = {}
                  , i = t.getProgramParameter(e, 35721);
                for (let r = 0; r < i; r++) {
                    const i = t.getActiveAttrib(e, r).name;
                    n[i] = t.getAttribLocation(e, i)
                }
                return n
            }(r, m)),
            T
        }
        ,
        this.destroy = function() {
            i.releaseStatesOfProgram(this),
            r.deleteProgram(m),
            this.program = void 0
        }
        ,
        this.name = n.shaderName,
        this.id = hr++,
        this.cacheKey = e,
        this.usedTimes = 1,
        this.program = m,
        this.vertexShader = S,
        this.fragmentShader = E,
        this
    }
    function Lr(t, e, n, i, r, o) {
        const s = []
          , a = i.isWebGL2
          , l = i.logarithmicDepthBuffer
          , c = i.floatVertexTextures
          , u = i.maxVertexUniforms
          , h = i.vertexTextures;
        let d = i.precision;
        const p = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
        function m(t) {
            let e;
            return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            e = t.texture.encoding) : e = W,
            e
        }
        return {
            getParameters: function(r, s, f, g, v) {
                const x = g.fog
                  , b = r.isMeshStandardMaterial ? g.environment : null
                  , w = e.get(r.envMap || b)
                  , M = p[r.type]
                  , S = v.isSkinnedMesh ? function(t) {
                    const e = t.skeleton.bones;
                    if (c)
                        return 1024;
                    {
                        const t = u
                          , n = Math.floor((t - 20) / 4)
                          , i = Math.min(n, e.length);
                        return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."),
                        0) : i
                    }
                }(v) : 0;
                let E, D;
                if (null !== r.precision && (d = i.getMaxPrecision(r.precision),
                d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")),
                M) {
                    const t = Kn[M];
                    E = t.vertexShader,
                    D = t.fragmentShader
                } else
                    E = r.vertexShader,
                    D = r.fragmentShader;
                const T = t.getRenderTarget();
                return {
                    isWebGL2: a,
                    shaderID: M,
                    shaderName: r.type,
                    vertexShader: E,
                    fragmentShader: D,
                    defines: r.defines,
                    isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                    glslVersion: r.glslVersion,
                    precision: d,
                    instancing: !0 === v.isInstancedMesh,
                    instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                    supportsVertexTextures: h,
                    outputEncoding: null !== T ? m(T.texture) : t.outputEncoding,
                    map: !!r.map,
                    mapEncoding: m(r.map),
                    matcap: !!r.matcap,
                    matcapEncoding: m(r.matcap),
                    envMap: !!w,
                    envMapMode: w && w.mapping,
                    envMapEncoding: m(w),
                    envMapCubeUV: !!w && (w.mapping === y || w.mapping === _),
                    lightMap: !!r.lightMap,
                    lightMapEncoding: m(r.lightMap),
                    aoMap: !!r.aoMap,
                    emissiveMap: !!r.emissiveMap,
                    emissiveMapEncoding: m(r.emissiveMap),
                    bumpMap: !!r.bumpMap,
                    normalMap: !!r.normalMap,
                    objectSpaceNormalMap: 1 === r.normalMapType,
                    tangentSpaceNormalMap: 0 === r.normalMapType,
                    clearcoatMap: !!r.clearcoatMap,
                    clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                    clearcoatNormalMap: !!r.clearcoatNormalMap,
                    displacementMap: !!r.displacementMap,
                    roughnessMap: !!r.roughnessMap,
                    metalnessMap: !!r.metalnessMap,
                    specularMap: !!r.specularMap,
                    alphaMap: !!r.alphaMap,
                    gradientMap: !!r.gradientMap,
                    sheen: !!r.sheen,
                    transmissionMap: !!r.transmissionMap,
                    combine: r.combine,
                    vertexTangents: r.normalMap && r.vertexTangents,
                    vertexColors: r.vertexColors,
                    vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap),
                    uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap),
                    fog: !!x,
                    useFog: r.fog,
                    fogExp2: x && x.isFogExp2,
                    flatShading: r.flatShading,
                    sizeAttenuation: r.sizeAttenuation,
                    logarithmicDepthBuffer: l,
                    skinning: r.skinning && S > 0,
                    maxBones: S,
                    useVertexTexture: c,
                    morphTargets: r.morphTargets,
                    morphNormals: r.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: s.directional.length,
                    numPointLights: s.point.length,
                    numSpotLights: s.spot.length,
                    numRectAreaLights: s.rectArea.length,
                    numHemiLights: s.hemi.length,
                    numDirLightShadows: s.directionalShadowMap.length,
                    numPointLightShadows: s.pointShadowMap.length,
                    numSpotLightShadows: s.spotShadowMap.length,
                    numClippingPlanes: o.numPlanes,
                    numClipIntersection: o.numIntersection,
                    dithering: r.dithering,
                    shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: r.toneMapped ? t.toneMapping : 0,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: r.premultipliedAlpha,
                    alphaTest: r.alphaTest,
                    doubleSided: 2 === r.side,
                    flipSided: 1 === r.side,
                    depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                    index0AttributeName: r.index0AttributeName,
                    extensionDerivatives: r.extensions && r.extensions.derivatives,
                    extensionFragDepth: r.extensions && r.extensions.fragDepth,
                    extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                    extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: r.customProgramCacheKey()
                }
            },
            getProgramCacheKey: function(e) {
                const n = [];
                if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader),
                n.push(e.vertexShader)),
                void 0 !== e.defines)
                    for (const t in e.defines)
                        n.push(t),
                        n.push(e.defines[t]);
                if (!1 === e.isRawShaderMaterial) {
                    for (let t = 0; t < f.length; t++)
                        n.push(e[f[t]]);
                    n.push(t.outputEncoding),
                    n.push(t.gammaFactor)
                }
                return n.push(e.customProgramCacheKey),
                n.join()
            },
            getUniforms: function(t) {
                const e = p[t.type];
                let n;
                if (e) {
                    const t = Kn[e];
                    n = Nn.clone(t.uniforms)
                } else
                    n = t.uniforms;
                return n
            },
            acquireProgram: function(e, n) {
                let i;
                for (let t = 0, e = s.length; t < e; t++) {
                    const e = s[t];
                    if (e.cacheKey === n) {
                        i = e,
                        ++i.usedTimes;
                        break
                    }
                }
                return void 0 === i && (i = new Cr(t,n,e,r),
                s.push(i)),
                i
            },
            releaseProgram: function(t) {
                if (0 == --t.usedTimes) {
                    const e = s.indexOf(t);
                    s[e] = s[s.length - 1],
                    s.pop(),
                    t.destroy()
                }
            },
            programs: s
        }
    }
    function Pr() {
        let t = new WeakMap;
        return {
            get: function(e) {
                let n = t.get(e);
                return void 0 === n && (n = {},
                t.set(e, n)),
                n
            },
            remove: function(e) {
                t.delete(e)
            },
            update: function(e, n, i) {
                t.get(e)[n] = i
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    function Rr(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }
    function Or(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }
    function Fr(t) {
        const e = [];
        let n = 0;
        const i = []
          , r = []
          , o = {
            id: -1
        };
        function s(i, r, s, a, l, c) {
            let u = e[n];
            const h = t.get(s);
            return void 0 === u ? (u = {
                id: i.id,
                object: i,
                geometry: r,
                material: s,
                program: h.program || o,
                groupOrder: a,
                renderOrder: i.renderOrder,
                z: l,
                group: c
            },
            e[n] = u) : (u.id = i.id,
            u.object = i,
            u.geometry = r,
            u.material = s,
            u.program = h.program || o,
            u.groupOrder = a,
            u.renderOrder = i.renderOrder,
            u.z = l,
            u.group = c),
            n++,
            u
        }
        return {
            opaque: i,
            transparent: r,
            init: function() {
                n = 0,
                i.length = 0,
                r.length = 0
            },
            push: function(t, e, n, o, a, l) {
                const c = s(t, e, n, o, a, l);
                (!0 === n.transparent ? r : i).push(c)
            },
            unshift: function(t, e, n, o, a, l) {
                const c = s(t, e, n, o, a, l);
                (!0 === n.transparent ? r : i).unshift(c)
            },
            finish: function() {
                for (let t = n, i = e.length; t < i; t++) {
                    const n = e[t];
                    if (null === n.id)
                        break;
                    n.id = null,
                    n.object = null,
                    n.geometry = null,
                    n.material = null,
                    n.program = null,
                    n.group = null
                }
            },
            sort: function(t, e) {
                i.length > 1 && i.sort(t || Rr),
                r.length > 1 && r.sort(e || Or)
            }
        }
    }
    function Nr(t) {
        let e = new WeakMap;
        return {
            get: function(n, i) {
                const r = e.get(n);
                let o;
                return void 0 === r ? (o = new Fr(t),
                e.set(n, new WeakMap),
                e.get(n).set(i, o)) : (o = r.get(i),
                void 0 === o && (o = new Fr(t),
                r.set(i, o))),
                o
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function Ir() {
        const t = {};
        return {
            get: function(e) {
                if (void 0 !== t[e.id])
                    return t[e.id];
                let n;
                switch (e.type) {
                case "DirectionalLight":
                    n = {
                        direction: new ft,
                        color: new Ne
                    };
                    break;
                case "SpotLight":
                    n = {
                        position: new ft,
                        direction: new ft,
                        color: new Ne,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    n = {
                        position: new ft,
                        color: new Ne,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    n = {
                        direction: new ft,
                        skyColor: new Ne,
                        groundColor: new Ne
                    };
                    break;
                case "RectAreaLight":
                    n = {
                        color: new Ne,
                        position: new ft,
                        halfWidth: new ft,
                        halfHeight: new ft
                    }
                }
                return t[e.id] = n,
                n
            }
        }
    }
    let Br = 0;
    function kr(t, e) {
        return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
    }
    function zr(t, e) {
        const n = new Ir
          , i = function() {
            const t = {};
            return {
                get: function(e) {
                    if (void 0 !== t[e.id])
                        return t[e.id];
                    let n;
                    switch (e.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                        n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new it
                        };
                        break;
                    case "PointLight":
                        n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new it,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        }
                    }
                    return t[e.id] = n,
                    n
                }
            }
        }()
          , r = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        };
        for (let t = 0; t < 9; t++)
            r.probe.push(new ft);
        const o = new ft
          , s = new Gt
          , a = new Gt;
        return {
            setup: function(o) {
                let s = 0
                  , a = 0
                  , l = 0;
                for (let t = 0; t < 9; t++)
                    r.probe[t].set(0, 0, 0);
                let c = 0
                  , u = 0
                  , h = 0
                  , d = 0
                  , p = 0
                  , f = 0
                  , m = 0
                  , g = 0;
                o.sort(kr);
                for (let t = 0, e = o.length; t < e; t++) {
                    const e = o[t]
                      , v = e.color
                      , y = e.intensity
                      , _ = e.distance
                      , x = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                    if (e.isAmbientLight)
                        s += v.r * y,
                        a += v.g * y,
                        l += v.b * y;
                    else if (e.isLightProbe)
                        for (let t = 0; t < 9; t++)
                            r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                    else if (e.isDirectionalLight) {
                        const t = n.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity),
                        e.castShadow) {
                            const t = e.shadow
                              , n = i.get(e);
                            n.shadowBias = t.bias,
                            n.shadowNormalBias = t.normalBias,
                            n.shadowRadius = t.radius,
                            n.shadowMapSize = t.mapSize,
                            r.directionalShadow[c] = n,
                            r.directionalShadowMap[c] = x,
                            r.directionalShadowMatrix[c] = e.shadow.matrix,
                            f++
                        }
                        r.directional[c] = t,
                        c++
                    } else if (e.isSpotLight) {
                        const t = n.get(e);
                        if (t.position.setFromMatrixPosition(e.matrixWorld),
                        t.color.copy(v).multiplyScalar(y),
                        t.distance = _,
                        t.coneCos = Math.cos(e.angle),
                        t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)),
                        t.decay = e.decay,
                        e.castShadow) {
                            const t = e.shadow
                              , n = i.get(e);
                            n.shadowBias = t.bias,
                            n.shadowNormalBias = t.normalBias,
                            n.shadowRadius = t.radius,
                            n.shadowMapSize = t.mapSize,
                            r.spotShadow[h] = n,
                            r.spotShadowMap[h] = x,
                            r.spotShadowMatrix[h] = e.shadow.matrix,
                            g++
                        }
                        r.spot[h] = t,
                        h++
                    } else if (e.isRectAreaLight) {
                        const t = n.get(e);
                        t.color.copy(v).multiplyScalar(y),
                        t.halfWidth.set(.5 * e.width, 0, 0),
                        t.halfHeight.set(0, .5 * e.height, 0),
                        r.rectArea[d] = t,
                        d++
                    } else if (e.isPointLight) {
                        const t = n.get(e);
                        if (t.color.copy(e.color).multiplyScalar(e.intensity),
                        t.distance = e.distance,
                        t.decay = e.decay,
                        e.castShadow) {
                            const t = e.shadow
                              , n = i.get(e);
                            n.shadowBias = t.bias,
                            n.shadowNormalBias = t.normalBias,
                            n.shadowRadius = t.radius,
                            n.shadowMapSize = t.mapSize,
                            n.shadowCameraNear = t.camera.near,
                            n.shadowCameraFar = t.camera.far,
                            r.pointShadow[u] = n,
                            r.pointShadowMap[u] = x,
                            r.pointShadowMatrix[u] = e.shadow.matrix,
                            m++
                        }
                        r.point[u] = t,
                        u++
                    } else if (e.isHemisphereLight) {
                        const t = n.get(e);
                        t.skyColor.copy(e.color).multiplyScalar(y),
                        t.groundColor.copy(e.groundColor).multiplyScalar(y),
                        r.hemi[p] = t,
                        p++
                    }
                }
                d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Qn.LTC_FLOAT_1,
                r.rectAreaLTC2 = Qn.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Qn.LTC_HALF_1,
                r.rectAreaLTC2 = Qn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                r.ambient[0] = s,
                r.ambient[1] = a,
                r.ambient[2] = l;
                const v = r.hash;
                v.directionalLength === c && v.pointLength === u && v.spotLength === h && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (r.directional.length = c,
                r.spot.length = h,
                r.rectArea.length = d,
                r.point.length = u,
                r.hemi.length = p,
                r.directionalShadow.length = f,
                r.directionalShadowMap.length = f,
                r.pointShadow.length = m,
                r.pointShadowMap.length = m,
                r.spotShadow.length = g,
                r.spotShadowMap.length = g,
                r.directionalShadowMatrix.length = f,
                r.pointShadowMatrix.length = m,
                r.spotShadowMatrix.length = g,
                v.directionalLength = c,
                v.pointLength = u,
                v.spotLength = h,
                v.rectAreaLength = d,
                v.hemiLength = p,
                v.numDirectionalShadows = f,
                v.numPointShadows = m,
                v.numSpotShadows = g,
                r.version = Br++)
            },
            setupView: function(t, e) {
                let n = 0
                  , i = 0
                  , l = 0
                  , c = 0
                  , u = 0;
                const h = e.matrixWorldInverse;
                for (let e = 0, d = t.length; e < d; e++) {
                    const d = t[e];
                    if (d.isDirectionalLight) {
                        const t = r.directional[n];
                        t.direction.setFromMatrixPosition(d.matrixWorld),
                        o.setFromMatrixPosition(d.target.matrixWorld),
                        t.direction.sub(o),
                        t.direction.transformDirection(h),
                        n++
                    } else if (d.isSpotLight) {
                        const t = r.spot[l];
                        t.position.setFromMatrixPosition(d.matrixWorld),
                        t.position.applyMatrix4(h),
                        t.direction.setFromMatrixPosition(d.matrixWorld),
                        o.setFromMatrixPosition(d.target.matrixWorld),
                        t.direction.sub(o),
                        t.direction.transformDirection(h),
                        l++
                    } else if (d.isRectAreaLight) {
                        const t = r.rectArea[c];
                        t.position.setFromMatrixPosition(d.matrixWorld),
                        t.position.applyMatrix4(h),
                        a.identity(),
                        s.copy(d.matrixWorld),
                        s.premultiply(h),
                        a.extractRotation(s),
                        t.halfWidth.set(.5 * d.width, 0, 0),
                        t.halfHeight.set(0, .5 * d.height, 0),
                        t.halfWidth.applyMatrix4(a),
                        t.halfHeight.applyMatrix4(a),
                        c++
                    } else if (d.isPointLight) {
                        const t = r.point[i];
                        t.position.setFromMatrixPosition(d.matrixWorld),
                        t.position.applyMatrix4(h),
                        i++
                    } else if (d.isHemisphereLight) {
                        const t = r.hemi[u];
                        t.direction.setFromMatrixPosition(d.matrixWorld),
                        t.direction.transformDirection(h),
                        t.direction.normalize(),
                        u++
                    }
                }
            },
            state: r
        }
    }
    function Ur(t, e) {
        const n = new zr(t,e)
          , i = []
          , r = [];
        return {
            init: function() {
                i.length = 0,
                r.length = 0
            },
            state: {
                lightsArray: i,
                shadowsArray: r,
                lights: n
            },
            setupLights: function() {
                n.setup(i)
            },
            setupLightsView: function(t) {
                n.setupView(i, t)
            },
            pushLight: function(t) {
                i.push(t)
            },
            pushShadow: function(t) {
                r.push(t)
            }
        }
    }
    function Hr(t, e) {
        let n = new WeakMap;
        return {
            get: function(i, r=0) {
                let o;
                return !1 === n.has(i) ? (o = new Ur(t,e),
                n.set(i, []),
                n.get(i).push(o)) : r >= n.get(i).length ? (o = new Ur(t,e),
                n.get(i).push(o)) : o = n.get(i)[r],
                o
            },
            dispose: function() {
                n = new WeakMap
            }
        }
    }
    function Gr(t) {
        ke.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = 3200,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.setValues(t)
    }
    function Vr(t) {
        ke.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new ft,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.skinning = !1,
        this.morphTargets = !1,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.fog = !1,
        this.setValues(t)
    }
    Gr.prototype = Object.create(ke.prototype),
    Gr.prototype.constructor = Gr,
    Gr.prototype.isMeshDepthMaterial = !0,
    Gr.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.depthPacking = t.depthPacking,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this
    }
    ,
    Vr.prototype = Object.create(ke.prototype),
    Vr.prototype.constructor = Vr,
    Vr.prototype.isMeshDistanceMaterial = !0,
    Vr.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.referencePosition.copy(t.referencePosition),
        this.nearDistance = t.nearDistance,
        this.farDistance = t.farDistance,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this
    }
    ;
    function jr(t, e, n) {
        let i = new qn;
        const r = new it
          , o = new it
          , s = new ut
          , a = []
          , l = []
          , c = {}
          , u = {
            0: 1,
            1: 0,
            2: 2
        }
          , h = new In({
            defines: {
                SAMPLE_RATE: 2 / 8,
                HALF_SAMPLE_RATE: 1 / 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new it
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
        })
          , d = h.clone();
        d.defines.HORIZONTAL_PASS = 1;
        const p = new hn;
        p.setAttribute("position", new Ge(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
        const f = new Cn(p,h)
          , m = this;
        function g(n, i) {
            const r = e.update(f);
            h.uniforms.shadow_pass.value = n.map.texture,
            h.uniforms.resolution.value = n.mapSize,
            h.uniforms.radius.value = n.radius,
            t.setRenderTarget(n.mapPass),
            t.clear(),
            t.renderBufferDirect(i, null, r, h, f, null),
            d.uniforms.shadow_pass.value = n.mapPass.texture,
            d.uniforms.resolution.value = n.mapSize,
            d.uniforms.radius.value = n.radius,
            t.setRenderTarget(n.map),
            t.clear(),
            t.renderBufferDirect(i, null, r, d, f, null)
        }
        function v(t, e, n) {
            const i = t << 0 | e << 1 | n << 2;
            let r = a[i];
            return void 0 === r && (r = new Gr({
                depthPacking: 3201,
                morphTargets: t,
                skinning: e
            }),
            a[i] = r),
            r
        }
        function y(t, e, n) {
            const i = t << 0 | e << 1 | n << 2;
            let r = l[i];
            return void 0 === r && (r = new Vr({
                morphTargets: t,
                skinning: e
            }),
            l[i] = r),
            r
        }
        function _(e, n, i, r, o, s, a) {
            let l = null
              , h = v
              , d = e.customDepthMaterial;
            if (!0 === r.isPointLight && (h = y,
            d = e.customDistanceMaterial),
            void 0 === d) {
                let t = !1;
                !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                let r = !1;
                !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
                l = h(t, r, !0 === e.isInstancedMesh)
            } else
                l = d;
            if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                const t = l.uuid
                  , e = i.uuid;
                let n = c[t];
                void 0 === n && (n = {},
                c[t] = n);
                let r = n[e];
                void 0 === r && (r = l.clone(),
                n[e] = r),
                l = r
            }
            return l.visible = i.visible,
            l.wireframe = i.wireframe,
            l.side = 3 === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side],
            l.clipShadows = i.clipShadows,
            l.clippingPlanes = i.clippingPlanes,
            l.clipIntersection = i.clipIntersection,
            l.wireframeLinewidth = i.wireframeLinewidth,
            l.linewidth = i.linewidth,
            !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld),
            l.nearDistance = o,
            l.farDistance = s),
            l
        }
        function x(n, r, o, s, a) {
            if (!1 === n.visible)
                return;
            if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                const i = e.update(n)
                  , r = n.material;
                if (Array.isArray(r)) {
                    const e = i.groups;
                    for (let l = 0, c = e.length; l < c; l++) {
                        const c = e[l]
                          , u = r[c.materialIndex];
                        if (u && u.visible) {
                            const e = _(n, i, u, s, o.near, o.far, a);
                            t.renderBufferDirect(o, null, i, e, n, c)
                        }
                    }
                } else if (r.visible) {
                    const e = _(n, i, r, s, o.near, o.far, a);
                    t.renderBufferDirect(o, null, i, e, n, null)
                }
            }
            const l = n.children;
            for (let t = 0, e = l.length; t < e; t++)
                x(l[t], r, o, s, a)
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = 1,
        this.render = function(e, a, l) {
            if (!1 === m.enabled)
                return;
            if (!1 === m.autoUpdate && !1 === m.needsUpdate)
                return;
            if (0 === e.length)
                return;
            const c = t.getRenderTarget()
              , u = t.getActiveCubeFace()
              , h = t.getActiveMipmapLevel()
              , d = t.state;
            d.setBlending(0),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
            for (let c = 0, u = e.length; c < u; c++) {
                const u = e[c]
                  , h = u.shadow;
                if (void 0 === h) {
                    console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                    continue
                }
                if (!1 === h.autoUpdate && !1 === h.needsUpdate)
                    continue;
                r.copy(h.mapSize);
                const p = h.getFrameExtents();
                if (r.multiply(p),
                o.copy(h.mapSize),
                (r.x > n || r.y > n) && (r.x > n && (o.x = Math.floor(n / p.x),
                r.x = o.x * p.x,
                h.mapSize.x = o.x),
                r.y > n && (o.y = Math.floor(n / p.y),
                r.y = o.y * p.y,
                h.mapSize.y = o.y)),
                null === h.map && !h.isPointLightShadow && 3 === this.type) {
                    const t = {
                        minFilter: D,
                        magFilter: D,
                        format: N
                    };
                    h.map = new ht(r.x,r.y,t),
                    h.map.texture.name = u.name + ".shadowMap",
                    h.mapPass = new ht(r.x,r.y,t),
                    h.camera.updateProjectionMatrix()
                }
                if (null === h.map) {
                    const t = {
                        minFilter: M,
                        magFilter: M,
                        format: N
                    };
                    h.map = new ht(r.x,r.y,t),
                    h.map.texture.name = u.name + ".shadowMap",
                    h.camera.updateProjectionMatrix()
                }
                t.setRenderTarget(h.map),
                t.clear();
                const f = h.getViewportCount();
                for (let t = 0; t < f; t++) {
                    const e = h.getViewport(t);
                    s.set(o.x * e.x, o.y * e.y, o.x * e.z, o.y * e.w),
                    d.viewport(s),
                    h.updateMatrices(u, t),
                    i = h.getFrustum(),
                    x(a, l, h.camera, u, this.type)
                }
                h.isPointLightShadow || 3 !== this.type || g(h, l),
                h.needsUpdate = !1
            }
            m.needsUpdate = !1,
            t.setRenderTarget(c, u, h)
        }
    }
    function Wr(t, e, n) {
        const i = n.isWebGL2;
        const r = new function() {
            let e = !1;
            const n = new ut;
            let i = null;
            const r = new ut(0,0,0,0);
            return {
                setMask: function(n) {
                    i === n || e || (t.colorMask(n, n, n, n),
                    i = n)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e, i, o, s, a) {
                    !0 === a && (e *= s,
                    i *= s,
                    o *= s),
                    n.set(e, i, o, s),
                    !1 === r.equals(n) && (t.clearColor(e, i, o, s),
                    r.copy(n))
                },
                reset: function() {
                    e = !1,
                    i = null,
                    r.set(-1, 0, 0, 0)
                }
            }
        }
          , o = new function() {
            let e = !1
              , n = null
              , i = null
              , r = null;
            return {
                setTest: function(t) {
                    t ? F(2929) : N(2929)
                },
                setMask: function(i) {
                    n === i || e || (t.depthMask(i),
                    n = i)
                },
                setFunc: function(e) {
                    if (i !== e) {
                        if (e)
                            switch (e) {
                            case 0:
                                t.depthFunc(512);
                                break;
                            case 1:
                                t.depthFunc(519);
                                break;
                            case 2:
                                t.depthFunc(513);
                                break;
                            case 3:
                                t.depthFunc(515);
                                break;
                            case 4:
                                t.depthFunc(514);
                                break;
                            case 5:
                                t.depthFunc(518);
                                break;
                            case 6:
                                t.depthFunc(516);
                                break;
                            case 7:
                                t.depthFunc(517);
                                break;
                            default:
                                t.depthFunc(515)
                            }
                        else
                            t.depthFunc(515);
                        i = e
                    }
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    r !== e && (t.clearDepth(e),
                    r = e)
                },
                reset: function() {
                    e = !1,
                    n = null,
                    i = null,
                    r = null
                }
            }
        }
          , s = new function() {
            let e = !1
              , n = null
              , i = null
              , r = null
              , o = null
              , s = null
              , a = null
              , l = null
              , c = null;
            return {
                setTest: function(t) {
                    e || (t ? F(2960) : N(2960))
                },
                setMask: function(i) {
                    n === i || e || (t.stencilMask(i),
                    n = i)
                },
                setFunc: function(e, n, s) {
                    i === e && r === n && o === s || (t.stencilFunc(e, n, s),
                    i = e,
                    r = n,
                    o = s)
                },
                setOp: function(e, n, i) {
                    s === e && a === n && l === i || (t.stencilOp(e, n, i),
                    s = e,
                    a = n,
                    l = i)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    c !== e && (t.clearStencil(e),
                    c = e)
                },
                reset: function() {
                    e = !1,
                    n = null,
                    i = null,
                    r = null,
                    o = null,
                    s = null,
                    a = null,
                    l = null,
                    c = null
                }
            }
        }
        ;
        let a = {}
          , l = null
          , c = null
          , u = null
          , h = null
          , d = null
          , p = null
          , f = null
          , g = null
          , v = null
          , y = !1
          , _ = null
          , x = null
          , b = null
          , w = null
          , M = null;
        const S = t.getParameter(35661);
        let E = !1
          , D = 0;
        const T = t.getParameter(7938);
        -1 !== T.indexOf("WebGL") ? (D = parseFloat(/^WebGL (\d)/.exec(T)[1]),
        E = D >= 1) : -1 !== T.indexOf("OpenGL ES") && (D = parseFloat(/^OpenGL ES (\d)/.exec(T)[1]),
        E = D >= 2);
        let A = null
          , C = {};
        const L = new ut
          , P = new ut;
        function R(e, n, i) {
            const r = new Uint8Array(4)
              , o = t.createTexture();
            t.bindTexture(e, o),
            t.texParameteri(e, 10241, 9728),
            t.texParameteri(e, 10240, 9728);
            for (let e = 0; e < i; e++)
                t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return o
        }
        const O = {};
        function F(e) {
            !0 !== a[e] && (t.enable(e),
            a[e] = !0)
        }
        function N(e) {
            !1 !== a[e] && (t.disable(e),
            a[e] = !1)
        }
        O[3553] = R(3553, 3553, 1),
        O[34067] = R(34067, 34069, 6),
        r.setClear(0, 0, 0, 1),
        o.setClear(1),
        s.setClear(0),
        F(2929),
        o.setFunc(3),
        z(!1),
        U(1),
        F(2884),
        k(0);
        const I = {
            [m]: 32774,
            101: 32778,
            102: 32779
        };
        if (i)
            I[103] = 32775,
            I[104] = 32776;
        else {
            const t = e.get("EXT_blend_minmax");
            null !== t && (I[103] = t.MIN_EXT,
            I[104] = t.MAX_EXT)
        }
        const B = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773
        };
        function k(e, n, i, r, o, s, a, l) {
            if (0 !== e) {
                if (c || (F(3042),
                c = !0),
                5 === e)
                    o = o || n,
                    s = s || i,
                    a = a || r,
                    n === h && o === f || (t.blendEquationSeparate(I[n], I[o]),
                    h = n,
                    f = o),
                    i === d && r === p && s === g && a === v || (t.blendFuncSeparate(B[i], B[r], B[s], B[a]),
                    d = i,
                    p = r,
                    g = s,
                    v = a),
                    u = e,
                    y = null;
                else if (e !== u || l !== y) {
                    if (h === m && f === m || (t.blendEquation(32774),
                    h = m,
                    f = m),
                    l)
                        switch (e) {
                        case 1:
                            t.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(1, 1);
                            break;
                        case 3:
                            t.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            t.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                    else
                        switch (e) {
                        case 1:
                            t.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(770, 1);
                            break;
                        case 3:
                            t.blendFunc(0, 769);
                            break;
                        case 4:
                            t.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                    d = null,
                    p = null,
                    g = null,
                    v = null,
                    u = e,
                    y = l
                }
            } else
                c && (N(3042),
                c = !1)
        }
        function z(e) {
            _ !== e && (e ? t.frontFace(2304) : t.frontFace(2305),
            _ = e)
        }
        function U(e) {
            0 !== e ? (F(2884),
            e !== x && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : N(2884),
            x = e
        }
        function H(e, n, i) {
            e ? (F(32823),
            w === n && M === i || (t.polygonOffset(n, i),
            w = n,
            M = i)) : N(32823)
        }
        function G(e) {
            void 0 === e && (e = 33984 + S - 1),
            A !== e && (t.activeTexture(e),
            A = e)
        }
        return {
            buffers: {
                color: r,
                depth: o,
                stencil: s
            },
            enable: F,
            disable: N,
            useProgram: function(e) {
                return l !== e && (t.useProgram(e),
                l = e,
                !0)
            },
            setBlending: k,
            setMaterial: function(t, e) {
                2 === t.side ? N(2884) : F(2884);
                let n = 1 === t.side;
                e && (n = !n),
                z(n),
                1 === t.blending && !1 === t.transparent ? k(0) : k(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha),
                o.setFunc(t.depthFunc),
                o.setTest(t.depthTest),
                o.setMask(t.depthWrite),
                r.setMask(t.colorWrite);
                const i = t.stencilWrite;
                s.setTest(i),
                i && (s.setMask(t.stencilWriteMask),
                s.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                s.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                H(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            },
            setFlipSided: z,
            setCullFace: U,
            setLineWidth: function(e) {
                e !== b && (E && t.lineWidth(e),
                b = e)
            },
            setPolygonOffset: H,
            setScissorTest: function(t) {
                t ? F(3089) : N(3089)
            },
            activeTexture: G,
            bindTexture: function(e, n) {
                null === A && G();
                let i = C[A];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                },
                C[A] = i),
                i.type === e && i.texture === n || (t.bindTexture(e, n || O[e]),
                i.type = e,
                i.texture = n)
            },
            unbindTexture: function() {
                const e = C[A];
                void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null),
                e.type = void 0,
                e.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage2D: function() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            texImage3D: function() {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            },
            scissor: function(e) {
                !1 === L.equals(e) && (t.scissor(e.x, e.y, e.z, e.w),
                L.copy(e))
            },
            viewport: function(e) {
                !1 === P.equals(e) && (t.viewport(e.x, e.y, e.z, e.w),
                P.copy(e))
            },
            reset: function() {
                a = {},
                A = null,
                C = {},
                l = null,
                c = null,
                u = null,
                h = null,
                d = null,
                p = null,
                f = null,
                g = null,
                v = null,
                y = !1,
                _ = null,
                x = null,
                b = null,
                w = null,
                M = null,
                r.reset(),
                o.reset(),
                s.reset()
            }
        }
    }
    function qr(t, e, n, i, r, o, s) {
        const a = r.isWebGL2
          , l = r.maxTextures
          , c = r.maxCubemapSize
          , u = r.maxTextureSize
          , h = r.maxSamples
          , d = new WeakMap;
        let p, f = !1;
        try {
            f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
        } catch (t) {}
        function m(t, e) {
            return f ? new OffscreenCanvas(t,e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }
        function g(t, e, n, i) {
            let r = 1;
            if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
            r < 1 || !0 === e) {
                if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                    const i = e ? nt.floorPowerOfTwo : Math.floor
                      , o = i(r * t.width)
                      , s = i(r * t.height);
                    void 0 === p && (p = m(o, s));
                    const a = n ? m(o, s) : p;
                    a.width = o,
                    a.height = s;
                    return a.getContext("2d").drawImage(t, 0, 0, o, s),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."),
                    a
                }
                return "data"in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."),
                t
            }
            return t
        }
        function v(t) {
            return nt.isPowerOfTwo(t.width) && nt.isPowerOfTwo(t.height)
        }
        function y(t, e) {
            return t.generateMipmaps && e && t.minFilter !== M && t.minFilter !== D
        }
        function _(e, n, r, o) {
            t.generateMipmap(e);
            i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
        }
        function A(n, i, r) {
            if (!1 === a)
                return i;
            if (null !== n) {
                if (void 0 !== t[n])
                    return t[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            let o = i;
            return 6403 === i && (5126 === r && (o = 33326),
            5131 === r && (o = 33325),
            5121 === r && (o = 33321)),
            6407 === i && (5126 === r && (o = 34837),
            5131 === r && (o = 34843),
            5121 === r && (o = 32849)),
            6408 === i && (5126 === r && (o = 34836),
            5131 === r && (o = 34842),
            5121 === r && (o = 32856)),
            33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || e.get("EXT_color_buffer_float"),
            o
        }
        function k(t) {
            return t === M || t === S || t === E ? 9728 : 9729
        }
        function z(e) {
            const n = e.target;
            n.removeEventListener("dispose", z),
            function(e) {
                const n = i.get(e);
                if (void 0 === n.__webglInit)
                    return;
                t.deleteTexture(n.__webglTexture),
                i.remove(e)
            }(n),
            n.isVideoTexture && d.delete(n),
            s.memory.textures--
        }
        function U(e) {
            const n = e.target;
            n.removeEventListener("dispose", U),
            function(e) {
                const n = i.get(e)
                  , r = i.get(e.texture);
                if (!e)
                    return;
                void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                e.depthTexture && e.depthTexture.dispose();
                if (e.isWebGLCubeRenderTarget)
                    for (let e = 0; e < 6; e++)
                        t.deleteFramebuffer(n.__webglFramebuffer[e]),
                        n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[e]);
                else
                    t.deleteFramebuffer(n.__webglFramebuffer),
                    n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer),
                    n.__webglMultisampledFramebuffer && t.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                    n.__webglColorRenderbuffer && t.deleteRenderbuffer(n.__webglColorRenderbuffer),
                    n.__webglDepthRenderbuffer && t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
                i.remove(e.texture),
                i.remove(e)
            }(n),
            s.memory.textures--
        }
        let H = 0;
        function G(t, e) {
            const r = i.get(t);
            if (t.isVideoTexture && function(t) {
                const e = s.render.frame;
                d.get(t) !== e && (d.set(t, e),
                t.update())
            }(t),
            t.version > 0 && r.__version !== t.version) {
                const n = t.image;
                if (void 0 === n)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== n.complete)
                        return void Y(r, t, e);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(33984 + e),
            n.bindTexture(3553, r.__webglTexture)
        }
        function V(e, r) {
            const s = i.get(e);
            e.version > 0 && s.__version !== e.version ? function(e, i, r) {
                if (6 !== i.image.length)
                    return;
                X(e, i),
                n.activeTexture(33984 + r),
                n.bindTexture(34067, e.__webglTexture),
                t.pixelStorei(37440, i.flipY);
                const s = i && (i.isCompressedTexture || i.image[0].isCompressedTexture)
                  , l = i.image[0] && i.image[0].isDataTexture
                  , u = [];
                for (let t = 0; t < 6; t++)
                    u[t] = s || l ? l ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, c);
                const h = u[0]
                  , d = v(h) || a
                  , p = o.convert(i.format)
                  , f = o.convert(i.type)
                  , m = A(i.internalFormat, p, f);
                let x;
                if (q(34067, i, d),
                s) {
                    for (let t = 0; t < 6; t++) {
                        x = u[t].mipmaps;
                        for (let e = 0; e < x.length; e++) {
                            const r = x[e];
                            i.format !== N && i.format !== F ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data)
                        }
                    }
                    e.__maxMipLevel = x.length - 1
                } else {
                    x = i.mipmaps;
                    for (let t = 0; t < 6; t++)
                        if (l) {
                            n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, p, f, u[t].data);
                            for (let e = 0; e < x.length; e++) {
                                const i = x[e].image[t].image;
                                n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, p, f, i.data)
                            }
                        } else {
                            n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                            for (let e = 0; e < x.length; e++) {
                                const i = x[e];
                                n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t])
                            }
                        }
                    e.__maxMipLevel = x.length
                }
                y(i, d) && _(34067, i, h.width, h.height);
                e.__version = i.version,
                i.onUpdate && i.onUpdate(i)
            }(s, e, r) : (n.activeTexture(33984 + r),
            n.bindTexture(34067, s.__webglTexture))
        }
        const j = {
            [x]: 10497,
            [b]: 33071,
            [w]: 33648
        }
          , W = {
            [M]: 9728,
            [S]: 9984,
            [E]: 9986,
            [D]: 9729,
            1007: 9985,
            [T]: 9987
        };
        function q(n, o, s) {
            s ? (t.texParameteri(n, 10242, j[o.wrapS]),
            t.texParameteri(n, 10243, j[o.wrapT]),
            32879 !== n && 35866 !== n || t.texParameteri(n, 32882, j[o.wrapR]),
            t.texParameteri(n, 10240, W[o.magFilter]),
            t.texParameteri(n, 10241, W[o.minFilter])) : (t.texParameteri(n, 10242, 33071),
            t.texParameteri(n, 10243, 33071),
            32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071),
            o.wrapS === b && o.wrapT === b || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            t.texParameteri(n, 10240, k(o.magFilter)),
            t.texParameteri(n, 10241, k(o.minFilter)),
            o.minFilter !== M && o.minFilter !== D && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));
            const l = e.get("EXT_texture_filter_anisotropic");
            if (l) {
                if (o.type === P && null === e.get("OES_texture_float_linear"))
                    return;
                if (o.type === R && null === (a || e.get("OES_texture_half_float_linear")))
                    return;
                (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())),
                i.get(o).__currentAnisotropy = o.anisotropy)
            }
        }
        function X(e, n) {
            void 0 === e.__webglInit && (e.__webglInit = !0,
            n.addEventListener("dispose", z),
            e.__webglTexture = t.createTexture(),
            s.memory.textures++)
        }
        function Y(e, i, r) {
            let s = 3553;
            i.isDataTexture2DArray && (s = 35866),
            i.isDataTexture3D && (s = 32879),
            X(e, i),
            n.activeTexture(33984 + r),
            n.bindTexture(s, e.__webglTexture),
            t.pixelStorei(37440, i.flipY),
            t.pixelStorei(37441, i.premultiplyAlpha),
            t.pixelStorei(3317, i.unpackAlignment);
            const l = function(t) {
                return !a && (t.wrapS !== b || t.wrapT !== b || t.minFilter !== M && t.minFilter !== D)
            }(i) && !1 === v(i.image)
              , c = g(i.image, l, !1, u)
              , h = v(c) || a
              , d = o.convert(i.format);
            let p, f = o.convert(i.type), m = A(i.internalFormat, d, f);
            q(s, i, h);
            const x = i.mipmaps;
            if (i.isDepthTexture)
                m = 6402,
                a ? m = i.type === P ? 36012 : i.type === L ? 33190 : i.type === O ? 35056 : 33189 : i.type === P && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                i.format === I && 6402 === m && i.type !== C && i.type !== L && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                i.type = C,
                f = o.convert(i.type)),
                i.format === B && 6402 === m && (m = 34041,
                i.type !== O && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                i.type = O,
                f = o.convert(i.type))),
                n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
            else if (i.isDataTexture)
                if (x.length > 0 && h) {
                    for (let t = 0, e = x.length; t < e; t++)
                        p = x[t],
                        n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                    i.generateMipmaps = !1,
                    e.__maxMipLevel = x.length - 1
                } else
                    n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data),
                    e.__maxMipLevel = 0;
            else if (i.isCompressedTexture) {
                for (let t = 0, e = x.length; t < e; t++)
                    p = x[t],
                    i.format !== N && i.format !== F ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                e.__maxMipLevel = x.length - 1
            } else if (i.isDataTexture2DArray)
                n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                e.__maxMipLevel = 0;
            else if (i.isDataTexture3D)
                n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data),
                e.__maxMipLevel = 0;
            else if (x.length > 0 && h) {
                for (let t = 0, e = x.length; t < e; t++)
                    p = x[t],
                    n.texImage2D(3553, t, m, d, f, p);
                i.generateMipmaps = !1,
                e.__maxMipLevel = x.length - 1
            } else
                n.texImage2D(3553, 0, m, d, f, c),
                e.__maxMipLevel = 0;
            y(i, h) && _(s, i, c.width, c.height),
            e.__version = i.version,
            i.onUpdate && i.onUpdate(i)
        }
        function Z(e, r, s, a) {
            const l = o.convert(r.texture.format)
              , c = o.convert(r.texture.type)
              , u = A(r.texture.internalFormat, l, c);
            n.texImage2D(a, 0, u, r.width, r.height, 0, l, c, null),
            t.bindFramebuffer(36160, e),
            t.framebufferTexture2D(36160, s, a, i.get(r.texture).__webglTexture, 0),
            t.bindFramebuffer(36160, null)
        }
        function J(e, n, i) {
            if (t.bindRenderbuffer(36161, e),
            n.depthBuffer && !n.stencilBuffer) {
                let r = 33189;
                if (i) {
                    const e = n.depthTexture;
                    e && e.isDepthTexture && (e.type === P ? r = 36012 : e.type === L && (r = 33190));
                    const i = K(n);
                    t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                } else
                    t.renderbufferStorage(36161, r, n.width, n.height);
                t.framebufferRenderbuffer(36160, 36096, 36161, e)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (i) {
                    const e = K(n);
                    t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                } else
                    t.renderbufferStorage(36161, 34041, n.width, n.height);
                t.framebufferRenderbuffer(36160, 33306, 36161, e)
            } else {
                const e = o.convert(n.texture.format)
                  , r = o.convert(n.texture.type)
                  , s = A(n.texture.internalFormat, e, r);
                if (i) {
                    const e = K(n);
                    t.renderbufferStorageMultisample(36161, e, s, n.width, n.height)
                } else
                    t.renderbufferStorage(36161, s, n.width, n.height)
            }
            t.bindRenderbuffer(36161, null)
        }
        function Q(e) {
            const n = i.get(e)
              , r = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
                if (r)
                    throw new Error("target.depthTexture not supported in Cube render targets");
                !function(e, n) {
                    if (n && n.isWebGLCubeRenderTarget)
                        throw new Error("Depth Texture with cube render targets is not supported");
                    if (t.bindFramebuffer(36160, e),
                    !n.depthTexture || !n.depthTexture.isDepthTexture)
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width,
                    n.depthTexture.image.height = n.height,
                    n.depthTexture.needsUpdate = !0),
                    G(n.depthTexture, 0);
                    const r = i.get(n.depthTexture).__webglTexture;
                    if (n.depthTexture.format === I)
                        t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                    else {
                        if (n.depthTexture.format !== B)
                            throw new Error("Unknown depthTexture format");
                        t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                    }
                }(n.__webglFramebuffer, e)
            } else if (r) {
                n.__webglDepthbuffer = [];
                for (let i = 0; i < 6; i++)
                    t.bindFramebuffer(36160, n.__webglFramebuffer[i]),
                    n.__webglDepthbuffer[i] = t.createRenderbuffer(),
                    J(n.__webglDepthbuffer[i], e, !1)
            } else
                t.bindFramebuffer(36160, n.__webglFramebuffer),
                n.__webglDepthbuffer = t.createRenderbuffer(),
                J(n.__webglDepthbuffer, e, !1);
            t.bindFramebuffer(36160, null)
        }
        function K(t) {
            return a && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0
        }
        let $ = !1
          , tt = !1;
        this.allocateTextureUnit = function() {
            const t = H;
            return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l),
            H += 1,
            t
        }
        ,
        this.resetTextureUnits = function() {
            H = 0
        }
        ,
        this.setTexture2D = G,
        this.setTexture2DArray = function(t, e) {
            const r = i.get(t);
            t.version > 0 && r.__version !== t.version ? Y(r, t, e) : (n.activeTexture(33984 + e),
            n.bindTexture(35866, r.__webglTexture))
        }
        ,
        this.setTexture3D = function(t, e) {
            const r = i.get(t);
            t.version > 0 && r.__version !== t.version ? Y(r, t, e) : (n.activeTexture(33984 + e),
            n.bindTexture(32879, r.__webglTexture))
        }
        ,
        this.setTextureCube = V,
        this.setupRenderTarget = function(e) {
            const r = i.get(e)
              , l = i.get(e.texture);
            e.addEventListener("dispose", U),
            l.__webglTexture = t.createTexture(),
            s.memory.textures++;
            const c = !0 === e.isWebGLCubeRenderTarget
              , u = !0 === e.isWebGLMultisampleRenderTarget
              , h = v(e) || a;
            if (!a || e.texture.format !== F || e.texture.type !== P && e.texture.type !== R || (e.texture.format = N,
            console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
            c) {
                r.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                    r.__webglFramebuffer[e] = t.createFramebuffer()
            } else if (r.__webglFramebuffer = t.createFramebuffer(),
            u)
                if (a) {
                    r.__webglMultisampledFramebuffer = t.createFramebuffer(),
                    r.__webglColorRenderbuffer = t.createRenderbuffer(),
                    t.bindRenderbuffer(36161, r.__webglColorRenderbuffer);
                    const n = o.convert(e.texture.format)
                      , i = o.convert(e.texture.type)
                      , s = A(e.texture.internalFormat, n, i)
                      , a = K(e);
                    t.renderbufferStorageMultisample(36161, a, s, e.width, e.height),
                    t.bindFramebuffer(36160, r.__webglMultisampledFramebuffer),
                    t.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer),
                    t.bindRenderbuffer(36161, null),
                    e.depthBuffer && (r.__webglDepthRenderbuffer = t.createRenderbuffer(),
                    J(r.__webglDepthRenderbuffer, e, !0)),
                    t.bindFramebuffer(36160, null)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (c) {
                n.bindTexture(34067, l.__webglTexture),
                q(34067, e.texture, h);
                for (let t = 0; t < 6; t++)
                    Z(r.__webglFramebuffer[t], e, 36064, 34069 + t);
                y(e.texture, h) && _(34067, e.texture, e.width, e.height),
                n.bindTexture(34067, null)
            } else
                n.bindTexture(3553, l.__webglTexture),
                q(3553, e.texture, h),
                Z(r.__webglFramebuffer, e, 36064, 3553),
                y(e.texture, h) && _(3553, e.texture, e.width, e.height),
                n.bindTexture(3553, null);
            e.depthBuffer && Q(e)
        }
        ,
        this.updateRenderTargetMipmap = function(t) {
            const e = t.texture;
            if (y(e, v(t) || a)) {
                const r = t.isWebGLCubeRenderTarget ? 34067 : 3553
                  , o = i.get(e).__webglTexture;
                n.bindTexture(r, o),
                _(r, e, t.width, t.height),
                n.bindTexture(r, null)
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(e) {
            if (e.isWebGLMultisampleRenderTarget)
                if (a) {
                    const n = i.get(e);
                    t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer),
                    t.bindFramebuffer(36009, n.__webglFramebuffer);
                    const r = e.width
                      , o = e.height;
                    let s = 16384;
                    e.depthBuffer && (s |= 256),
                    e.stencilBuffer && (s |= 1024),
                    t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, 9728),
                    t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }
        ,
        this.safeSetTexture2D = function(t, e) {
            t && t.isWebGLRenderTarget && (!1 === $ && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
            $ = !0),
            t = t.texture),
            G(t, e)
        }
        ,
        this.safeSetTextureCube = function(t, e) {
            t && t.isWebGLCubeRenderTarget && (!1 === tt && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
            tt = !0),
            t = t.texture),
            V(t, e)
        }
    }
    function Xr(t, e, n) {
        const i = n.isWebGL2;
        return {
            convert: function(t) {
                let n;
                if (t === A)
                    return 5121;
                if (1017 === t)
                    return 32819;
                if (1018 === t)
                    return 32820;
                if (1019 === t)
                    return 33635;
                if (1010 === t)
                    return 5120;
                if (1011 === t)
                    return 5122;
                if (t === C)
                    return 5123;
                if (1013 === t)
                    return 5124;
                if (t === L)
                    return 5125;
                if (t === P)
                    return 5126;
                if (t === R)
                    return i ? 5131 : (n = e.get("OES_texture_half_float"),
                    null !== n ? n.HALF_FLOAT_OES : null);
                if (1021 === t)
                    return 6406;
                if (t === F)
                    return 6407;
                if (t === N)
                    return 6408;
                if (1024 === t)
                    return 6409;
                if (1025 === t)
                    return 6410;
                if (t === I)
                    return 6402;
                if (t === B)
                    return 34041;
                if (1028 === t)
                    return 6403;
                if (1029 === t)
                    return 36244;
                if (1030 === t)
                    return 33319;
                if (1031 === t)
                    return 33320;
                if (1032 === t)
                    return 36248;
                if (1033 === t)
                    return 36249;
                if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                    if (n = e.get("WEBGL_compressed_texture_s3tc"),
                    null === n)
                        return null;
                    if (33776 === t)
                        return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === t)
                        return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === t)
                        return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === t)
                        return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                    if (n = e.get("WEBGL_compressed_texture_pvrtc"),
                    null === n)
                        return null;
                    if (35840 === t)
                        return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === t)
                        return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === t)
                        return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === t)
                        return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === t)
                    return n = e.get("WEBGL_compressed_texture_etc1"),
                    null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"),
                null !== n)) {
                    if (37492 === t)
                        return n.COMPRESSED_RGB8_ETC2;
                    if (37496 === t)
                        return n.COMPRESSED_RGBA8_ETC2_EAC
                }
                return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"),
                null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"),
                null !== n ? t : null) : t === O ? i ? 34042 : (n = e.get("WEBGL_depth_texture"),
                null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
        }
    }
    function Yr(t=[]) {
        kn.call(this),
        this.cameras = t
    }
    function Zr() {
        pe.call(this),
        this.type = "Group"
    }
    function Jr() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    function Qr(t, e) {
        const n = this;
        let i = null
          , r = 1
          , o = null
          , s = "local-floor"
          , a = null;
        const l = []
          , c = new Map
          , u = new kn;
        u.layers.enable(1),
        u.viewport = new ut;
        const h = new kn;
        h.layers.enable(2),
        h.viewport = new ut;
        const d = [u, h]
          , p = new Yr;
        p.layers.enable(1),
        p.layers.enable(2);
        let f = null
          , m = null;
        function g(t) {
            const e = c.get(t.inputSource);
            e && e.dispatchEvent({
                type: t.type,
                data: t.inputSource
            })
        }
        function v() {
            c.forEach((function(t, e) {
                t.disconnect(e)
            }
            )),
            c.clear(),
            t.setFramebuffer(null),
            t.setRenderTarget(t.getRenderTarget()),
            S.stop(),
            n.isPresenting = !1,
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        function y(t) {
            o = t,
            S.setContext(i),
            S.start(),
            n.isPresenting = !0,
            n.dispatchEvent({
                type: "sessionstart"
            })
        }
        function _(t) {
            const e = i.inputSources;
            for (let t = 0; t < l.length; t++)
                c.set(e[t], l[t]);
            for (let e = 0; e < t.removed.length; e++) {
                const n = t.removed[e]
                  , i = c.get(n);
                i && (i.dispatchEvent({
                    type: "disconnected",
                    data: n
                }),
                c.delete(n))
            }
            for (let e = 0; e < t.added.length; e++) {
                const n = t.added[e]
                  , i = c.get(n);
                i && i.dispatchEvent({
                    type: "connected",
                    data: n
                })
            }
        }
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(t) {
            let e = l[t];
            return void 0 === e && (e = new Jr,
            l[t] = e),
            e.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(t) {
            let e = l[t];
            return void 0 === e && (e = new Jr,
            l[t] = e),
            e.getGripSpace()
        }
        ,
        this.getHand = function(t) {
            let e = l[t];
            return void 0 === e && (e = new Jr,
            l[t] = e),
            e.getHandSpace()
        }
        ,
        this.setFramebufferScaleFactor = function(t) {
            r = t,
            !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(t) {
            s = t,
            !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return o
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = function(t) {
            if (i = t,
            null !== i) {
                i.addEventListener("select", g),
                i.addEventListener("selectstart", g),
                i.addEventListener("selectend", g),
                i.addEventListener("squeeze", g),
                i.addEventListener("squeezestart", g),
                i.addEventListener("squeezeend", g),
                i.addEventListener("end", v);
                const t = e.getContextAttributes();
                !0 !== t.xrCompatible && e.makeXRCompatible();
                const n = {
                    antialias: t.antialias,
                    alpha: t.alpha,
                    depth: t.depth,
                    stencil: t.stencil,
                    framebufferScaleFactor: r
                }
                  , o = new XRWebGLLayer(i,e,n);
                i.updateRenderState({
                    baseLayer: o
                }),
                i.requestReferenceSpace(s).then(y),
                i.addEventListener("inputsourceschange", _)
            }
        }
        ;
        const x = new ft
          , b = new ft;
        function w(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
            t.matrixWorldInverse.copy(t.matrixWorld).invert()
        }
        this.getCamera = function(t) {
            p.near = h.near = u.near = t.near,
            p.far = h.far = u.far = t.far,
            f === p.near && m === p.far || (i.updateRenderState({
                depthNear: p.near,
                depthFar: p.far
            }),
            f = p.near,
            m = p.far);
            const e = t.parent
              , n = p.cameras;
            w(p, e);
            for (let t = 0; t < n.length; t++)
                w(n[t], e);
            t.matrixWorld.copy(p.matrixWorld);
            const r = t.children;
            for (let t = 0, e = r.length; t < e; t++)
                r[t].updateMatrixWorld(!0);
            return 2 === n.length ? function(t, e, n) {
                x.setFromMatrixPosition(e.matrixWorld),
                b.setFromMatrixPosition(n.matrixWorld);
                const i = x.distanceTo(b)
                  , r = e.projectionMatrix.elements
                  , o = n.projectionMatrix.elements
                  , s = r[14] / (r[10] - 1)
                  , a = r[14] / (r[10] + 1)
                  , l = (r[9] + 1) / r[5]
                  , c = (r[9] - 1) / r[5]
                  , u = (r[8] - 1) / r[0]
                  , h = (o[8] + 1) / o[0]
                  , d = s * u
                  , p = s * h
                  , f = i / (-u + h)
                  , m = f * -u;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                t.translateX(m),
                t.translateZ(f),
                t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
                const g = s + f
                  , v = a + f
                  , y = d - m
                  , _ = p + (i - m)
                  , w = l * a / v * g
                  , M = c * a / v * g;
                t.projectionMatrix.makePerspective(y, _, w, M, g, v)
            }(p, u, h) : p.projectionMatrix.copy(u.projectionMatrix),
            p
        }
        ;
        let M = null;
        const S = new Xn;
        S.setAnimationLoop((function(e, n) {
            if (a = n.getViewerPose(o),
            null !== a) {
                const e = a.views
                  , n = i.renderState.baseLayer;
                t.setFramebuffer(n.framebuffer);
                let r = !1;
                e.length !== p.cameras.length && (p.cameras.length = 0,
                r = !0);
                for (let t = 0; t < e.length; t++) {
                    const i = e[t]
                      , o = n.getViewport(i)
                      , s = d[t];
                    s.matrix.fromArray(i.transform.matrix),
                    s.projectionMatrix.fromArray(i.projectionMatrix),
                    s.viewport.set(o.x, o.y, o.width, o.height),
                    0 === t && p.matrix.copy(s.matrix),
                    !0 === r && p.cameras.push(s)
                }
            }
            const r = i.inputSources;
            for (let t = 0; t < l.length; t++) {
                const e = l[t]
                  , i = r[t];
                e.update(i, n, o)
            }
            M && M(e, n)
        }
        )),
        this.setAnimationLoop = function(t) {
            M = t
        }
        ,
        this.dispose = function() {}
    }
    function Kr(t) {
        function e(e, n) {
            e.opacity.value = n.opacity,
            n.color && e.diffuse.value.copy(n.color),
            n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
            n.map && (e.map.value = n.map),
            n.alphaMap && (e.alphaMap.value = n.alphaMap),
            n.specularMap && (e.specularMap.value = n.specularMap);
            const i = t.get(n).envMap;
            if (i) {
                e.envMap.value = i,
                e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1,
                e.reflectivity.value = n.reflectivity,
                e.refractionRatio.value = n.refractionRatio;
                const r = t.get(i).__maxMipLevel;
                void 0 !== r && (e.maxMipLevel.value = r)
            }
            let r, o;
            n.lightMap && (e.lightMap.value = n.lightMap,
            e.lightMapIntensity.value = n.lightMapIntensity),
            n.aoMap && (e.aoMap.value = n.aoMap,
            e.aoMapIntensity.value = n.aoMapIntensity),
            n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
            void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture),
            !0 === r.matrixAutoUpdate && r.updateMatrix(),
            e.uvTransform.value.copy(r.matrix)),
            n.aoMap ? o = n.aoMap : n.lightMap && (o = n.lightMap),
            void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture),
            !0 === o.matrixAutoUpdate && o.updateMatrix(),
            e.uv2Transform.value.copy(o.matrix))
        }
        function n(e, n) {
            e.roughness.value = n.roughness,
            e.metalness.value = n.metalness,
            n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
            n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
            n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
            n.bumpMap && (e.bumpMap.value = n.bumpMap,
            e.bumpScale.value = n.bumpScale,
            1 === n.side && (e.bumpScale.value *= -1)),
            n.normalMap && (e.normalMap.value = n.normalMap,
            e.normalScale.value.copy(n.normalScale),
            1 === n.side && e.normalScale.value.negate()),
            n.displacementMap && (e.displacementMap.value = n.displacementMap,
            e.displacementScale.value = n.displacementScale,
            e.displacementBias.value = n.displacementBias);
            t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
        }
        return {
            refreshFogUniforms: function(t, e) {
                t.fogColor.value.copy(e.color),
                e.isFog ? (t.fogNear.value = e.near,
                t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            },
            refreshMaterialUniforms: function(t, i, r, o) {
                i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i),
                function(t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                }(t, i)) : i.isMeshToonMaterial ? (e(t, i),
                function(t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshPhongMaterial ? (e(t, i),
                function(t, e) {
                    t.specular.value.copy(e.specular),
                    t.shininess.value = Math.max(e.shininess, 1e-4),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshStandardMaterial ? (e(t, i),
                i.isMeshPhysicalMaterial ? function(t, e) {
                    n(t, e),
                    t.reflectivity.value = e.reflectivity,
                    t.clearcoat.value = e.clearcoat,
                    t.clearcoatRoughness.value = e.clearcoatRoughness,
                    e.sheen && t.sheen.value.copy(e.sheen);
                    e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                    e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                    e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                    t.clearcoatNormalMap.value = e.clearcoatNormalMap,
                    1 === e.side && t.clearcoatNormalScale.value.negate());
                    t.transmission.value = e.transmission,
                    e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                }(t, i) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i),
                function(t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshDepthMaterial ? (e(t, i),
                function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i),
                function(t, e) {
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias);
                    t.referencePosition.value.copy(e.referencePosition),
                    t.nearDistance.value = e.nearDistance,
                    t.farDistance.value = e.farDistance
                }(t, i)) : i.isMeshNormalMaterial ? (e(t, i),
                function(t, e) {
                    e.bumpMap && (t.bumpMap.value = e.bumpMap,
                    t.bumpScale.value = e.bumpScale,
                    1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap && (t.normalMap.value = e.normalMap,
                    t.normalScale.value.copy(e.normalScale),
                    1 === e.side && t.normalScale.value.negate());
                    e.displacementMap && (t.displacementMap.value = e.displacementMap,
                    t.displacementScale.value = e.displacementScale,
                    t.displacementBias.value = e.displacementBias)
                }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                    t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity
                }(t, i),
                i.isLineDashedMaterial && function(t, e) {
                    t.dashSize.value = e.dashSize,
                    t.totalSize.value = e.dashSize + e.gapSize,
                    t.scale.value = e.scale
                }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                    t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity,
                    t.size.value = e.size * n,
                    t.scale.value = .5 * i,
                    e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let r;
                    e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                    void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                    t.uvTransform.value.copy(r.matrix))
                }(t, i, r, o) : i.isSpriteMaterial ? function(t, e) {
                    t.diffuse.value.copy(e.color),
                    t.opacity.value = e.opacity,
                    t.rotation.value = e.rotation,
                    e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let n;
                    e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                    t.uvTransform.value.copy(n.matrix))
                }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color),
                t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
            }
        }
    }
    function $r(t) {
        const e = void 0 !== (t = t || {}).canvas ? t.canvas : function() {
            const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            return t.style.display = "block",
            t
        }()
          , n = void 0 !== t.context ? t.context : null
          , i = void 0 !== t.alpha && t.alpha
          , r = void 0 === t.depth || t.depth
          , o = void 0 === t.stencil || t.stencil
          , s = void 0 !== t.antialias && t.antialias
          , a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha
          , l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer
          , c = void 0 !== t.powerPreference ? t.powerPreference : "default"
          , u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
        let h = null
          , d = null;
        const p = [];
        this.domElement = e,
        this.debug = {
            checkShaderErrors: !0
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.outputEncoding = W,
        this.physicallyCorrectLights = !1,
        this.toneMapping = 0,
        this.toneMappingExposure = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        const f = this;
        let m = !1
          , g = null
          , v = 0
          , y = 0
          , _ = null
          , x = null
          , b = -1
          , w = null;
        const M = new ut
          , S = new ut;
        let E = null
          , D = e.width
          , T = e.height
          , C = 1
          , L = null
          , O = null;
        const F = new ut(0,0,D,T)
          , I = new ut(0,0,D,T);
        let B = !1;
        const k = new qn;
        let z = !1
          , U = !1;
        const H = new Gt
          , G = new ft
          , V = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function j() {
            return null === _ ? C : 1
        }
        let q, X, Y, Z, J, Q, K, $, tt, et, rt, ot, st, at, lt, ct, ht, dt, pt, mt, gt, vt = n;
        function yt(t, n) {
            for (let i = 0; i < t.length; i++) {
                const r = t[i]
                  , o = e.getContext(r, n);
                if (null !== o)
                    return o
            }
            return null
        }
        try {
            const t = {
                alpha: i,
                depth: r,
                stencil: o,
                antialias: s,
                premultipliedAlpha: a,
                preserveDrawingBuffer: l,
                powerPreference: c,
                failIfMajorPerformanceCaveat: u
            };
            if (e.addEventListener("webglcontextlost", wt, !1),
            e.addEventListener("webglcontextrestored", Mt, !1),
            null === vt) {
                const e = ["webgl2", "webgl", "experimental-webgl"];
                if (!0 === f.isWebGL1Renderer && e.shift(),
                vt = yt(e, t),
                null === vt)
                    throw yt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            void 0 === vt.getShaderPrecisionFormat && (vt.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (t) {
            throw console.error("THREE.WebGLRenderer: " + t.message),
            t
        }
        function _t() {
            q = new oi(vt),
            X = new ni(vt,q,t),
            !1 === X.isWebGL2 && (q.get("WEBGL_depth_texture"),
            q.get("OES_texture_float"),
            q.get("OES_texture_half_float"),
            q.get("OES_texture_half_float_linear"),
            q.get("OES_standard_derivatives"),
            q.get("OES_element_index_uint"),
            q.get("OES_vertex_array_object"),
            q.get("ANGLE_instanced_arrays")),
            q.get("OES_texture_float_linear"),
            mt = new Xr(vt,q,X),
            Y = new Wr(vt,q,X),
            Y.scissor(S.copy(I).multiplyScalar(C).floor()),
            Y.viewport(M.copy(F).multiplyScalar(C).floor()),
            Z = new li(vt),
            J = new Pr,
            Q = new qr(vt,q,Y,J,X,mt,Z),
            K = new ri(f),
            $ = new Yn(vt,X),
            gt = new ti(vt,q,$,X),
            tt = new si(vt,$,Z,gt),
            et = new di(vt,tt,$,Z),
            ht = new hi(vt),
            lt = new ii(J),
            rt = new Lr(f,K,q,X,gt,lt),
            ot = new Kr(J),
            st = new Nr(J),
            at = new Hr(q,X),
            ct = new $n(f,K,Y,et,a),
            dt = new ei(vt,q,Z,X),
            pt = new ai(vt,q,Z,X),
            Z.programs = rt.programs,
            f.capabilities = X,
            f.extensions = q,
            f.properties = J,
            f.renderLists = st,
            f.state = Y,
            f.info = Z
        }
        _t();
        const xt = new Qr(f,vt);
        this.xr = xt;
        const bt = new jr(f,et,X.maxTextureSize);
        function wt(t) {
            t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            m = !0
        }
        function Mt() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            m = !1,
            _t()
        }
        function St(t) {
            const e = t.target;
            e.removeEventListener("dispose", St),
            function(t) {
                Et(t),
                J.remove(t)
            }(e)
        }
        function Et(t) {
            const e = J.get(t).program;
            void 0 !== e && rt.releaseProgram(e)
        }
        this.shadowMap = bt,
        this.getContext = function() {
            return vt
        }
        ,
        this.getContextAttributes = function() {
            return vt.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const t = q.get("WEBGL_lose_context");
            t && t.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const t = q.get("WEBGL_lose_context");
            t && t.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return C
        }
        ,
        this.setPixelRatio = function(t) {
            void 0 !== t && (C = t,
            this.setSize(D, T, !1))
        }
        ,
        this.getSize = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
            t = new it),
            t.set(D, T)
        }
        ,
        this.setSize = function(t, n, i) {
            xt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (D = t,
            T = n,
            e.width = Math.floor(t * C),
            e.height = Math.floor(n * C),
            !1 !== i && (e.style.width = t + "px",
            e.style.height = n + "px"),
            this.setViewport(0, 0, t, n))
        }
        ,
        this.getDrawingBufferSize = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
            t = new it),
            t.set(D * C, T * C).floor()
        }
        ,
        this.setDrawingBufferSize = function(t, n, i) {
            D = t,
            T = n,
            C = i,
            e.width = Math.floor(t * i),
            e.height = Math.floor(n * i),
            this.setViewport(0, 0, t, n)
        }
        ,
        this.getCurrentViewport = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
            t = new ut),
            t.copy(M)
        }
        ,
        this.getViewport = function(t) {
            return t.copy(F)
        }
        ,
        this.setViewport = function(t, e, n, i) {
            t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i),
            Y.viewport(M.copy(F).multiplyScalar(C).floor())
        }
        ,
        this.getScissor = function(t) {
            return t.copy(I)
        }
        ,
        this.setScissor = function(t, e, n, i) {
            t.isVector4 ? I.set(t.x, t.y, t.z, t.w) : I.set(t, e, n, i),
            Y.scissor(S.copy(I).multiplyScalar(C).floor())
        }
        ,
        this.getScissorTest = function() {
            return B
        }
        ,
        this.setScissorTest = function(t) {
            Y.setScissorTest(B = t)
        }
        ,
        this.setOpaqueSort = function(t) {
            L = t
        }
        ,
        this.setTransparentSort = function(t) {
            O = t
        }
        ,
        this.getClearColor = function(t) {
            return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),
            t = new Ne),
            t.copy(ct.getClearColor())
        }
        ,
        this.setClearColor = function() {
            ct.setClearColor.apply(ct, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return ct.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            ct.setClearAlpha.apply(ct, arguments)
        }
        ,
        this.clear = function(t, e, n) {
            let i = 0;
            (void 0 === t || t) && (i |= 16384),
            (void 0 === e || e) && (i |= 256),
            (void 0 === n || n) && (i |= 1024),
            vt.clear(i)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            e.removeEventListener("webglcontextlost", wt, !1),
            e.removeEventListener("webglcontextrestored", Mt, !1),
            st.dispose(),
            at.dispose(),
            J.dispose(),
            K.dispose(),
            et.dispose(),
            gt.dispose(),
            xt.dispose(),
            Tt.stop()
        }
        ,
        this.renderBufferImmediate = function(t, e) {
            gt.initAttributes();
            const n = J.get(t);
            t.hasPositions && !n.position && (n.position = vt.createBuffer()),
            t.hasNormals && !n.normal && (n.normal = vt.createBuffer()),
            t.hasUvs && !n.uv && (n.uv = vt.createBuffer()),
            t.hasColors && !n.color && (n.color = vt.createBuffer());
            const i = e.getAttributes();
            t.hasPositions && (vt.bindBuffer(34962, n.position),
            vt.bufferData(34962, t.positionArray, 35048),
            gt.enableAttribute(i.position),
            vt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
            t.hasNormals && (vt.bindBuffer(34962, n.normal),
            vt.bufferData(34962, t.normalArray, 35048),
            gt.enableAttribute(i.normal),
            vt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
            t.hasUvs && (vt.bindBuffer(34962, n.uv),
            vt.bufferData(34962, t.uvArray, 35048),
            gt.enableAttribute(i.uv),
            vt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
            t.hasColors && (vt.bindBuffer(34962, n.color),
            vt.bufferData(34962, t.colorArray, 35048),
            gt.enableAttribute(i.color),
            vt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
            gt.disableUnusedAttributes(),
            vt.drawArrays(4, 0, t.count),
            t.count = 0
        }
        ,
        this.renderBufferDirect = function(t, e, n, i, r, o) {
            null === e && (e = V);
            const s = r.isMesh && r.matrixWorld.determinant() < 0
              , a = Rt(t, e, i, r);
            Y.setMaterial(i, s);
            let l = n.index;
            const c = n.attributes.position;
            if (null === l) {
                if (void 0 === c || 0 === c.count)
                    return
            } else if (0 === l.count)
                return;
            let u, h = 1;
            !0 === i.wireframe && (l = tt.getWireframeAttribute(n),
            h = 2),
            (i.morphTargets || i.morphNormals) && ht.update(r, n, i, a),
            gt.setup(r, i, a, n, l);
            let d = dt;
            null !== l && (u = $.get(l),
            d = pt,
            d.setIndex(u));
            const p = null !== l ? l.count : c.count
              , f = n.drawRange.start * h
              , m = n.drawRange.count * h
              , g = null !== o ? o.start * h : 0
              , v = null !== o ? o.count * h : 1 / 0
              , y = Math.max(f, g)
              , _ = Math.min(p, f + m, g + v) - 1
              , x = Math.max(0, _ - y + 1);
            if (0 !== x) {
                if (r.isMesh)
                    !0 === i.wireframe ? (Y.setLineWidth(i.wireframeLinewidth * j()),
                    d.setMode(1)) : d.setMode(4);
                else if (r.isLine) {
                    let t = i.linewidth;
                    void 0 === t && (t = 1),
                    Y.setLineWidth(t * j()),
                    r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                } else
                    r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                if (r.isInstancedMesh)
                    d.renderInstances(y, x, r.count);
                else if (n.isInstancedBufferGeometry) {
                    const t = Math.min(n.instanceCount, n._maxInstanceCount);
                    d.renderInstances(y, x, t)
                } else
                    d.render(y, x)
            }
        }
        ,
        this.compile = function(t, e) {
            d = at.get(t),
            d.init(),
            t.traverseVisible((function(t) {
                t.isLight && t.layers.test(e.layers) && (d.pushLight(t),
                t.castShadow && d.pushShadow(t))
            }
            )),
            d.setupLights();
            const n = new WeakMap;
            t.traverse((function(e) {
                const i = e.material;
                if (i)
                    if (Array.isArray(i))
                        for (let r = 0; r < i.length; r++) {
                            const o = i[r];
                            !1 === n.has(o) && (Pt(o, t, e),
                            n.set(o))
                        }
                    else
                        !1 === n.has(i) && (Pt(i, t, e),
                        n.set(i))
            }
            ))
        }
        ;
        let Dt = null;
        const Tt = new Xn;
        function At(t, e, n, i) {
            if (!1 === t.visible)
                return;
            if (t.layers.test(e.layers))
                if (t.isGroup)
                    n = t.renderOrder;
                else if (t.isLOD)
                    !0 === t.autoUpdate && t.update(e);
                else if (t.isLight)
                    d.pushLight(t),
                    t.castShadow && d.pushShadow(t);
                else if (t.isSprite) {
                    if (!t.frustumCulled || k.intersectsSprite(t)) {
                        i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);
                        const e = et.update(t)
                          , r = t.material;
                        r.visible && h.push(t, e, r, n, G.z, null)
                    }
                } else if (t.isImmediateRenderObject)
                    i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H),
                    h.push(t, null, t.material, n, G.z, null);
                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== Z.render.frame && (t.skeleton.update(),
                t.skeleton.frame = Z.render.frame),
                !t.frustumCulled || k.intersectsObject(t))) {
                    i && G.setFromMatrixPosition(t.matrixWorld).applyMatrix4(H);
                    const e = et.update(t)
                      , r = t.material;
                    if (Array.isArray(r)) {
                        const i = e.groups;
                        for (let o = 0, s = i.length; o < s; o++) {
                            const s = i[o]
                              , a = r[s.materialIndex];
                            a && a.visible && h.push(t, e, a, n, G.z, s)
                        }
                    } else
                        r.visible && h.push(t, e, r, n, G.z, null)
                }
            const r = t.children;
            for (let t = 0, o = r.length; t < o; t++)
                At(r[t], e, n, i)
        }
        function Ct(t, e, n) {
            const i = !0 === e.isScene ? e.overrideMaterial : null;
            for (let r = 0, o = t.length; r < o; r++) {
                const o = t[r]
                  , s = o.object
                  , a = o.geometry
                  , l = null === i ? o.material : i
                  , c = o.group;
                if (n.isArrayCamera) {
                    const t = n.cameras;
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        s.layers.test(i.layers) && (Y.viewport(M.copy(i.viewport)),
                        d.setupLightsView(i),
                        Lt(s, e, i, a, l, c))
                    }
                } else
                    Lt(s, e, n, a, l, c)
            }
        }
        function Lt(t, e, n, i, r, o) {
            if (t.onBeforeRender(f, e, n, i, r, o),
            t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            t.isImmediateRenderObject) {
                const i = Rt(n, e, r, t);
                Y.setMaterial(r),
                gt.reset(),
                function(t, e) {
                    t.render((function(t) {
                        f.renderBufferImmediate(t, e)
                    }
                    ))
                }(t, i)
            } else
                f.renderBufferDirect(n, e, i, r, t, o);
            t.onAfterRender(f, e, n, i, r, o)
        }
        function Pt(t, e, n) {
            !0 !== e.isScene && (e = V);
            const i = J.get(t)
              , r = d.state.lights
              , o = d.state.shadowsArray
              , s = r.state.version
              , a = rt.getParameters(t, r.state, o, e, n)
              , l = rt.getProgramCacheKey(a);
            let c = i.program
              , u = !0;
            if (void 0 === c)
                t.addEventListener("dispose", St);
            else if (c.cacheKey !== l)
                Et(t);
            else if (i.lightsStateVersion !== s)
                u = !1;
            else {
                if (void 0 !== a.shaderID) {
                    const n = t.isMeshStandardMaterial ? e.environment : null;
                    return void (i.envMap = K.get(t.envMap || n))
                }
                u = !1
            }
            u && (a.uniforms = rt.getUniforms(t),
            t.onBeforeCompile(a, f),
            c = rt.acquireProgram(a, l),
            i.program = c,
            i.uniforms = a.uniforms,
            i.outputEncoding = a.outputEncoding);
            const h = i.uniforms;
            (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = lt.numPlanes,
            i.numIntersection = lt.numIntersection,
            h.clippingPlanes = lt.uniform),
            i.environment = t.isMeshStandardMaterial ? e.environment : null,
            i.fog = e.fog,
            i.envMap = K.get(t.envMap || i.environment),
            i.needsLights = function(t) {
                return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
            }(t),
            i.lightsStateVersion = s,
            i.needsLights && (h.ambientLightColor.value = r.state.ambient,
            h.lightProbe.value = r.state.probe,
            h.directionalLights.value = r.state.directional,
            h.directionalLightShadows.value = r.state.directionalShadow,
            h.spotLights.value = r.state.spot,
            h.spotLightShadows.value = r.state.spotShadow,
            h.rectAreaLights.value = r.state.rectArea,
            h.ltc_1.value = r.state.rectAreaLTC1,
            h.ltc_2.value = r.state.rectAreaLTC2,
            h.pointLights.value = r.state.point,
            h.pointLightShadows.value = r.state.pointShadow,
            h.hemisphereLights.value = r.state.hemi,
            h.directionalShadowMap.value = r.state.directionalShadowMap,
            h.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
            h.spotShadowMap.value = r.state.spotShadowMap,
            h.spotShadowMatrix.value = r.state.spotShadowMatrix,
            h.pointShadowMap.value = r.state.pointShadowMap,
            h.pointShadowMatrix.value = r.state.pointShadowMatrix);
            const p = i.program.getUniforms()
              , m = cr.seqWithValue(p.seq, h);
            i.uniformsList = m
        }
        function Rt(t, e, n, i) {
            !0 !== e.isScene && (e = V),
            Q.resetTextureUnits();
            const r = e.fog
              , o = n.isMeshStandardMaterial ? e.environment : null
              , s = null === _ ? f.outputEncoding : _.texture.encoding
              , a = K.get(n.envMap || o)
              , l = J.get(n)
              , c = d.state.lights;
            if (!0 === z && (!0 === U || t !== w)) {
                const e = t === w && n.id === b;
                lt.setState(n, t, e)
            }
            n.version === l.__version ? n.fog && l.fog !== r || l.environment !== o || l.needsLights && l.lightsStateVersion !== c.state.version ? Pt(n, e, i) : void 0 === l.numClippingPlanes || l.numClippingPlanes === lt.numPlanes && l.numIntersection === lt.numIntersection ? (l.outputEncoding !== s || l.envMap !== a) && Pt(n, e, i) : Pt(n, e, i) : (Pt(n, e, i),
            l.__version = n.version);
            let u = !1
              , h = !1
              , p = !1;
            const m = l.program
              , g = m.getUniforms()
              , v = l.uniforms;
            if (Y.useProgram(m.program) && (u = !0,
            h = !0,
            p = !0),
            n.id !== b && (b = n.id,
            h = !0),
            u || w !== t) {
                if (g.setValue(vt, "projectionMatrix", t.projectionMatrix),
                X.logarithmicDepthBuffer && g.setValue(vt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)),
                w !== t && (w = t,
                h = !0,
                p = !0),
                n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                    const e = g.map.cameraPosition;
                    void 0 !== e && e.setValue(vt, G.setFromMatrixPosition(t.matrixWorld))
                }
                (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && g.setValue(vt, "isOrthographic", !0 === t.isOrthographicCamera),
                (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && g.setValue(vt, "viewMatrix", t.matrixWorldInverse)
            }
            if (n.skinning) {
                g.setOptional(vt, i, "bindMatrix"),
                g.setOptional(vt, i, "bindMatrixInverse");
                const t = i.skeleton;
                if (t) {
                    const e = t.bones;
                    if (X.floatVertexTextures) {
                        if (null === t.boneTexture) {
                            let n = Math.sqrt(4 * e.length);
                            n = nt.ceilPowerOfTwo(n),
                            n = Math.max(n, 4);
                            const i = new Float32Array(n * n * 4);
                            i.set(t.boneMatrices);
                            const r = new Vn(i,n,n,N,P);
                            t.boneMatrices = i,
                            t.boneTexture = r,
                            t.boneTextureSize = n
                        }
                        g.setValue(vt, "boneTexture", t.boneTexture, Q),
                        g.setValue(vt, "boneTextureSize", t.boneTextureSize)
                    } else
                        g.setOptional(vt, t, "boneMatrices")
                }
            }
            var y, x;
            return (h || l.receiveShadow !== i.receiveShadow) && (l.receiveShadow = i.receiveShadow,
            g.setValue(vt, "receiveShadow", i.receiveShadow)),
            h && (g.setValue(vt, "toneMappingExposure", f.toneMappingExposure),
            l.needsLights && (x = p,
            (y = v).ambientLightColor.needsUpdate = x,
            y.lightProbe.needsUpdate = x,
            y.directionalLights.needsUpdate = x,
            y.directionalLightShadows.needsUpdate = x,
            y.pointLights.needsUpdate = x,
            y.pointLightShadows.needsUpdate = x,
            y.spotLights.needsUpdate = x,
            y.spotLightShadows.needsUpdate = x,
            y.rectAreaLights.needsUpdate = x,
            y.hemisphereLights.needsUpdate = x),
            r && n.fog && ot.refreshFogUniforms(v, r),
            ot.refreshMaterialUniforms(v, n, C, T),
            cr.upload(vt, l.uniformsList, v, Q)),
            n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (cr.upload(vt, l.uniformsList, v, Q),
            n.uniformsNeedUpdate = !1),
            n.isSpriteMaterial && g.setValue(vt, "center", i.center),
            g.setValue(vt, "modelViewMatrix", i.modelViewMatrix),
            g.setValue(vt, "normalMatrix", i.normalMatrix),
            g.setValue(vt, "modelMatrix", i.matrixWorld),
            m
        }
        Tt.setAnimationLoop((function(t) {
            xt.isPresenting || Dt && Dt(t)
        }
        )),
        "undefined" != typeof window && Tt.setContext(window),
        this.setAnimationLoop = function(t) {
            Dt = t,
            xt.setAnimationLoop(t),
            null === t ? Tt.stop() : Tt.start()
        }
        ,
        this.render = function(t, e) {
            let n, i;
            if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),
            n = arguments[2]),
            void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),
            i = arguments[3]),
            void 0 !== e && !0 !== e.isCamera)
                return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!0 === m)
                return;
            gt.resetDefaultState(),
            b = -1,
            w = null,
            !0 === t.autoUpdate && t.updateMatrixWorld(),
            null === e.parent && e.updateMatrixWorld(),
            !0 === xt.enabled && !0 === xt.isPresenting && (e = xt.getCamera(e)),
            !0 === t.isScene && t.onBeforeRender(f, t, e, n || _),
            d = at.get(t, p.length),
            d.init(),
            p.push(d),
            H.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            k.setFromProjectionMatrix(H),
            U = this.localClippingEnabled,
            z = lt.init(this.clippingPlanes, U, e),
            h = st.get(t, e),
            h.init(),
            At(t, e, 0, f.sortObjects),
            h.finish(),
            !0 === f.sortObjects && h.sort(L, O),
            !0 === z && lt.beginShadows();
            const r = d.state.shadowsArray;
            bt.render(r, t, e),
            d.setupLights(),
            d.setupLightsView(e),
            !0 === z && lt.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            void 0 !== n && this.setRenderTarget(n),
            ct.render(h, t, e, i);
            const o = h.opaque
              , s = h.transparent;
            o.length > 0 && Ct(o, t, e),
            s.length > 0 && Ct(s, t, e),
            !0 === t.isScene && t.onAfterRender(f, t, e),
            null !== _ && (Q.updateRenderTargetMipmap(_),
            Q.updateMultisampleRenderTarget(_)),
            Y.buffers.depth.setTest(!0),
            Y.buffers.depth.setMask(!0),
            Y.buffers.color.setMask(!0),
            Y.setPolygonOffset(!1),
            p.pop(),
            d = p.length > 0 ? p[p.length - 1] : null,
            h = null
        }
        ,
        this.setFramebuffer = function(t) {
            g !== t && null === _ && vt.bindFramebuffer(36160, t),
            g = t
        }
        ,
        this.getActiveCubeFace = function() {
            return v
        }
        ,
        this.getActiveMipmapLevel = function() {
            return y
        }
        ,
        this.getRenderList = function() {
            return h
        }
        ,
        this.setRenderList = function(t) {
            h = t
        }
        ,
        this.getRenderTarget = function() {
            return _
        }
        ,
        this.setRenderTarget = function(t, e=0, n=0) {
            _ = t,
            v = e,
            y = n,
            t && void 0 === J.get(t).__webglFramebuffer && Q.setupRenderTarget(t);
            let i = g
              , r = !1;
            if (t) {
                const n = J.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget ? (i = n[e],
                r = !0) : i = t.isWebGLMultisampleRenderTarget ? J.get(t).__webglMultisampledFramebuffer : n,
                M.copy(t.viewport),
                S.copy(t.scissor),
                E = t.scissorTest
            } else
                M.copy(F).multiplyScalar(C).floor(),
                S.copy(I).multiplyScalar(C).floor(),
                E = B;
            if (x !== i && (vt.bindFramebuffer(36160, i),
            x = i),
            Y.viewport(M),
            Y.scissor(S),
            Y.setScissorTest(E),
            r) {
                const i = J.get(t.texture);
                vt.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
            }
        }
        ,
        this.readRenderTargetPixels = function(t, e, n, i, r, o, s) {
            if (!t || !t.isWebGLRenderTarget)
                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let a = J.get(t).__webglFramebuffer;
            if (t.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]),
            a) {
                let s = !1;
                a !== x && (vt.bindFramebuffer(36160, a),
                s = !0);
                try {
                    const a = t.texture
                      , l = a.format
                      , c = a.type;
                    if (l !== N && mt.convert(l) !== vt.getParameter(35739))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    if (!(c === A || mt.convert(c) === vt.getParameter(35738) || c === P && (X.isWebGL2 || q.get("OES_texture_float") || q.get("WEBGL_color_buffer_float")) || c === R && (X.isWebGL2 ? q.get("EXT_color_buffer_float") : q.get("EXT_color_buffer_half_float"))))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    36053 === vt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && vt.readPixels(e, n, i, r, mt.convert(l), mt.convert(c), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                } finally {
                    s && vt.bindFramebuffer(36160, x)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(t, e, n=0) {
            const i = Math.pow(2, -n)
              , r = Math.floor(e.image.width * i)
              , o = Math.floor(e.image.height * i)
              , s = mt.convert(e.format);
            Q.setTexture2D(e, 0),
            vt.copyTexImage2D(3553, n, s, t.x, t.y, r, o, 0),
            Y.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(t, e, n, i=0) {
            const r = e.image.width
              , o = e.image.height
              , s = mt.convert(n.format)
              , a = mt.convert(n.type);
            Q.setTexture2D(n, 0),
            vt.pixelStorei(37440, n.flipY),
            vt.pixelStorei(37441, n.premultiplyAlpha),
            vt.pixelStorei(3317, n.unpackAlignment),
            e.isDataTexture ? vt.texSubImage2D(3553, i, t.x, t.y, r, o, s, a, e.image.data) : e.isCompressedTexture ? vt.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, s, e.mipmaps[0].data) : vt.texSubImage2D(3553, i, t.x, t.y, s, a, e.image),
            0 === i && n.generateMipmaps && vt.generateMipmap(3553),
            Y.unbindTexture()
        }
        ,
        this.initTexture = function(t) {
            Q.setTexture2D(t, 0),
            Y.unbindTexture()
        }
        ,
        this.resetState = function() {
            Y.reset(),
            gt.reset()
        }
        ,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    function to(t) {
        $r.call(this, t)
    }
    Yr.prototype = Object.assign(Object.create(kn.prototype), {
        constructor: Yr,
        isArrayCamera: !0
    }),
    Zr.prototype = Object.assign(Object.create(pe.prototype), {
        constructor: Zr,
        isGroup: !0
    }),
    Object.assign(Jr.prototype, {
        constructor: Jr,
        getHandSpace: function() {
            if (null === this._hand && (this._hand = new Zr,
            this._hand.matrixAutoUpdate = !1,
            this._hand.visible = !1,
            this._hand.joints = [],
            this._hand.inputState = {
                pinching: !1
            },
            window.XRHand))
                for (let t = 0; t <= window.XRHand.LITTLE_PHALANX_TIP; t++) {
                    const t = new Zr;
                    t.matrixAutoUpdate = !1,
                    t.visible = !1,
                    this._hand.joints.push(t),
                    this._hand.add(t)
                }
            return this._hand
        },
        getTargetRaySpace: function() {
            return null === this._targetRay && (this._targetRay = new Zr,
            this._targetRay.matrixAutoUpdate = !1,
            this._targetRay.visible = !1),
            this._targetRay
        },
        getGripSpace: function() {
            return null === this._grip && (this._grip = new Zr,
            this._grip.matrixAutoUpdate = !1,
            this._grip.visible = !1),
            this._grip
        },
        dispatchEvent: function(t) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            null !== this._hand && this._hand.dispatchEvent(t),
            this
        },
        disconnect: function(t) {
            return this.dispatchEvent({
                type: "disconnected",
                data: t
            }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
        },
        update: function(t, e, n) {
            let i = null
              , r = null
              , o = null;
            const s = this._targetRay
              , a = this._grip
              , l = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState)
                if (l && t.hand) {
                    o = !0;
                    for (let i = 0; i <= window.XRHand.LITTLE_PHALANX_TIP; i++)
                        if (t.hand[i]) {
                            const r = e.getJointPose(t.hand[i], n)
                              , o = l.joints[i];
                            null !== r && (o.matrix.fromArray(r.transform.matrix),
                            o.matrix.decompose(o.position, o.rotation, o.scale),
                            o.jointRadius = r.radius),
                            o.visible = null !== r;
                            const s = l.joints[window.XRHand.INDEX_PHALANX_TIP]
                              , a = l.joints[window.XRHand.THUMB_PHALANX_TIP]
                              , c = s.position.distanceTo(a.position)
                              , u = .02
                              , h = .005;
                            l.inputState.pinching && c > u + h ? (l.inputState.pinching = !1,
                            this.dispatchEvent({
                                type: "pinchend",
                                handedness: t.handedness,
                                target: this
                            })) : !l.inputState.pinching && c <= u - h && (l.inputState.pinching = !0,
                            this.dispatchEvent({
                                type: "pinchstart",
                                handedness: t.handedness,
                                target: this
                            }))
                        }
                } else
                    null !== s && (i = e.getPose(t.targetRaySpace, n),
                    null !== i && (s.matrix.fromArray(i.transform.matrix),
                    s.matrix.decompose(s.position, s.rotation, s.scale))),
                    null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n),
                    null !== r && (a.matrix.fromArray(r.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale)));
            return null !== s && (s.visible = null !== i),
            null !== a && (a.visible = null !== r),
            null !== l && (l.visible = null !== o),
            this
        }
    }),
    Object.assign(Qr.prototype, $.prototype),
    to.prototype = Object.assign(Object.create($r.prototype), {
        constructor: to,
        isWebGL1Renderer: !0
    });
    class eo extends pe {
        constructor() {
            super(),
            Object.defineProperty(this, "isScene", {
                value: !0
            }),
            this.type = "Scene",
            this.background = null,
            this.environment = null,
            this.fog = null,
            this.overrideMaterial = null,
            this.autoUpdate = !0,
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        copy(t, e) {
            return super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment && (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            this.autoUpdate = t.autoUpdate,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this
        }
        toJSON(t) {
            const e = super.toJSON(t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)),
            null !== this.environment && (e.object.environment = this.environment.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
        }
    }
    function no(t, e) {
        this.array = t,
        this.stride = e,
        this.count = void 0 !== t ? t.length / e : 0,
        this.usage = J,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = nt.generateUUID()
    }
    Object.defineProperty(no.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(no.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setUsage: function(t) {
            return this.usage = t,
            this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array),
            this.count = t.count,
            this.stride = t.stride,
            this.usage = t.usage,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.stride,
            n *= e.stride;
            for (let i = 0, r = this.stride; i < r; i++)
                this.array[t + i] = e.array[n + i];
            return this
        },
        set: function(t, e=0) {
            return this.array.set(t, e),
            this
        },
        clone: function(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = nt.generateUUID()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const e = new no(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),this.stride);
            return e.setUsage(this.usage),
            e
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        },
        toJSON: function(t) {
            return void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = nt.generateUUID()),
            void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    });
    const io = new ft;
    function ro(t, e, n, i) {
        this.name = "",
        this.data = t,
        this.itemSize = e,
        this.offset = n,
        this.normalized = !0 === i
    }
    function oo(t) {
        ke.call(this),
        this.type = "SpriteMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.setValues(t)
    }
    let so;
    Object.defineProperties(ro.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        },
        needsUpdate: {
            set: function(t) {
                this.data.needsUpdate = t
            }
        }
    }),
    Object.assign(ro.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function(t) {
            for (let e = 0, n = this.data.count; e < n; e++)
                io.x = this.getX(e),
                io.y = this.getY(e),
                io.z = this.getZ(e),
                io.applyMatrix4(t),
                this.setXYZ(e, io.x, io.y, io.z);
            return this
        },
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e,
            this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e,
            this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e,
            this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e,
            this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, n) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, i) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this
        },
        setXYZW: function(t, e, n, i, r) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this.data.array[t + 3] = r,
            this
        },
        clone: function(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const n = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++)
                        t.push(this.data.array[n + e])
                }
                return new Ge(new this.array.constructor(t),this.itemSize,this.normalized)
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
            new ro(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
        },
        toJSON: function(t) {
            if (void 0 === t) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                const t = [];
                for (let e = 0; e < this.count; e++) {
                    const n = e * this.data.stride + this.offset;
                    for (let e = 0; e < this.itemSize; e++)
                        t.push(this.data.array[n + e])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: t,
                    normalized: this.normalized
                }
            }
            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
            void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    }),
    oo.prototype = Object.create(ke.prototype),
    oo.prototype.constructor = oo,
    oo.prototype.isSpriteMaterial = !0,
    oo.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.rotation = t.rotation,
        this.sizeAttenuation = t.sizeAttenuation,
        this
    }
    ;
    const ao = new ft
      , lo = new ft
      , co = new ft
      , uo = new it
      , ho = new it
      , po = new Gt
      , fo = new ft
      , mo = new ft
      , go = new ft
      , vo = new it
      , yo = new it
      , _o = new it;
    function xo(t) {
        if (pe.call(this),
        this.type = "Sprite",
        void 0 === so) {
            so = new hn;
            const t = new no(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5);
            so.setIndex([0, 1, 2, 0, 2, 3]),
            so.setAttribute("position", new ro(t,3,0,!1)),
            so.setAttribute("uv", new ro(t,2,3,!1))
        }
        this.geometry = so,
        this.material = void 0 !== t ? t : new oo,
        this.center = new it(.5,.5)
    }
    function bo(t, e, n, i, r, o) {
        uo.subVectors(t, n).addScalar(.5).multiply(i),
        void 0 !== r ? (ho.x = o * uo.x - r * uo.y,
        ho.y = r * uo.x + o * uo.y) : ho.copy(uo),
        t.copy(e),
        t.x += ho.x,
        t.y += ho.y,
        t.applyMatrix4(po)
    }
    xo.prototype = Object.assign(Object.create(pe.prototype), {
        constructor: xo,
        isSprite: !0,
        raycast: function(t, e) {
            null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
            lo.setFromMatrixScale(this.matrixWorld),
            po.copy(t.camera.matrixWorld),
            this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld),
            co.setFromMatrixPosition(this.modelViewMatrix),
            t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && lo.multiplyScalar(-co.z);
            const n = this.material.rotation;
            let i, r;
            0 !== n && (r = Math.cos(n),
            i = Math.sin(n));
            const o = this.center;
            bo(fo.set(-.5, -.5, 0), co, o, lo, i, r),
            bo(mo.set(.5, -.5, 0), co, o, lo, i, r),
            bo(go.set(.5, .5, 0), co, o, lo, i, r),
            vo.set(0, 0),
            yo.set(1, 0),
            _o.set(1, 1);
            let s = t.ray.intersectTriangle(fo, mo, go, !1, ao);
            if (null === s && (bo(mo.set(-.5, .5, 0), co, o, lo, i, r),
            yo.set(0, 1),
            s = t.ray.intersectTriangle(fo, go, mo, !1, ao),
            null === s))
                return;
            const a = t.ray.origin.distanceTo(ao);
            a < t.near || a > t.far || e.push({
                distance: a,
                point: ao.clone(),
                uv: Ae.getUV(ao, fo, mo, go, vo, yo, _o, new it),
                face: null,
                object: this
            })
        },
        copy: function(t) {
            return pe.prototype.copy.call(this, t),
            void 0 !== t.center && this.center.copy(t.center),
            this.material = t.material,
            this
        }
    });
    const wo = new ft
      , Mo = new ft;
    function So() {
        pe.call(this),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        }),
        this.autoUpdate = !0
    }
    So.prototype = Object.assign(Object.create(pe.prototype), {
        constructor: So,
        isLOD: !0,
        copy: function(t) {
            pe.prototype.copy.call(this, t, !1);
            const e = t.levels;
            for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this.autoUpdate = t.autoUpdate,
            this
        },
        addLevel: function(t, e=0) {
            e = Math.abs(e);
            const n = this.levels;
            let i;
            for (i = 0; i < n.length && !(e < n[i].distance); i++)
                ;
            return n.splice(i, 0, {
                distance: e,
                object: t
            }),
            this.add(t),
            this
        },
        getCurrentLevel: function() {
            return this._currentLevel
        },
        getObjectForDistance: function(t) {
            const e = this.levels;
            if (e.length > 0) {
                let n, i;
                for (n = 1,
                i = e.length; n < i && !(t < e[n].distance); n++)
                    ;
                return e[n - 1].object
            }
            return null
        },
        raycast: function(t, e) {
            if (this.levels.length > 0) {
                wo.setFromMatrixPosition(this.matrixWorld);
                const n = t.ray.origin.distanceTo(wo);
                this.getObjectForDistance(n).raycast(t, e)
            }
        },
        update: function(t) {
            const e = this.levels;
            if (e.length > 1) {
                wo.setFromMatrixPosition(t.matrixWorld),
                Mo.setFromMatrixPosition(this.matrixWorld);
                const n = wo.distanceTo(Mo) / t.zoom;
                let i, r;
                for (e[0].object.visible = !0,
                i = 1,
                r = e.length; i < r && n >= e[i].distance; i++)
                    e[i - 1].object.visible = !1,
                    e[i].object.visible = !0;
                for (this._currentLevel = i - 1; i < r; i++)
                    e[i].object.visible = !1
            }
        },
        toJSON: function(t) {
            const e = pe.prototype.toJSON.call(this, t);
            !1 === this.autoUpdate && (e.object.autoUpdate = !1),
            e.object.levels = [];
            const n = this.levels;
            for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                e.object.levels.push({
                    object: i.object.uuid,
                    distance: i.distance
                })
            }
            return e
        }
    });
    const Eo = new ft
      , Do = new ut
      , To = new ut
      , Ao = new ft
      , Co = new Gt;
    function Lo(t, e) {
        t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),
        Cn.call(this, t, e),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Gt,
        this.bindMatrixInverse = new Gt
    }
    function Po() {
        pe.call(this),
        this.type = "Bone"
    }
    Lo.prototype = Object.assign(Object.create(Cn.prototype), {
        constructor: Lo,
        isSkinnedMesh: !0,
        copy: function(t) {
            return Cn.prototype.copy.call(this, t),
            this.bindMode = t.bindMode,
            this.bindMatrix.copy(t.bindMatrix),
            this.bindMatrixInverse.copy(t.bindMatrixInverse),
            this.skeleton = t.skeleton,
            this
        },
        bind: function(t, e) {
            this.skeleton = t,
            void 0 === e && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            e = this.matrixWorld),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.copy(e).invert()
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            const t = new ut
              , e = this.geometry.attributes.skinWeight;
            for (let n = 0, i = e.count; n < i; n++) {
                t.x = e.getX(n),
                t.y = e.getY(n),
                t.z = e.getZ(n),
                t.w = e.getW(n);
                const i = 1 / t.manhattanLength();
                i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w)
            }
        },
        updateMatrixWorld: function(t) {
            Cn.prototype.updateMatrixWorld.call(this, t),
            "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        boneTransform: function(t, e) {
            const n = this.skeleton
              , i = this.geometry;
            Do.fromBufferAttribute(i.attributes.skinIndex, t),
            To.fromBufferAttribute(i.attributes.skinWeight, t),
            Eo.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix),
            e.set(0, 0, 0);
            for (let t = 0; t < 4; t++) {
                const i = To.getComponent(t);
                if (0 !== i) {
                    const r = Do.getComponent(t);
                    Co.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                    e.addScaledVector(Ao.copy(Eo).applyMatrix4(Co), i)
                }
            }
            return e.applyMatrix4(this.bindMatrixInverse)
        }
    }),
    Po.prototype = Object.assign(Object.create(pe.prototype), {
        constructor: Po,
        isBone: !0
    });
    const Ro = new Gt
      , Oo = new Gt;
    function Fo(t=[], e=[]) {
        this.uuid = nt.generateUUID(),
        this.bones = t.slice(0),
        this.boneInverses = e,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.boneTextureSize = 0,
        this.frame = -1,
        this.init()
    }
    Object.assign(Fo.prototype, {
        init: function() {
            const t = this.bones
              , e = this.boneInverses;
            if (this.boneMatrices = new Float32Array(16 * t.length),
            0 === e.length)
                this.calculateInverses();
            else if (t.length !== e.length) {
                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                this.boneInverses = [];
                for (let t = 0, e = this.bones.length; t < e; t++)
                    this.boneInverses.push(new Gt)
            }
        },
        calculateInverses: function() {
            this.boneInverses.length = 0;
            for (let t = 0, e = this.bones.length; t < e; t++) {
                const e = new Gt;
                this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                this.boneInverses.push(e)
            }
        },
        pose: function() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
                const e = this.bones[t];
                e && e.matrixWorld.copy(this.boneInverses[t]).invert()
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
                const e = this.bones[t];
                e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale))
            }
        },
        update: function() {
            const t = this.bones
              , e = this.boneInverses
              , n = this.boneMatrices
              , i = this.boneTexture;
            for (let i = 0, r = t.length; i < r; i++) {
                const r = t[i] ? t[i].matrixWorld : Oo;
                Ro.multiplyMatrices(r, e[i]),
                Ro.toArray(n, 16 * i)
            }
            null !== i && (i.needsUpdate = !0)
        },
        clone: function() {
            return new Fo(this.bones,this.boneInverses)
        },
        getBoneByName: function(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
                const n = this.bones[e];
                if (n.name === t)
                    return n
            }
        },
        dispose: function() {
            null !== this.boneTexture && (this.boneTexture.dispose(),
            this.boneTexture = null)
        },
        fromJSON: function(t, e) {
            this.uuid = t.uuid;
            for (let n = 0, i = t.bones.length; n < i; n++) {
                const i = t.bones[n];
                let r = e[i];
                void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                r = new Po),
                this.bones.push(r),
                this.boneInverses.push((new Gt).fromArray(t.boneInverses[n]))
            }
            return this.init(),
            this
        },
        toJSON: function() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "Skeleton",
                    generator: "Skeleton.toJSON"
                },
                bones: [],
                boneInverses: []
            };
            t.uuid = this.uuid;
            const e = this.bones
              , n = this.boneInverses;
            for (let i = 0, r = e.length; i < r; i++) {
                const r = e[i];
                t.bones.push(r.uuid);
                const o = n[i];
                t.boneInverses.push(o.toArray())
            }
            return t
        }
    });
    const No = new Gt
      , Io = new Gt
      , Bo = []
      , ko = new Cn;
    function zo(t, e, n) {
        Cn.call(this, t, e),
        this.instanceMatrix = new Ge(new Float32Array(16 * n),16),
        this.instanceColor = null,
        this.count = n,
        this.frustumCulled = !1
    }
    function Uo(t) {
        ke.call(this),
        this.type = "LineBasicMaterial",
        this.color = new Ne(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.morphTargets = !1,
        this.setValues(t)
    }
    zo.prototype = Object.assign(Object.create(Cn.prototype), {
        constructor: zo,
        isInstancedMesh: !0,
        copy: function(t) {
            return Cn.prototype.copy.call(this, t),
            this.instanceMatrix.copy(t.instanceMatrix),
            this.count = t.count,
            this
        },
        getColorAt: function(t, e) {
            e.fromArray(this.instanceColor.array, 3 * t)
        },
        getMatrixAt: function(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t)
        },
        raycast: function(t, e) {
            const n = this.matrixWorld
              , i = this.count;
            if (ko.geometry = this.geometry,
            ko.material = this.material,
            void 0 !== ko.material)
                for (let r = 0; r < i; r++) {
                    this.getMatrixAt(r, No),
                    Io.multiplyMatrices(n, No),
                    ko.matrixWorld = Io,
                    ko.raycast(t, Bo);
                    for (let t = 0, n = Bo.length; t < n; t++) {
                        const n = Bo[t];
                        n.instanceId = r,
                        n.object = this,
                        e.push(n)
                    }
                    Bo.length = 0
                }
        },
        setColorAt: function(t, e) {
            null === this.instanceColor && (this.instanceColor = new Ge(new Float32Array(3 * this.count),3)),
            e.toArray(this.instanceColor.array, 3 * t)
        },
        setMatrixAt: function(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t)
        },
        updateMorphTargets: function() {},
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Uo.prototype = Object.create(ke.prototype),
    Uo.prototype.constructor = Uo,
    Uo.prototype.isLineBasicMaterial = !0,
    Uo.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.linewidth = t.linewidth,
        this.linecap = t.linecap,
        this.linejoin = t.linejoin,
        this.morphTargets = t.morphTargets,
        this
    }
    ;
    const Ho = new ft
      , Go = new ft
      , Vo = new Gt
      , jo = new Ht
      , Wo = new Ot;
    function qo(t=new hn, e=new Uo) {
        pe.call(this),
        this.type = "Line",
        this.geometry = t,
        this.material = e,
        this.updateMorphTargets()
    }
    qo.prototype = Object.assign(Object.create(pe.prototype), {
        constructor: qo,
        isLine: !0,
        copy: function(t) {
            return pe.prototype.copy.call(this, t),
            this.material = t.material,
            this.geometry = t.geometry,
            this
        },
        computeLineDistances: function() {
            const t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    const e = t.attributes.position
                      , n = [0];
                    for (let t = 1, i = e.count; t < i; t++)
                        Ho.fromBufferAttribute(e, t - 1),
                        Go.fromBufferAttribute(e, t),
                        n[t] = n[t - 1],
                        n[t] += Ho.distanceTo(Go);
                    t.setAttribute("lineDistance", new Qe(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry) {
                const e = t.vertices
                  , n = t.lineDistances;
                n[0] = 0;
                for (let t = 1, i = e.length; t < i; t++)
                    n[t] = n[t - 1],
                    n[t] += e[t - 1].distanceTo(e[t])
            }
            return this
        },
        raycast: function(t, e) {
            const n = this.geometry
              , i = this.matrixWorld
              , r = t.params.Line.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            Wo.copy(n.boundingSphere),
            Wo.applyMatrix4(i),
            Wo.radius += r,
            !1 === t.ray.intersectsSphere(Wo))
                return;
            Vo.copy(i).invert(),
            jo.copy(t.ray).applyMatrix4(Vo);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , s = o * o
              , a = new ft
              , l = new ft
              , c = new ft
              , u = new ft
              , h = this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
                const i = n.index
                  , r = n.attributes.position;
                if (null !== i) {
                    const n = i.array;
                    for (let i = 0, o = n.length - 1; i < o; i += h) {
                        const o = n[i]
                          , h = n[i + 1];
                        a.fromBufferAttribute(r, o),
                        l.fromBufferAttribute(r, h);
                        if (jo.distanceSqToSegment(a, l, u, c) > s)
                            continue;
                        u.applyMatrix4(this.matrixWorld);
                        const d = t.ray.origin.distanceTo(u);
                        d < t.near || d > t.far || e.push({
                            distance: d,
                            point: c.clone().applyMatrix4(this.matrixWorld),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else
                    for (let n = 0, i = r.count - 1; n < i; n += h) {
                        a.fromBufferAttribute(r, n),
                        l.fromBufferAttribute(r, n + 1);
                        if (jo.distanceSqToSegment(a, l, u, c) > s)
                            continue;
                        u.applyMatrix4(this.matrixWorld);
                        const i = t.ray.origin.distanceTo(u);
                        i < t.near || i > t.far || e.push({
                            distance: i,
                            point: c.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
            } else if (n.isGeometry) {
                const i = n.vertices
                  , r = i.length;
                for (let n = 0; n < r - 1; n += h) {
                    if (jo.distanceSqToSegment(i[n], i[n + 1], u, c) > s)
                        continue;
                    u.applyMatrix4(this.matrixWorld);
                    const r = t.ray.origin.distanceTo(u);
                    r < t.near || r > t.far || e.push({
                        distance: r,
                        point: c.clone().applyMatrix4(this.matrixWorld),
                        index: n,
                        face: null,
                        faceIndex: null,
                        object: this
                    })
                }
            }
        },
        updateMorphTargets: function() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes
                  , n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    });
    const Xo = new ft
      , Yo = new ft;
    function Zo(t, e) {
        qo.call(this, t, e),
        this.type = "LineSegments"
    }
    function Jo(t, e) {
        qo.call(this, t, e),
        this.type = "LineLoop"
    }
    function Qo(t) {
        ke.call(this),
        this.type = "PointsMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.morphTargets = !1,
        this.setValues(t)
    }
    Zo.prototype = Object.assign(Object.create(qo.prototype), {
        constructor: Zo,
        isLineSegments: !0,
        computeLineDistances: function() {
            const t = this.geometry;
            if (t.isBufferGeometry)
                if (null === t.index) {
                    const e = t.attributes.position
                      , n = [];
                    for (let t = 0, i = e.count; t < i; t += 2)
                        Xo.fromBufferAttribute(e, t),
                        Yo.fromBufferAttribute(e, t + 1),
                        n[t] = 0 === t ? 0 : n[t - 1],
                        n[t + 1] = n[t] + Xo.distanceTo(Yo);
                    t.setAttribute("lineDistance", new Qe(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (t.isGeometry) {
                const e = t.vertices
                  , n = t.lineDistances;
                for (let t = 0, i = e.length; t < i; t += 2)
                    Xo.copy(e[t]),
                    Yo.copy(e[t + 1]),
                    n[t] = 0 === t ? 0 : n[t - 1],
                    n[t + 1] = n[t] + Xo.distanceTo(Yo)
            }
            return this
        }
    }),
    Jo.prototype = Object.assign(Object.create(qo.prototype), {
        constructor: Jo,
        isLineLoop: !0
    }),
    Qo.prototype = Object.create(ke.prototype),
    Qo.prototype.constructor = Qo,
    Qo.prototype.isPointsMaterial = !0,
    Qo.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.alphaMap = t.alphaMap,
        this.size = t.size,
        this.sizeAttenuation = t.sizeAttenuation,
        this.morphTargets = t.morphTargets,
        this
    }
    ;
    const Ko = new Gt
      , $o = new Ht
      , ts = new Ot
      , es = new ft;
    function ns(t=new hn, e=new Qo) {
        pe.call(this),
        this.type = "Points",
        this.geometry = t,
        this.material = e,
        this.updateMorphTargets()
    }
    function is(t, e, n, i, r, o, s) {
        const a = $o.distanceSqToPoint(t);
        if (a < n) {
            const n = new ft;
            $o.closestPointToPoint(t, n),
            n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far)
                return;
            o.push({
                distance: l,
                distanceToRay: Math.sqrt(a),
                point: n,
                index: e,
                face: null,
                object: s
            })
        }
    }
    function rs(t, e, n, i, r, o, s, a, l) {
        lt.call(this, t, e, n, i, r, o, s, a, l),
        this.format = void 0 !== s ? s : F,
        this.minFilter = void 0 !== o ? o : D,
        this.magFilter = void 0 !== r ? r : D,
        this.generateMipmaps = !1;
        const c = this;
        "requestVideoFrameCallback"in t && t.requestVideoFrameCallback((function e() {
            c.needsUpdate = !0,
            t.requestVideoFrameCallback(e)
        }
        ))
    }
    function os(t, e, n, i, r, o, s, a, l, c, u, h) {
        lt.call(this, null, o, s, a, l, c, i, r, u, h),
        this.image = {
            width: e,
            height: n
        },
        this.mipmaps = t,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    function ss(t, e, n, i, r, o, s, a, l) {
        lt.call(this, t, e, n, i, r, o, s, a, l),
        this.needsUpdate = !0
    }
    function as(t, e, n, i, r, o, s, a, l, c) {
        if ((c = void 0 !== c ? c : I) !== I && c !== B)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && c === I && (n = C),
        void 0 === n && c === B && (n = O),
        lt.call(this, null, i, r, o, s, a, c, n, l),
        this.image = {
            width: t,
            height: e
        },
        this.magFilter = void 0 !== s ? s : M,
        this.minFilter = void 0 !== a ? a : M,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
    ns.prototype = Object.assign(Object.create(pe.prototype), {
        constructor: ns,
        isPoints: !0,
        copy: function(t) {
            return pe.prototype.copy.call(this, t),
            this.material = t.material,
            this.geometry = t.geometry,
            this
        },
        raycast: function(t, e) {
            const n = this.geometry
              , i = this.matrixWorld
              , r = t.params.Points.threshold;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            ts.copy(n.boundingSphere),
            ts.applyMatrix4(i),
            ts.radius += r,
            !1 === t.ray.intersectsSphere(ts))
                return;
            Ko.copy(i).invert(),
            $o.copy(t.ray).applyMatrix4(Ko);
            const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , s = o * o;
            if (n.isBufferGeometry) {
                const r = n.index
                  , o = n.attributes.position;
                if (null !== r) {
                    const n = r.array;
                    for (let r = 0, a = n.length; r < a; r++) {
                        const a = n[r];
                        es.fromBufferAttribute(o, a),
                        is(es, a, s, i, t, e, this)
                    }
                } else
                    for (let n = 0, r = o.count; n < r; n++)
                        es.fromBufferAttribute(o, n),
                        is(es, n, s, i, t, e, this)
            } else {
                const r = n.vertices;
                for (let n = 0, o = r.length; n < o; n++)
                    is(r[n], n, s, i, t, e, this)
            }
        },
        updateMorphTargets: function() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
                const e = t.morphAttributes
                  , n = Object.keys(e);
                if (n.length > 0) {
                    const t = e[n[0]];
                    if (void 0 !== t) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                    }
                }
            } else {
                const e = t.morphTargets;
                void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    }),
    rs.prototype = Object.assign(Object.create(lt.prototype), {
        constructor: rs,
        clone: function() {
            return new this.constructor(this.image).copy(this)
        },
        isVideoTexture: !0,
        update: function() {
            const t = this.image;
            !1 === "requestVideoFrameCallback"in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    os.prototype = Object.create(lt.prototype),
    os.prototype.constructor = os,
    os.prototype.isCompressedTexture = !0,
    ss.prototype = Object.create(lt.prototype),
    ss.prototype.constructor = ss,
    ss.prototype.isCanvasTexture = !0,
    as.prototype = Object.create(lt.prototype),
    as.prototype.constructor = as,
    as.prototype.isDepthTexture = !0;
    let ls = 0;
    const cs = new Gt
      , us = new pe
      , hs = new ft;
    function ds() {
        Object.defineProperty(this, "id", {
            value: ls += 2
        }),
        this.uuid = nt.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.elementsNeedUpdate = !1,
        this.verticesNeedUpdate = !1,
        this.uvsNeedUpdate = !1,
        this.normalsNeedUpdate = !1,
        this.colorsNeedUpdate = !1,
        this.lineDistancesNeedUpdate = !1,
        this.groupsNeedUpdate = !1
    }
    ds.prototype = Object.assign(Object.create($.prototype), {
        constructor: ds,
        isGeometry: !0,
        applyMatrix4: function(t) {
            const e = (new rt).getNormalMatrix(t);
            for (let e = 0, n = this.vertices.length; e < n; e++) {
                this.vertices[e].applyMatrix4(t)
            }
            for (let t = 0, n = this.faces.length; t < n; t++) {
                const n = this.faces[t];
                n.normal.applyMatrix3(e).normalize();
                for (let t = 0, i = n.vertexNormals.length; t < i; t++)
                    n.vertexNormals[t].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.verticesNeedUpdate = !0,
            this.normalsNeedUpdate = !0,
            this
        },
        rotateX: function(t) {
            return cs.makeRotationX(t),
            this.applyMatrix4(cs),
            this
        },
        rotateY: function(t) {
            return cs.makeRotationY(t),
            this.applyMatrix4(cs),
            this
        },
        rotateZ: function(t) {
            return cs.makeRotationZ(t),
            this.applyMatrix4(cs),
            this
        },
        translate: function(t, e, n) {
            return cs.makeTranslation(t, e, n),
            this.applyMatrix4(cs),
            this
        },
        scale: function(t, e, n) {
            return cs.makeScale(t, e, n),
            this.applyMatrix4(cs),
            this
        },
        lookAt: function(t) {
            return us.lookAt(t),
            us.updateMatrix(),
            this.applyMatrix4(us.matrix),
            this
        },
        fromBufferGeometry: function(t) {
            const e = this
              , n = null !== t.index ? t.index : void 0
              , i = t.attributes;
            if (void 0 === i.position)
                return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),
                this;
            const r = i.position
              , o = i.normal
              , s = i.color
              , a = i.uv
              , l = i.uv2;
            void 0 !== l && (this.faceVertexUvs[1] = []);
            for (let t = 0; t < r.count; t++)
                e.vertices.push((new ft).fromBufferAttribute(r, t)),
                void 0 !== s && e.colors.push((new Ne).fromBufferAttribute(s, t));
            function c(t, n, i, r) {
                const c = void 0 === s ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()]
                  , u = void 0 === o ? [] : [(new ft).fromBufferAttribute(o, t), (new ft).fromBufferAttribute(o, n), (new ft).fromBufferAttribute(o, i)]
                  , h = new Ie(t,n,i,u,c,r);
                e.faces.push(h),
                void 0 !== a && e.faceVertexUvs[0].push([(new it).fromBufferAttribute(a, t), (new it).fromBufferAttribute(a, n), (new it).fromBufferAttribute(a, i)]),
                void 0 !== l && e.faceVertexUvs[1].push([(new it).fromBufferAttribute(l, t), (new it).fromBufferAttribute(l, n), (new it).fromBufferAttribute(l, i)])
            }
            const u = t.groups;
            if (u.length > 0)
                for (let t = 0; t < u.length; t++) {
                    const e = u[t]
                      , i = e.start;
                    for (let t = i, r = i + e.count; t < r; t += 3)
                        void 0 !== n ? c(n.getX(t), n.getX(t + 1), n.getX(t + 2), e.materialIndex) : c(t, t + 1, t + 2, e.materialIndex)
                }
            else if (void 0 !== n)
                for (let t = 0; t < n.count; t += 3)
                    c(n.getX(t), n.getX(t + 1), n.getX(t + 2));
            else
                for (let t = 0; t < r.count; t += 3)
                    c(t, t + 1, t + 2);
            return this.computeFaceNormals(),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            this
        },
        center: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(hs).negate(),
            this.translate(hs.x, hs.y, hs.z),
            this
        },
        normalize: function() {
            this.computeBoundingSphere();
            const t = this.boundingSphere.center
              , e = this.boundingSphere.radius
              , n = 0 === e ? 1 : 1 / e
              , i = new Gt;
            return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1),
            this.applyMatrix4(i),
            this
        },
        computeFaceNormals: function() {
            const t = new ft
              , e = new ft;
            for (let n = 0, i = this.faces.length; n < i; n++) {
                const i = this.faces[n]
                  , r = this.vertices[i.a]
                  , o = this.vertices[i.b]
                  , s = this.vertices[i.c];
                t.subVectors(s, o),
                e.subVectors(r, o),
                t.cross(e),
                t.normalize(),
                i.normal.copy(t)
            }
        },
        computeVertexNormals: function(t=!0) {
            const e = new Array(this.vertices.length);
            for (let t = 0, n = this.vertices.length; t < n; t++)
                e[t] = new ft;
            if (t) {
                const t = new ft
                  , n = new ft;
                for (let i = 0, r = this.faces.length; i < r; i++) {
                    const r = this.faces[i]
                      , o = this.vertices[r.a]
                      , s = this.vertices[r.b]
                      , a = this.vertices[r.c];
                    t.subVectors(a, s),
                    n.subVectors(o, s),
                    t.cross(n),
                    e[r.a].add(t),
                    e[r.b].add(t),
                    e[r.c].add(t)
                }
            } else {
                this.computeFaceNormals();
                for (let t = 0, n = this.faces.length; t < n; t++) {
                    const n = this.faces[t];
                    e[n.a].add(n.normal),
                    e[n.b].add(n.normal),
                    e[n.c].add(n.normal)
                }
            }
            for (let t = 0, n = this.vertices.length; t < n; t++)
                e[t].normalize();
            for (let t = 0, n = this.faces.length; t < n; t++) {
                const n = this.faces[t]
                  , i = n.vertexNormals;
                3 === i.length ? (i[0].copy(e[n.a]),
                i[1].copy(e[n.b]),
                i[2].copy(e[n.c])) : (i[0] = e[n.a].clone(),
                i[1] = e[n.b].clone(),
                i[2] = e[n.c].clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            this.computeFaceNormals();
            for (let t = 0, e = this.faces.length; t < e; t++) {
                const e = this.faces[t]
                  , n = e.vertexNormals;
                3 === n.length ? (n[0].copy(e.normal),
                n[1].copy(e.normal),
                n[2].copy(e.normal)) : (n[0] = e.normal.clone(),
                n[1] = e.normal.clone(),
                n[2] = e.normal.clone())
            }
            this.faces.length > 0 && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            for (let t = 0, e = this.faces.length; t < e; t++) {
                const e = this.faces[t];
                e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(),
                e.__originalVertexNormals || (e.__originalVertexNormals = []);
                for (let t = 0, n = e.vertexNormals.length; t < n; t++)
                    e.__originalVertexNormals[t] ? e.__originalVertexNormals[t].copy(e.vertexNormals[t]) : e.__originalVertexNormals[t] = e.vertexNormals[t].clone()
            }
            const t = new ds;
            t.faces = this.faces;
            for (let e = 0, n = this.morphTargets.length; e < n; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {},
                    this.morphNormals[e].faceNormals = [],
                    this.morphNormals[e].vertexNormals = [];
                    const t = this.morphNormals[e].faceNormals
                      , n = this.morphNormals[e].vertexNormals;
                    for (let e = 0, i = this.faces.length; e < i; e++) {
                        const e = new ft
                          , i = {
                            a: new ft,
                            b: new ft,
                            c: new ft
                        };
                        t.push(e),
                        n.push(i)
                    }
                }
                const n = this.morphNormals[e];
                t.vertices = this.morphTargets[e].vertices,
                t.computeFaceNormals(),
                t.computeVertexNormals();
                for (let t = 0, e = this.faces.length; t < e; t++) {
                    const e = this.faces[t]
                      , i = n.faceNormals[t]
                      , r = n.vertexNormals[t];
                    i.copy(e.normal),
                    r.a.copy(e.vertexNormals[0]),
                    r.b.copy(e.vertexNormals[1]),
                    r.c.copy(e.vertexNormals[2])
                }
            }
            for (let t = 0, e = this.faces.length; t < e; t++) {
                const e = this.faces[t];
                e.normal = e.__originalFaceNormal,
                e.vertexNormals = e.__originalVertexNormals
            }
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new vt),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new Ot),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(t, e, n=0) {
            if (!t || !t.isGeometry)
                return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
            let i;
            const r = this.vertices.length
              , o = this.vertices
              , s = t.vertices
              , a = this.faces
              , l = t.faces
              , c = this.colors
              , u = t.colors;
            void 0 !== e && (i = (new rt).getNormalMatrix(e));
            for (let t = 0, n = s.length; t < n; t++) {
                const n = s[t].clone();
                void 0 !== e && n.applyMatrix4(e),
                o.push(n)
            }
            for (let t = 0, e = u.length; t < e; t++)
                c.push(u[t].clone());
            for (let t = 0, e = l.length; t < e; t++) {
                const e = l[t];
                let o, s;
                const c = e.vertexNormals
                  , u = e.vertexColors
                  , h = new Ie(e.a + r,e.b + r,e.c + r);
                h.normal.copy(e.normal),
                void 0 !== i && h.normal.applyMatrix3(i).normalize();
                for (let t = 0, e = c.length; t < e; t++)
                    o = c[t].clone(),
                    void 0 !== i && o.applyMatrix3(i).normalize(),
                    h.vertexNormals.push(o);
                h.color.copy(e.color);
                for (let t = 0, e = u.length; t < e; t++)
                    s = u[t],
                    h.vertexColors.push(s.clone());
                h.materialIndex = e.materialIndex + n,
                a.push(h)
            }
            for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                const n = t.faceVertexUvs[e];
                void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t]
                      , r = [];
                    for (let t = 0, e = i.length; t < e; t++)
                        r.push(i[t].clone());
                    this.faceVertexUvs[e].push(r)
                }
            }
        },
        mergeMesh: function(t) {
            t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(),
            this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
        },
        mergeVertices: function(t=4) {
            const e = {}
              , n = []
              , i = []
              , r = Math.pow(10, t);
            for (let t = 0, o = this.vertices.length; t < o; t++) {
                const o = this.vertices[t]
                  , s = Math.round(o.x * r) + "_" + Math.round(o.y * r) + "_" + Math.round(o.z * r);
                void 0 === e[s] ? (e[s] = t,
                n.push(this.vertices[t]),
                i[t] = n.length - 1) : i[t] = i[e[s]]
            }
            const o = [];
            for (let t = 0, e = this.faces.length; t < e; t++) {
                const e = this.faces[t];
                e.a = i[e.a],
                e.b = i[e.b],
                e.c = i[e.c];
                const n = [e.a, e.b, e.c];
                for (let e = 0; e < 3; e++)
                    if (n[e] === n[(e + 1) % 3]) {
                        o.push(t);
                        break
                    }
            }
            for (let t = o.length - 1; t >= 0; t--) {
                const e = o[t];
                this.faces.splice(e, 1);
                for (let t = 0, n = this.faceVertexUvs.length; t < n; t++)
                    this.faceVertexUvs[t].splice(e, 1)
            }
            const s = this.vertices.length - n.length;
            return this.vertices = n,
            s
        },
        setFromPoints: function(t) {
            this.vertices = [];
            for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                this.vertices.push(new ft(n.x,n.y,n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            const t = this.faces
              , e = t.length;
            for (let n = 0; n < e; n++)
                t[n]._id = n;
            t.sort((function(t, e) {
                return t.materialIndex - e.materialIndex
            }
            ));
            const n = this.faceVertexUvs[0]
              , i = this.faceVertexUvs[1];
            let r, o;
            n && n.length === e && (r = []),
            i && i.length === e && (o = []);
            for (let s = 0; s < e; s++) {
                const e = t[s]._id;
                r && r.push(n[e]),
                o && o.push(i[e])
            }
            r && (this.faceVertexUvs[0] = r),
            o && (this.faceVertexUvs[1] = o)
        },
        toJSON: function() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (t.uuid = this.uuid,
            t.type = this.type,
            "" !== this.name && (t.name = this.name),
            void 0 !== this.parameters) {
                const e = this.parameters;
                for (const n in e)
                    void 0 !== e[n] && (t[n] = e[n]);
                return t
            }
            const e = [];
            for (let t = 0; t < this.vertices.length; t++) {
                const n = this.vertices[t];
                e.push(n.x, n.y, n.z)
            }
            const n = []
              , i = []
              , r = {}
              , o = []
              , s = {}
              , a = []
              , l = {};
            for (let t = 0; t < this.faces.length; t++) {
                const e = this.faces[t]
                  , i = !0
                  , r = !1
                  , o = void 0 !== this.faceVertexUvs[0][t]
                  , s = e.normal.length() > 0
                  , a = e.vertexNormals.length > 0
                  , l = 1 !== e.color.r || 1 !== e.color.g || 1 !== e.color.b
                  , p = e.vertexColors.length > 0;
                let f = 0;
                if (f = c(f, 0, 0),
                f = c(f, 1, i),
                f = c(f, 2, r),
                f = c(f, 3, o),
                f = c(f, 4, s),
                f = c(f, 5, a),
                f = c(f, 6, l),
                f = c(f, 7, p),
                n.push(f),
                n.push(e.a, e.b, e.c),
                n.push(e.materialIndex),
                o) {
                    const e = this.faceVertexUvs[0][t];
                    n.push(d(e[0]), d(e[1]), d(e[2]))
                }
                if (s && n.push(u(e.normal)),
                a) {
                    const t = e.vertexNormals;
                    n.push(u(t[0]), u(t[1]), u(t[2]))
                }
                if (l && n.push(h(e.color)),
                p) {
                    const t = e.vertexColors;
                    n.push(h(t[0]), h(t[1]), h(t[2]))
                }
            }
            function c(t, e, n) {
                return n ? t | 1 << e : t & ~(1 << e)
            }
            function u(t) {
                const e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== r[e] || (r[e] = i.length / 3,
                i.push(t.x, t.y, t.z)),
                r[e]
            }
            function h(t) {
                const e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== s[e] || (s[e] = o.length,
                o.push(t.getHex())),
                s[e]
            }
            function d(t) {
                const e = t.x.toString() + t.y.toString();
                return void 0 !== l[e] || (l[e] = a.length / 2,
                a.push(t.x, t.y)),
                l[e]
            }
            return t.data = {},
            t.data.vertices = e,
            t.data.normals = i,
            o.length > 0 && (t.data.colors = o),
            a.length > 0 && (t.data.uvs = [a]),
            t.data.faces = n,
            t
        },
        clone: function() {
            return (new ds).copy(this)
        },
        copy: function(t) {
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.name = t.name;
            const e = t.vertices;
            for (let t = 0, n = e.length; t < n; t++)
                this.vertices.push(e[t].clone());
            const n = t.colors;
            for (let t = 0, e = n.length; t < e; t++)
                this.colors.push(n[t].clone());
            const i = t.faces;
            for (let t = 0, e = i.length; t < e; t++)
                this.faces.push(i[t].clone());
            for (let e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                const n = t.faceVertexUvs[e];
                void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
                for (let t = 0, i = n.length; t < i; t++) {
                    const i = n[t]
                      , r = [];
                    for (let t = 0, e = i.length; t < e; t++) {
                        const e = i[t];
                        r.push(e.clone())
                    }
                    this.faceVertexUvs[e].push(r)
                }
            }
            const r = t.morphTargets;
            for (let t = 0, e = r.length; t < e; t++) {
                const e = {};
                if (e.name = r[t].name,
                void 0 !== r[t].vertices) {
                    e.vertices = [];
                    for (let n = 0, i = r[t].vertices.length; n < i; n++)
                        e.vertices.push(r[t].vertices[n].clone())
                }
                if (void 0 !== r[t].normals) {
                    e.normals = [];
                    for (let n = 0, i = r[t].normals.length; n < i; n++)
                        e.normals.push(r[t].normals[n].clone())
                }
                this.morphTargets.push(e)
            }
            const o = t.morphNormals;
            for (let t = 0, e = o.length; t < e; t++) {
                const e = {};
                if (void 0 !== o[t].vertexNormals) {
                    e.vertexNormals = [];
                    for (let n = 0, i = o[t].vertexNormals.length; n < i; n++) {
                        const i = o[t].vertexNormals[n]
                          , r = {};
                        r.a = i.a.clone(),
                        r.b = i.b.clone(),
                        r.c = i.c.clone(),
                        e.vertexNormals.push(r)
                    }
                }
                if (void 0 !== o[t].faceNormals) {
                    e.faceNormals = [];
                    for (let n = 0, i = o[t].faceNormals.length; n < i; n++)
                        e.faceNormals.push(o[t].faceNormals[n].clone())
                }
                this.morphNormals.push(e)
            }
            const s = t.skinWeights;
            for (let t = 0, e = s.length; t < e; t++)
                this.skinWeights.push(s[t].clone());
            const a = t.skinIndices;
            for (let t = 0, e = a.length; t < e; t++)
                this.skinIndices.push(a[t].clone());
            const l = t.lineDistances;
            for (let t = 0, e = l.length; t < e; t++)
                this.lineDistances.push(l[t]);
            const c = t.boundingBox;
            null !== c && (this.boundingBox = c.clone());
            const u = t.boundingSphere;
            return null !== u && (this.boundingSphere = u.clone()),
            this.elementsNeedUpdate = t.elementsNeedUpdate,
            this.verticesNeedUpdate = t.verticesNeedUpdate,
            this.uvsNeedUpdate = t.uvsNeedUpdate,
            this.normalsNeedUpdate = t.normalsNeedUpdate,
            this.colorsNeedUpdate = t.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = t.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    new ft,
    new ft,
    new ft,
    new Ae;
    const ps = function(t, e, n) {
        n = n || 2;
        const i = e && e.length
          , r = i ? e[0] * n : t.length;
        let o = fs(t, 0, r, n, !0);
        const s = [];
        if (!o || o.next === o.prev)
            return s;
        let a, l, c, u, h, d, p;
        if (i && (o = function(t, e, n, i) {
            const r = [];
            let o, s, a, l, c;
            for (o = 0,
            s = e.length; o < s; o++)
                a = e[o] * i,
                l = o < s - 1 ? e[o + 1] * i : t.length,
                c = fs(t, a, l, i, !1),
                c === c.next && (c.steiner = !0),
                r.push(Es(c));
            for (r.sort(bs),
            o = 0; o < r.length; o++)
                ws(r[o], n),
                n = ms(n, n.next);
            return n
        }(t, e, o, n)),
        t.length > 80 * n) {
            a = c = t[0],
            l = u = t[1];
            for (let e = n; e < r; e += n)
                h = t[e],
                d = t[e + 1],
                h < a && (a = h),
                d < l && (l = d),
                h > c && (c = h),
                d > u && (u = d);
            p = Math.max(c - a, u - l),
            p = 0 !== p ? 1 / p : 0
        }
        return gs(o, s, n, a, l, p),
        s
    };
    function fs(t, e, n, i, r) {
        let o, s;
        if (r === function(t, e, n, i) {
            let r = 0;
            for (let o = e, s = n - i; o < n; o += i)
                r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]),
                s = o;
            return r
        }(t, e, n, i) > 0)
            for (o = e; o < n; o += i)
                s = Ns(o, t[o], t[o + 1], s);
        else
            for (o = n - i; o >= e; o -= i)
                s = Ns(o, t[o], t[o + 1], s);
        return s && Cs(s, s.next) && (Is(s),
        s = s.next),
        s
    }
    function ms(t, e) {
        if (!t)
            return t;
        e || (e = t);
        let n, i = t;
        do {
            if (n = !1,
            i.steiner || !Cs(i, i.next) && 0 !== As(i.prev, i, i.next))
                i = i.next;
            else {
                if (Is(i),
                i = e = i.prev,
                i === i.next)
                    break;
                n = !0
            }
        } while (n || i !== e);
        return e
    }
    function gs(t, e, n, i, r, o, s) {
        if (!t)
            return;
        !s && o && function(t, e, n, i) {
            let r = t;
            do {
                null === r.z && (r.z = Ss(r.x, r.y, e, n, i)),
                r.prevZ = r.prev,
                r.nextZ = r.next,
                r = r.next
            } while (r !== t);
            r.prevZ.nextZ = null,
            r.prevZ = null,
            function(t) {
                let e, n, i, r, o, s, a, l, c = 1;
                do {
                    for (n = t,
                    t = null,
                    o = null,
                    s = 0; n; ) {
                        for (s++,
                        i = n,
                        a = 0,
                        e = 0; e < c && (a++,
                        i = i.nextZ,
                        i); e++)
                            ;
                        for (l = c; a > 0 || l > 0 && i; )
                            0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n,
                            n = n.nextZ,
                            a--) : (r = i,
                            i = i.nextZ,
                            l--),
                            o ? o.nextZ = r : t = r,
                            r.prevZ = o,
                            o = r;
                        n = i
                    }
                    o.nextZ = null,
                    c *= 2
                } while (s > 1)
            }(r)
        }(t, i, r, o);
        let a, l, c = t;
        for (; t.prev !== t.next; )
            if (a = t.prev,
            l = t.next,
            o ? ys(t, i, r, o) : vs(t))
                e.push(a.i / n),
                e.push(t.i / n),
                e.push(l.i / n),
                Is(t),
                t = l.next,
                c = l.next;
            else if ((t = l) === c) {
                s ? 1 === s ? gs(t = _s(ms(t), e, n), e, n, i, r, o, 2) : 2 === s && xs(t, e, n, i, r, o) : gs(ms(t), e, n, i, r, o, 1);
                break
            }
    }
    function vs(t) {
        const e = t.prev
          , n = t
          , i = t.next;
        if (As(e, n, i) >= 0)
            return !1;
        let r = t.next.next;
        for (; r !== t.prev; ) {
            if (Ds(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && As(r.prev, r, r.next) >= 0)
                return !1;
            r = r.next
        }
        return !0
    }
    function ys(t, e, n, i) {
        const r = t.prev
          , o = t
          , s = t.next;
        if (As(r, o, s) >= 0)
            return !1;
        const a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x
          , l = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y
          , c = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x
          , u = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y
          , h = Ss(a, l, e, n, i)
          , d = Ss(c, u, e, n, i);
        let p = t.prevZ
          , f = t.nextZ;
        for (; p && p.z >= h && f && f.z <= d; ) {
            if (p !== t.prev && p !== t.next && Ds(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && As(p.prev, p, p.next) >= 0)
                return !1;
            if (p = p.prevZ,
            f !== t.prev && f !== t.next && Ds(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && As(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        for (; p && p.z >= h; ) {
            if (p !== t.prev && p !== t.next && Ds(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && As(p.prev, p, p.next) >= 0)
                return !1;
            p = p.prevZ
        }
        for (; f && f.z <= d; ) {
            if (f !== t.prev && f !== t.next && Ds(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && As(f.prev, f, f.next) >= 0)
                return !1;
            f = f.nextZ
        }
        return !0
    }
    function _s(t, e, n) {
        let i = t;
        do {
            const r = i.prev
              , o = i.next.next;
            !Cs(r, o) && Ls(r, i, i.next, o) && Os(r, o) && Os(o, r) && (e.push(r.i / n),
            e.push(i.i / n),
            e.push(o.i / n),
            Is(i),
            Is(i.next),
            i = t = o),
            i = i.next
        } while (i !== t);
        return ms(i)
    }
    function xs(t, e, n, i, r, o) {
        let s = t;
        do {
            let t = s.next.next;
            for (; t !== s.prev; ) {
                if (s.i !== t.i && Ts(s, t)) {
                    let a = Fs(s, t);
                    return s = ms(s, s.next),
                    a = ms(a, a.next),
                    gs(s, e, n, i, r, o),
                    void gs(a, e, n, i, r, o)
                }
                t = t.next
            }
            s = s.next
        } while (s !== t)
    }
    function bs(t, e) {
        return t.x - e.x
    }
    function ws(t, e) {
        if (e = function(t, e) {
            let n = e;
            const i = t.x
              , r = t.y;
            let o, s = -1 / 0;
            do {
                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                    const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    if (t <= i && t > s) {
                        if (s = t,
                        t === i) {
                            if (r === n.y)
                                return n;
                            if (r === n.next.y)
                                return n.next
                        }
                        o = n.x < n.next.x ? n : n.next
                    }
                }
                n = n.next
            } while (n !== e);
            if (!o)
                return null;
            if (i === s)
                return o;
            const a = o
              , l = o.x
              , c = o.y;
            let u, h = 1 / 0;
            n = o;
            do {
                i >= n.x && n.x >= l && i !== n.x && Ds(r < c ? i : s, r, l, c, r < c ? s : i, r, n.x, n.y) && (u = Math.abs(r - n.y) / (i - n.x),
                Os(n, t) && (u < h || u === h && (n.x > o.x || n.x === o.x && Ms(o, n))) && (o = n,
                h = u)),
                n = n.next
            } while (n !== a);
            return o
        }(t, e)) {
            const n = Fs(e, t);
            ms(e, e.next),
            ms(n, n.next)
        }
    }
    function Ms(t, e) {
        return As(t.prev, t, e.prev) < 0 && As(e.next, t, t.next) < 0
    }
    function Ss(t, e, n, i, r) {
        return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }
    function Es(t) {
        let e = t
          , n = t;
        do {
            (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e),
            e = e.next
        } while (e !== t);
        return n
    }
    function Ds(t, e, n, i, r, o, s, a) {
        return (r - s) * (e - a) - (t - s) * (o - a) >= 0 && (t - s) * (i - a) - (n - s) * (e - a) >= 0 && (n - s) * (o - a) - (r - s) * (i - a) >= 0
    }
    function Ts(t, e) {
        return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
            let n = t;
            do {
                if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Ls(n, n.next, t, e))
                    return !0;
                n = n.next
            } while (n !== t);
            return !1
        }(t, e) && (Os(t, e) && Os(e, t) && function(t, e) {
            let n = t
              , i = !1;
            const r = (t.x + e.x) / 2
              , o = (t.y + e.y) / 2;
            do {
                n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                n = n.next
            } while (n !== t);
            return i
        }(t, e) && (As(t.prev, t, e.prev) || As(t, e.prev, e)) || Cs(t, e) && As(t.prev, t, t.next) > 0 && As(e.prev, e, e.next) > 0)
    }
    function As(t, e, n) {
        return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }
    function Cs(t, e) {
        return t.x === e.x && t.y === e.y
    }
    function Ls(t, e, n, i) {
        const r = Rs(As(t, e, n))
          , o = Rs(As(t, e, i))
          , s = Rs(As(n, i, t))
          , a = Rs(As(n, i, e));
        return r !== o && s !== a || (!(0 !== r || !Ps(t, n, e)) || (!(0 !== o || !Ps(t, i, e)) || (!(0 !== s || !Ps(n, t, i)) || !(0 !== a || !Ps(n, e, i)))))
    }
    function Ps(t, e, n) {
        return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
    }
    function Rs(t) {
        return t > 0 ? 1 : t < 0 ? -1 : 0
    }
    function Os(t, e) {
        return As(t.prev, t, t.next) < 0 ? As(t, e, t.next) >= 0 && As(t, t.prev, e) >= 0 : As(t, e, t.prev) < 0 || As(t, t.next, e) < 0
    }
    function Fs(t, e) {
        const n = new Bs(t.i,t.x,t.y)
          , i = new Bs(e.i,e.x,e.y)
          , r = t.next
          , o = e.prev;
        return t.next = e,
        e.prev = t,
        n.next = r,
        r.prev = n,
        i.next = n,
        n.prev = i,
        o.next = i,
        i.prev = o,
        i
    }
    function Ns(t, e, n, i) {
        const r = new Bs(t,e,n);
        return i ? (r.next = i.next,
        r.prev = i,
        i.next.prev = r,
        i.next = r) : (r.prev = r,
        r.next = r),
        r
    }
    function Is(t) {
        t.next.prev = t.prev,
        t.prev.next = t.next,
        t.prevZ && (t.prevZ.nextZ = t.nextZ),
        t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }
    function Bs(t, e, n) {
        this.i = t,
        this.x = e,
        this.y = n,
        this.prev = null,
        this.next = null,
        this.z = null,
        this.prevZ = null,
        this.nextZ = null,
        this.steiner = !1
    }
    const ks = {
        area: function(t) {
            const e = t.length;
            let n = 0;
            for (let i = e - 1, r = 0; r < e; i = r++)
                n += t[i].x * t[r].y - t[r].x * t[i].y;
            return .5 * n
        },
        isClockWise: function(t) {
            return ks.area(t) < 0
        },
        triangulateShape: function(t, e) {
            const n = []
              , i = []
              , r = [];
            zs(t),
            Us(n, t);
            let o = t.length;
            e.forEach(zs);
            for (let t = 0; t < e.length; t++)
                i.push(o),
                o += e[t].length,
                Us(n, e[t]);
            const s = ps(n, i);
            for (let t = 0; t < s.length; t += 3)
                r.push(s.slice(t, t + 3));
            return r
        }
    };
    function zs(t) {
        const e = t.length;
        e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }
    function Us(t, e) {
        for (let n = 0; n < e.length; n++)
            t.push(e[n].x),
            t.push(e[n].y)
    }
    class Hs extends hn {
        constructor(t, e) {
            super(),
            this.type = "ExtrudeBufferGeometry",
            this.parameters = {
                shapes: t,
                options: e
            },
            t = Array.isArray(t) ? t : [t];
            const n = this
              , i = []
              , r = [];
            for (let e = 0, n = t.length; e < n; e++) {
                o(t[e])
            }
            function o(t) {
                const o = []
                  , s = void 0 !== e.curveSegments ? e.curveSegments : 12
                  , a = void 0 !== e.steps ? e.steps : 1;
                let l = void 0 !== e.depth ? e.depth : 100
                  , c = void 0 === e.bevelEnabled || e.bevelEnabled
                  , u = void 0 !== e.bevelThickness ? e.bevelThickness : 6
                  , h = void 0 !== e.bevelSize ? e.bevelSize : u - 2
                  , d = void 0 !== e.bevelOffset ? e.bevelOffset : 0
                  , p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                const f = e.extrudePath
                  , m = void 0 !== e.UVGenerator ? e.UVGenerator : Gs;
                void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
                l = e.amount);
                let g, v, y, _, x, b = !1;
                f && (g = f.getSpacedPoints(a),
                b = !0,
                c = !1,
                v = f.computeFrenetFrames(a, !1),
                y = new ft,
                _ = new ft,
                x = new ft),
                c || (p = 0,
                u = 0,
                h = 0,
                d = 0);
                const w = t.extractPoints(s);
                let M = w.shape;
                const S = w.holes;
                if (!ks.isClockWise(M)) {
                    M = M.reverse();
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        ks.isClockWise(e) && (S[t] = e.reverse())
                    }
                }
                const E = ks.triangulateShape(M, S)
                  , D = M;
                for (let t = 0, e = S.length; t < e; t++) {
                    const e = S[t];
                    M = M.concat(e)
                }
                function T(t, e, n) {
                    return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                    e.clone().multiplyScalar(n).add(t)
                }
                const A = M.length
                  , C = E.length;
                function L(t, e, n) {
                    let i, r, o;
                    const s = t.x - e.x
                      , a = t.y - e.y
                      , l = n.x - t.x
                      , c = n.y - t.y
                      , u = s * s + a * a
                      , h = s * c - a * l;
                    if (Math.abs(h) > Number.EPSILON) {
                        const h = Math.sqrt(u)
                          , d = Math.sqrt(l * l + c * c)
                          , p = e.x - a / h
                          , f = e.y + s / h
                          , m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (s * c - a * l);
                        i = p + s * m - t.x,
                        r = f + a * m - t.y;
                        const g = i * i + r * r;
                        if (g <= 2)
                            return new it(i,r);
                        o = Math.sqrt(g / 2)
                    } else {
                        let t = !1;
                        s > Number.EPSILON ? l > Number.EPSILON && (t = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0),
                        t ? (i = -a,
                        r = s,
                        o = Math.sqrt(u)) : (i = s,
                        r = a,
                        o = Math.sqrt(u / 2))
                    }
                    return new it(i / o,r / o)
                }
                const P = [];
                for (let t = 0, e = D.length, n = e - 1, i = t + 1; t < e; t++,
                n++,
                i++)
                    n === e && (n = 0),
                    i === e && (i = 0),
                    P[t] = L(D[t], D[n], D[i]);
                const R = [];
                let O, F = P.concat();
                for (let t = 0, e = S.length; t < e; t++) {
                    const e = S[t];
                    O = [];
                    for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++,
                    i++,
                    r++)
                        i === n && (i = 0),
                        r === n && (r = 0),
                        O[t] = L(e[t], e[i], e[r]);
                    R.push(O),
                    F = F.concat(O)
                }
                for (let t = 0; t < p; t++) {
                    const e = t / p
                      , n = u * Math.cos(e * Math.PI / 2)
                      , i = h * Math.sin(e * Math.PI / 2) + d;
                    for (let t = 0, e = D.length; t < e; t++) {
                        const e = T(D[t], P[t], i);
                        B(e.x, e.y, -n)
                    }
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        O = R[t];
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = T(e[t], O[t], i);
                            B(r.x, r.y, -n)
                        }
                    }
                }
                const N = h + d;
                for (let t = 0; t < A; t++) {
                    const e = c ? T(M[t], F[t], N) : M[t];
                    b ? (_.copy(v.normals[0]).multiplyScalar(e.x),
                    y.copy(v.binormals[0]).multiplyScalar(e.y),
                    x.copy(g[0]).add(_).add(y),
                    B(x.x, x.y, x.z)) : B(e.x, e.y, 0)
                }
                for (let t = 1; t <= a; t++)
                    for (let e = 0; e < A; e++) {
                        const n = c ? T(M[e], F[e], N) : M[e];
                        b ? (_.copy(v.normals[t]).multiplyScalar(n.x),
                        y.copy(v.binormals[t]).multiplyScalar(n.y),
                        x.copy(g[t]).add(_).add(y),
                        B(x.x, x.y, x.z)) : B(n.x, n.y, l / a * t)
                    }
                for (let t = p - 1; t >= 0; t--) {
                    const e = t / p
                      , n = u * Math.cos(e * Math.PI / 2)
                      , i = h * Math.sin(e * Math.PI / 2) + d;
                    for (let t = 0, e = D.length; t < e; t++) {
                        const e = T(D[t], P[t], i);
                        B(e.x, e.y, l + n)
                    }
                    for (let t = 0, e = S.length; t < e; t++) {
                        const e = S[t];
                        O = R[t];
                        for (let t = 0, r = e.length; t < r; t++) {
                            const r = T(e[t], O[t], i);
                            b ? B(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : B(r.x, r.y, l + n)
                        }
                    }
                }
                function I(t, e) {
                    let n = t.length;
                    for (; --n >= 0; ) {
                        const i = n;
                        let r = n - 1;
                        r < 0 && (r = t.length - 1);
                        for (let t = 0, n = a + 2 * p; t < n; t++) {
                            const n = A * t
                              , o = A * (t + 1);
                            z(e + i + n, e + r + n, e + r + o, e + i + o)
                        }
                    }
                }
                function B(t, e, n) {
                    o.push(t),
                    o.push(e),
                    o.push(n)
                }
                function k(t, e, r) {
                    U(t),
                    U(e),
                    U(r);
                    const o = i.length / 3
                      , s = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
                    H(s[0]),
                    H(s[1]),
                    H(s[2])
                }
                function z(t, e, r, o) {
                    U(t),
                    U(e),
                    U(o),
                    U(e),
                    U(r),
                    U(o);
                    const s = i.length / 3
                      , a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
                    H(a[0]),
                    H(a[1]),
                    H(a[3]),
                    H(a[1]),
                    H(a[2]),
                    H(a[3])
                }
                function U(t) {
                    i.push(o[3 * t + 0]),
                    i.push(o[3 * t + 1]),
                    i.push(o[3 * t + 2])
                }
                function H(t) {
                    r.push(t.x),
                    r.push(t.y)
                }
                !function() {
                    const t = i.length / 3;
                    if (c) {
                        let t = 0
                          , e = A * t;
                        for (let t = 0; t < C; t++) {
                            const n = E[t];
                            k(n[2] + e, n[1] + e, n[0] + e)
                        }
                        t = a + 2 * p,
                        e = A * t;
                        for (let t = 0; t < C; t++) {
                            const n = E[t];
                            k(n[0] + e, n[1] + e, n[2] + e)
                        }
                    } else {
                        for (let t = 0; t < C; t++) {
                            const e = E[t];
                            k(e[2], e[1], e[0])
                        }
                        for (let t = 0; t < C; t++) {
                            const e = E[t];
                            k(e[0] + A * a, e[1] + A * a, e[2] + A * a)
                        }
                    }
                    n.addGroup(t, i.length / 3 - t, 0)
                }(),
                function() {
                    const t = i.length / 3;
                    let e = 0;
                    I(D, e),
                    e += D.length;
                    for (let t = 0, n = S.length; t < n; t++) {
                        const n = S[t];
                        I(n, e),
                        e += n.length
                    }
                    n.addGroup(t, i.length / 3 - t, 1)
                }()
            }
            this.setAttribute("position", new Qe(i,3)),
            this.setAttribute("uv", new Qe(r,2)),
            this.computeVertexNormals()
        }
        toJSON() {
            const t = hn.prototype.toJSON.call(this);
            return function(t, e, n) {
                if (n.shapes = [],
                Array.isArray(t))
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e];
                        n.shapes.push(i.uuid)
                    }
                else
                    n.shapes.push(t.uuid);
                void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
                return n
            }(this.parameters.shapes, this.parameters.options, t)
        }
    }
    const Gs = {
        generateTopUV: function(t, e, n, i, r) {
            const o = e[3 * n]
              , s = e[3 * n + 1]
              , a = e[3 * i]
              , l = e[3 * i + 1]
              , c = e[3 * r]
              , u = e[3 * r + 1];
            return [new it(o,s), new it(a,l), new it(c,u)]
        },
        generateSideWallUV: function(t, e, n, i, r, o) {
            const s = e[3 * n]
              , a = e[3 * n + 1]
              , l = e[3 * n + 2]
              , c = e[3 * i]
              , u = e[3 * i + 1]
              , h = e[3 * i + 2]
              , d = e[3 * r]
              , p = e[3 * r + 1]
              , f = e[3 * r + 2]
              , m = e[3 * o]
              , g = e[3 * o + 1]
              , v = e[3 * o + 2];
            return Math.abs(a - u) < .01 ? [new it(s,1 - l), new it(c,1 - h), new it(d,1 - f), new it(m,1 - v)] : [new it(a,1 - l), new it(u,1 - h), new it(p,1 - f), new it(g,1 - v)]
        }
    };
    class Vs extends ds {
        constructor(t, e) {
            super(),
            this.type = "ExtrudeGeometry",
            this.parameters = {
                shapes: t,
                options: e
            },
            this.fromBufferGeometry(new Hs(t,e)),
            this.mergeVertices()
        }
        toJSON() {
            const t = super.toJSON();
            return function(t, e, n) {
                if (n.shapes = [],
                Array.isArray(t))
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e];
                        n.shapes.push(i.uuid)
                    }
                else
                    n.shapes.push(t.uuid);
                void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
                return n
            }(this.parameters.shapes, this.parameters.options, t)
        }
    }
    function js(t, e, n) {
        hn.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: t,
            slices: e,
            stacks: n
        };
        const i = []
          , r = []
          , o = []
          , s = []
          , a = 1e-5
          , l = new ft
          , c = new ft
          , u = new ft
          , h = new ft
          , d = new ft;
        t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        const p = e + 1;
        for (let i = 0; i <= n; i++) {
            const p = i / n;
            for (let n = 0; n <= e; n++) {
                const i = n / e;
                t(i, p, c),
                r.push(c.x, c.y, c.z),
                i - a >= 0 ? (t(i - a, p, u),
                h.subVectors(c, u)) : (t(i + a, p, u),
                h.subVectors(u, c)),
                p - a >= 0 ? (t(i, p - a, u),
                d.subVectors(c, u)) : (t(i, p + a, u),
                d.subVectors(u, c)),
                l.crossVectors(h, d).normalize(),
                o.push(l.x, l.y, l.z),
                s.push(i, p)
            }
        }
        for (let t = 0; t < n; t++)
            for (let n = 0; n < e; n++) {
                const e = t * p + n
                  , r = t * p + n + 1
                  , o = (t + 1) * p + n + 1
                  , s = (t + 1) * p + n;
                i.push(e, r, s),
                i.push(r, o, s)
            }
        this.setIndex(i),
        this.setAttribute("position", new Qe(r,3)),
        this.setAttribute("normal", new Qe(o,3)),
        this.setAttribute("uv", new Qe(s,2))
    }
    function Ws(t, e, n) {
        ds.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: t,
            slices: e,
            stacks: n
        },
        this.fromBufferGeometry(new js(t,e,n)),
        this.mergeVertices()
    }
    js.prototype = Object.create(hn.prototype),
    js.prototype.constructor = js,
    Ws.prototype = Object.create(ds.prototype),
    Ws.prototype.constructor = Ws;
    class qs extends hn {
        constructor(t, e=12) {
            super(),
            this.type = "ShapeBufferGeometry",
            this.parameters = {
                shapes: t,
                curveSegments: e
            };
            const n = []
              , i = []
              , r = []
              , o = [];
            let s = 0
              , a = 0;
            if (!1 === Array.isArray(t))
                l(t);
            else
                for (let e = 0; e < t.length; e++)
                    l(t[e]),
                    this.addGroup(s, a, e),
                    s += a,
                    a = 0;
            function l(t) {
                const s = i.length / 3
                  , l = t.extractPoints(e);
                let c = l.shape;
                const u = l.holes;
                !1 === ks.isClockWise(c) && (c = c.reverse());
                for (let t = 0, e = u.length; t < e; t++) {
                    const e = u[t];
                    !0 === ks.isClockWise(e) && (u[t] = e.reverse())
                }
                const h = ks.triangulateShape(c, u);
                for (let t = 0, e = u.length; t < e; t++) {
                    const e = u[t];
                    c = c.concat(e)
                }
                for (let t = 0, e = c.length; t < e; t++) {
                    const e = c[t];
                    i.push(e.x, e.y, 0),
                    r.push(0, 0, 1),
                    o.push(e.x, e.y)
                }
                for (let t = 0, e = h.length; t < e; t++) {
                    const e = h[t]
                      , i = e[0] + s
                      , r = e[1] + s
                      , o = e[2] + s;
                    n.push(i, r, o),
                    a += 3
                }
            }
            this.setIndex(n),
            this.setAttribute("position", new Qe(i,3)),
            this.setAttribute("normal", new Qe(r,3)),
            this.setAttribute("uv", new Qe(o,2))
        }
        toJSON() {
            const t = hn.prototype.toJSON.call(this);
            return function(t, e) {
                if (e.shapes = [],
                Array.isArray(t))
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        e.shapes.push(i.uuid)
                    }
                else
                    e.shapes.push(t.uuid);
                return e
            }(this.parameters.shapes, t)
        }
    }
    class Xs extends ds {
        constructor(t, e) {
            super(),
            this.type = "ShapeGeometry",
            "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
            e = e.curveSegments),
            this.parameters = {
                shapes: t,
                curveSegments: e
            },
            this.fromBufferGeometry(new qs(t,e)),
            this.mergeVertices()
        }
        toJSON() {
            const t = ds.prototype.toJSON.call(this);
            return function(t, e) {
                if (e.shapes = [],
                Array.isArray(t))
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        e.shapes.push(i.uuid)
                    }
                else
                    e.shapes.push(t.uuid);
                return e
            }(this.parameters.shapes, t)
        }
    }
    function Ys(t) {
        ke.call(this),
        this.type = "ShadowMaterial",
        this.color = new Ne(0),
        this.transparent = !0,
        this.setValues(t)
    }
    function Zs(t) {
        In.call(this, t),
        this.type = "RawShaderMaterial"
    }
    function Js(t) {
        ke.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new Ne(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ne(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.vertexTangents = !1,
        this.setValues(t)
    }
    function Qs(t) {
        Js.call(this),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoat = 0,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new it(1,1),
        this.clearcoatNormalMap = null,
        this.reflectivity = .5,
        Object.defineProperty(this, "ior", {
            get: function() {
                return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
            },
            set: function(t) {
                this.reflectivity = nt.clamp(2.5 * (t - 1) / (t + 1), 0, 1)
            }
        }),
        this.sheen = null,
        this.transmission = 0,
        this.transmissionMap = null,
        this.setValues(t)
    }
    function Ks(t) {
        ke.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new Ne(16777215),
        this.specular = new Ne(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ne(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function $s(t) {
        ke.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ne(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function ta(t) {
        ke.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function ea(t) {
        ke.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new Ne(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new Ne(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function na(t) {
        ke.call(this),
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new Ne(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new it(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.setValues(t)
    }
    function ia(t) {
        Uo.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(t)
    }
    Ys.prototype = Object.create(ke.prototype),
    Ys.prototype.constructor = Ys,
    Ys.prototype.isShadowMaterial = !0,
    Ys.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this
    }
    ,
    Zs.prototype = Object.create(In.prototype),
    Zs.prototype.constructor = Zs,
    Zs.prototype.isRawShaderMaterial = !0,
    Js.prototype = Object.create(ke.prototype),
    Js.prototype.constructor = Js,
    Js.prototype.isMeshStandardMaterial = !0,
    Js.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(t.color),
        this.roughness = t.roughness,
        this.metalness = t.metalness,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.roughnessMap = t.roughnessMap,
        this.metalnessMap = t.metalnessMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.envMapIntensity = t.envMapIntensity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this.vertexTangents = t.vertexTangents,
        this
    }
    ,
    Qs.prototype = Object.create(Js.prototype),
    Qs.prototype.constructor = Qs,
    Qs.prototype.isMeshPhysicalMaterial = !0,
    Qs.prototype.copy = function(t) {
        return Js.prototype.copy.call(this, t),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = t.clearcoat,
        this.clearcoatMap = t.clearcoatMap,
        this.clearcoatRoughness = t.clearcoatRoughness,
        this.clearcoatRoughnessMap = t.clearcoatRoughnessMap,
        this.clearcoatNormalMap = t.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
        this.reflectivity = t.reflectivity,
        t.sheen ? this.sheen = (this.sheen || new Ne).copy(t.sheen) : this.sheen = null,
        this.transmission = t.transmission,
        this.transmissionMap = t.transmissionMap,
        this
    }
    ,
    Ks.prototype = Object.create(ke.prototype),
    Ks.prototype.constructor = Ks,
    Ks.prototype.isMeshPhongMaterial = !0,
    Ks.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        this.shininess = t.shininess,
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    $s.prototype = Object.create(ke.prototype),
    $s.prototype.constructor = $s,
    $s.prototype.isMeshToonMaterial = !0,
    $s.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.gradientMap = t.gradientMap,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.alphaMap = t.alphaMap,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    ta.prototype = Object.create(ke.prototype),
    ta.prototype.constructor = ta,
    ta.prototype.isMeshNormalMaterial = !0,
    ta.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    ea.prototype = Object.create(ke.prototype),
    ea.prototype.constructor = ea,
    ea.prototype.isMeshLambertMaterial = !0,
    ea.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    na.prototype = Object.create(ke.prototype),
    na.prototype.constructor = na,
    na.prototype.isMeshMatcapMaterial = !0,
    na.prototype.copy = function(t) {
        return ke.prototype.copy.call(this, t),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(t.color),
        this.matcap = t.matcap,
        this.map = t.map,
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalMapType = t.normalMapType,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.alphaMap = t.alphaMap,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
    ,
    ia.prototype = Object.create(Uo.prototype),
    ia.prototype.constructor = ia,
    ia.prototype.isLineDashedMaterial = !0,
    ia.prototype.copy = function(t) {
        return Uo.prototype.copy.call(this, t),
        this.scale = t.scale,
        this.dashSize = t.dashSize,
        this.gapSize = t.gapSize,
        this
    }
    ;
    var ra = Object.freeze({
        __proto__: null,
        ShadowMaterial: Ys,
        SpriteMaterial: oo,
        RawShaderMaterial: Zs,
        ShaderMaterial: In,
        PointsMaterial: Qo,
        MeshPhysicalMaterial: Qs,
        MeshStandardMaterial: Js,
        MeshPhongMaterial: Ks,
        MeshToonMaterial: $s,
        MeshNormalMaterial: ta,
        MeshLambertMaterial: ea,
        MeshDepthMaterial: Gr,
        MeshDistanceMaterial: Vr,
        MeshBasicMaterial: ze,
        MeshMatcapMaterial: na,
        LineDashedMaterial: ia,
        LineBasicMaterial: Uo,
        Material: ke
    });
    const oa = {
        arraySlice: function(t, e, n) {
            return oa.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
        },
        convertArray: function(t, e, n) {
            return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        },
        isTypedArray: function(t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        },
        getKeyframeOrder: function(t) {
            const e = t.length
              , n = new Array(e);
            for (let t = 0; t !== e; ++t)
                n[t] = t;
            return n.sort((function(e, n) {
                return t[e] - t[n]
            }
            )),
            n
        },
        sortedArray: function(t, e, n) {
            const i = t.length
              , r = new t.constructor(i);
            for (let o = 0, s = 0; s !== i; ++o) {
                const i = n[o] * e;
                for (let n = 0; n !== e; ++n)
                    r[s++] = t[i + n]
            }
            return r
        },
        flattenJSON: function(t, e, n, i) {
            let r = 1
              , o = t[0];
            for (; void 0 !== o && void 0 === o[i]; )
                o = t[r++];
            if (void 0 === o)
                return;
            let s = o[i];
            if (void 0 !== s)
                if (Array.isArray(s))
                    do {
                        s = o[i],
                        void 0 !== s && (e.push(o.time),
                        n.push.apply(n, s)),
                        o = t[r++]
                    } while (void 0 !== o);
                else if (void 0 !== s.toArray)
                    do {
                        s = o[i],
                        void 0 !== s && (e.push(o.time),
                        s.toArray(n, n.length)),
                        o = t[r++]
                    } while (void 0 !== o);
                else
                    do {
                        s = o[i],
                        void 0 !== s && (e.push(o.time),
                        n.push(s)),
                        o = t[r++]
                    } while (void 0 !== o)
        },
        subclip: function(t, e, n, i, r=30) {
            const o = t.clone();
            o.name = e;
            const s = [];
            for (let t = 0; t < o.tracks.length; ++t) {
                const e = o.tracks[t]
                  , a = e.getValueSize()
                  , l = []
                  , c = [];
                for (let t = 0; t < e.times.length; ++t) {
                    const o = e.times[t] * r;
                    if (!(o < n || o >= i)) {
                        l.push(e.times[t]);
                        for (let n = 0; n < a; ++n)
                            c.push(e.values[t * a + n])
                    }
                }
                0 !== l.length && (e.times = oa.convertArray(l, e.times.constructor),
                e.values = oa.convertArray(c, e.values.constructor),
                s.push(e))
            }
            o.tracks = s;
            let a = 1 / 0;
            for (let t = 0; t < o.tracks.length; ++t)
                a > o.tracks[t].times[0] && (a = o.tracks[t].times[0]);
            for (let t = 0; t < o.tracks.length; ++t)
                o.tracks[t].shift(-1 * a);
            return o.resetDuration(),
            o
        },
        makeClipAdditive: function(t, e=0, n=t, i=30) {
            i <= 0 && (i = 30);
            const r = n.tracks.length
              , o = e / i;
            for (let e = 0; e < r; ++e) {
                const i = n.tracks[e]
                  , r = i.ValueTypeName;
                if ("bool" === r || "string" === r)
                    continue;
                const s = t.tracks.find((function(t) {
                    return t.name === i.name && t.ValueTypeName === r
                }
                ));
                if (void 0 === s)
                    continue;
                let a = 0;
                const l = i.getValueSize();
                i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                let c = 0;
                const u = s.getValueSize();
                s.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                const h = i.times.length - 1;
                let d;
                if (o <= i.times[0]) {
                    const t = a
                      , e = l - a;
                    d = oa.arraySlice(i.values, t, e)
                } else if (o >= i.times[h]) {
                    const t = h * l + a
                      , e = t + l - a;
                    d = oa.arraySlice(i.values, t, e)
                } else {
                    const t = i.createInterpolant()
                      , e = a
                      , n = l - a;
                    t.evaluate(o),
                    d = oa.arraySlice(t.resultBuffer, e, n)
                }
                if ("quaternion" === r) {
                    (new pt).fromArray(d).normalize().conjugate().toArray(d)
                }
                const p = s.times.length;
                for (let t = 0; t < p; ++t) {
                    const e = t * u + c;
                    if ("quaternion" === r)
                        pt.multiplyQuaternionsFlat(s.values, e, d, 0, s.values, e);
                    else {
                        const t = u - 2 * c;
                        for (let n = 0; n < t; ++n)
                            s.values[e + n] -= d[n]
                    }
                }
            }
            return t.blendMode = 2501,
            t
        }
    };
    function sa(t, e, n, i) {
        this.parameterPositions = t,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== i ? i : new e.constructor(n),
        this.sampleValues = e,
        this.valueSize = n
    }
    function aa(t, e, n, i) {
        sa.call(this, t, e, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0
    }
    function la(t, e, n, i) {
        sa.call(this, t, e, n, i)
    }
    function ca(t, e, n, i) {
        sa.call(this, t, e, n, i)
    }
    function ua(t, e, n, i) {
        if (void 0 === t)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t,
        this.times = oa.convertArray(e, this.TimeBufferType),
        this.values = oa.convertArray(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    function ha(t, e, n) {
        ua.call(this, t, e, n)
    }
    function da(t, e, n, i) {
        ua.call(this, t, e, n, i)
    }
    function pa(t, e, n, i) {
        ua.call(this, t, e, n, i)
    }
    function fa(t, e, n, i) {
        sa.call(this, t, e, n, i)
    }
    function ma(t, e, n, i) {
        ua.call(this, t, e, n, i)
    }
    function ga(t, e, n, i) {
        ua.call(this, t, e, n, i)
    }
    function va(t, e, n, i) {
        ua.call(this, t, e, n, i)
    }
    function ya(t, e=-1, n, i=2500) {
        this.name = t,
        this.tracks = n,
        this.duration = e,
        this.blendMode = i,
        this.uuid = nt.generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    function _a(t) {
        if (void 0 === t.type)
            throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = function(t) {
            switch (t.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return pa;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return va;
            case "color":
                return da;
            case "quaternion":
                return ma;
            case "bool":
            case "boolean":
                return ha;
            case "string":
                return ga
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
        }(t.type);
        if (void 0 === t.times) {
            const e = []
              , n = [];
            oa.flattenJSON(t.keys, e, n, "value"),
            t.times = e,
            t.values = n
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name,t.times,t.values,t.interpolation)
    }
    Object.assign(sa.prototype, {
        evaluate: function(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex
              , i = e[n]
              , r = e[n - 1];
            t: {
                e: {
                    let o;
                    n: {
                        i: if (!(t < i)) {
                            for (let o = n + 2; ; ) {
                                if (void 0 === i) {
                                    if (t < r)
                                        break i;
                                    return n = e.length,
                                    this._cachedIndex = n,
                                    this.afterEnd_(n - 1, t, r)
                                }
                                if (n === o)
                                    break;
                                if (r = i,
                                i = e[++n],
                                t < i)
                                    break e
                            }
                            o = e.length;
                            break n
                        }
                        if (t >= r)
                            break t;
                        {
                            const s = e[1];
                            t < s && (n = 2,
                            r = s);
                            for (let o = n - 2; ; ) {
                                if (void 0 === r)
                                    return this._cachedIndex = 0,
                                    this.beforeStart_(0, t, i);
                                if (n === o)
                                    break;
                                if (i = r,
                                r = e[--n - 1],
                                t >= r)
                                    break e
                            }
                            o = n,
                            n = 0
                        }
                    }
                    for (; n < o; ) {
                        const i = n + o >>> 1;
                        t < e[i] ? o = i : n = i + 1
                    }
                    if (i = e[n],
                    r = e[n - 1],
                    void 0 === r)
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, t, i);
                    if (void 0 === i)
                        return n = e.length,
                        this._cachedIndex = n,
                        this.afterEnd_(n - 1, r, t)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, t, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(t) {
            const e = this.resultBuffer
              , n = this.sampleValues
              , i = this.valueSize
              , r = t * i;
            for (let t = 0; t !== i; ++t)
                e[t] = n[r + t];
            return e
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    Object.assign(sa.prototype, {
        beforeStart_: sa.prototype.copySampleValue_,
        afterEnd_: sa.prototype.copySampleValue_
    }),
    aa.prototype = Object.assign(Object.create(sa.prototype), {
        constructor: aa,
        DefaultSettings_: {
            endingStart: H,
            endingEnd: H
        },
        intervalChanged_: function(t, e, n) {
            const i = this.parameterPositions;
            let r = t - 2
              , o = t + 1
              , s = i[r]
              , a = i[o];
            if (void 0 === s)
                switch (this.getSettings_().endingStart) {
                case G:
                    r = t,
                    s = 2 * e - n;
                    break;
                case V:
                    r = i.length - 2,
                    s = e + i[r] - i[r + 1];
                    break;
                default:
                    r = t,
                    s = n
                }
            if (void 0 === a)
                switch (this.getSettings_().endingEnd) {
                case G:
                    o = t,
                    a = 2 * n - e;
                    break;
                case V:
                    o = 1,
                    a = n + i[1] - i[0];
                    break;
                default:
                    o = t - 1,
                    a = e
                }
            const l = .5 * (n - e)
              , c = this.valueSize;
            this._weightPrev = l / (e - s),
            this._weightNext = l / (a - n),
            this._offsetPrev = r * c,
            this._offsetNext = o * c
        },
        interpolate_: function(t, e, n, i) {
            const r = this.resultBuffer
              , o = this.sampleValues
              , s = this.valueSize
              , a = t * s
              , l = a - s
              , c = this._offsetPrev
              , u = this._offsetNext
              , h = this._weightPrev
              , d = this._weightNext
              , p = (n - e) / (i - e)
              , f = p * p
              , m = f * p
              , g = -h * m + 2 * h * f - h * p
              , v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1
              , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
              , _ = d * m - d * f;
            for (let t = 0; t !== s; ++t)
                r[t] = g * o[c + t] + v * o[l + t] + y * o[a + t] + _ * o[u + t];
            return r
        }
    }),
    la.prototype = Object.assign(Object.create(sa.prototype), {
        constructor: la,
        interpolate_: function(t, e, n, i) {
            const r = this.resultBuffer
              , o = this.sampleValues
              , s = this.valueSize
              , a = t * s
              , l = a - s
              , c = (n - e) / (i - e)
              , u = 1 - c;
            for (let t = 0; t !== s; ++t)
                r[t] = o[l + t] * u + o[a + t] * c;
            return r
        }
    }),
    ca.prototype = Object.assign(Object.create(sa.prototype), {
        constructor: ca,
        interpolate_: function(t) {
            return this.copySampleValue_(t - 1)
        }
    }),
    Object.assign(ua, {
        toJSON: function(t) {
            const e = t.constructor;
            let n;
            if (void 0 !== e.toJSON)
                n = e.toJSON(t);
            else {
                n = {
                    name: t.name,
                    times: oa.convertArray(t.times, Array),
                    values: oa.convertArray(t.values, Array)
                };
                const e = t.getInterpolation();
                e !== t.DefaultInterpolation && (n.interpolation = e)
            }
            return n.type = t.ValueTypeName,
            n
        }
    }),
    Object.assign(ua.prototype, {
        constructor: ua,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: z,
        InterpolantFactoryMethodDiscrete: function(t) {
            return new ca(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodLinear: function(t) {
            return new la(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: function(t) {
            return new aa(this.times,this.values,this.getValueSize(),t)
        },
        setInterpolation: function(t) {
            let e;
            switch (t) {
            case k:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case z:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case U:
                e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                if (void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation)
                        throw new Error(e);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", e),
                this
            }
            return this.createInterpolant = e,
            this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return k;
            case this.InterpolantFactoryMethodLinear:
                return z;
            case this.InterpolantFactoryMethodSmooth:
                return U
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(t) {
            if (0 !== t) {
                const e = this.times;
                for (let n = 0, i = e.length; n !== i; ++n)
                    e[n] += t
            }
            return this
        },
        scale: function(t) {
            if (1 !== t) {
                const e = this.times;
                for (let n = 0, i = e.length; n !== i; ++n)
                    e[n] *= t
            }
            return this
        },
        trim: function(t, e) {
            const n = this.times
              , i = n.length;
            let r = 0
              , o = i - 1;
            for (; r !== i && n[r] < t; )
                ++r;
            for (; -1 !== o && n[o] > e; )
                --o;
            if (++o,
            0 !== r || o !== i) {
                r >= o && (o = Math.max(o, 1),
                r = o - 1);
                const t = this.getValueSize();
                this.times = oa.arraySlice(n, r, o),
                this.values = oa.arraySlice(this.values, r * t, o * t)
            }
            return this
        },
        validate: function() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            t = !1);
            const n = this.times
              , i = this.values
              , r = n.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            t = !1);
            let o = null;
            for (let e = 0; e !== r; e++) {
                const i = n[e];
                if ("number" == typeof i && isNaN(i)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i),
                    t = !1;
                    break
                }
                if (null !== o && o > i) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, o),
                    t = !1;
                    break
                }
                o = i
            }
            if (void 0 !== i && oa.isTypedArray(i))
                for (let e = 0, n = i.length; e !== n; ++e) {
                    const n = i[e];
                    if (isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n),
                        t = !1;
                        break
                    }
                }
            return t
        },
        optimize: function() {
            const t = oa.arraySlice(this.times)
              , e = oa.arraySlice(this.values)
              , n = this.getValueSize()
              , i = this.getInterpolation() === U
              , r = t.length - 1;
            let o = 1;
            for (let s = 1; s < r; ++s) {
                let r = !1;
                const a = t[s];
                if (a !== t[s + 1] && (1 !== s || a !== a[0]))
                    if (i)
                        r = !0;
                    else {
                        const t = s * n
                          , i = t - n
                          , o = t + n;
                        for (let s = 0; s !== n; ++s) {
                            const n = e[t + s];
                            if (n !== e[i + s] || n !== e[o + s]) {
                                r = !0;
                                break
                            }
                        }
                    }
                if (r) {
                    if (s !== o) {
                        t[o] = t[s];
                        const i = s * n
                          , r = o * n;
                        for (let t = 0; t !== n; ++t)
                            e[r + t] = e[i + t]
                    }
                    ++o
                }
            }
            if (r > 0) {
                t[o] = t[r];
                for (let t = r * n, i = o * n, s = 0; s !== n; ++s)
                    e[i + s] = e[t + s];
                ++o
            }
            return o !== t.length ? (this.times = oa.arraySlice(t, 0, o),
            this.values = oa.arraySlice(e, 0, o * n)) : (this.times = t,
            this.values = e),
            this
        },
        clone: function() {
            const t = oa.arraySlice(this.times, 0)
              , e = oa.arraySlice(this.values, 0)
              , n = new (0,
            this.constructor)(this.name,t,e);
            return n.createInterpolant = this.createInterpolant,
            n
        }
    }),
    ha.prototype = Object.assign(Object.create(ua.prototype), {
        constructor: ha,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: k,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    da.prototype = Object.assign(Object.create(ua.prototype), {
        constructor: da,
        ValueTypeName: "color"
    }),
    pa.prototype = Object.assign(Object.create(ua.prototype), {
        constructor: pa,
        ValueTypeName: "number"
    }),
    fa.prototype = Object.assign(Object.create(sa.prototype), {
        constructor: fa,
        interpolate_: function(t, e, n, i) {
            const r = this.resultBuffer
              , o = this.sampleValues
              , s = this.valueSize
              , a = (n - e) / (i - e);
            let l = t * s;
            for (let t = l + s; l !== t; l += 4)
                pt.slerpFlat(r, 0, o, l - s, o, l, a);
            return r
        }
    }),
    ma.prototype = Object.assign(Object.create(ua.prototype), {
        constructor: ma,
        ValueTypeName: "quaternion",
        DefaultInterpolation: z,
        InterpolantFactoryMethodLinear: function(t) {
            return new fa(this.times,this.values,this.getValueSize(),t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    ga.prototype = Object.assign(Object.create(ua.prototype), {
        constructor: ga,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: k,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    va.prototype = Object.assign(Object.create(ua.prototype), {
        constructor: va,
        ValueTypeName: "vector"
    }),
    Object.assign(ya, {
        parse: function(t) {
            const e = []
              , n = t.tracks
              , i = 1 / (t.fps || 1);
            for (let t = 0, r = n.length; t !== r; ++t)
                e.push(_a(n[t]).scale(i));
            const r = new ya(t.name,t.duration,e,t.blendMode);
            return r.uuid = t.uuid,
            r
        },
        toJSON: function(t) {
            const e = []
              , n = t.tracks
              , i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode
            };
            for (let t = 0, i = n.length; t !== i; ++t)
                e.push(ua.toJSON(n[t]));
            return i
        },
        CreateFromMorphTargetSequence: function(t, e, n, i) {
            const r = e.length
              , o = [];
            for (let t = 0; t < r; t++) {
                let s = []
                  , a = [];
                s.push((t + r - 1) % r, t, (t + 1) % r),
                a.push(0, 1, 0);
                const l = oa.getKeyframeOrder(s);
                s = oa.sortedArray(s, 1, l),
                a = oa.sortedArray(a, 1, l),
                i || 0 !== s[0] || (s.push(r),
                a.push(a[0])),
                o.push(new pa(".morphTargetInfluences[" + e[t].name + "]",s,a).scale(1 / n))
            }
            return new ya(t,-1,o)
        },
        findByName: function(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
                const e = t;
                n = e.geometry && e.geometry.animations || e.animations
            }
            for (let t = 0; t < n.length; t++)
                if (n[t].name === e)
                    return n[t];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(t, e, n) {
            const i = {}
              , r = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e]
                  , o = n.name.match(r);
                if (o && o.length > 1) {
                    const t = o[1];
                    let e = i[t];
                    e || (i[t] = e = []),
                    e.push(n)
                }
            }
            const o = [];
            for (const t in i)
                o.push(ya.CreateFromMorphTargetSequence(t, i[t], e, n));
            return o
        },
        parseAnimation: function(t, e) {
            if (!t)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            const n = function(t, e, n, i, r) {
                if (0 !== n.length) {
                    const o = []
                      , s = [];
                    oa.flattenJSON(n, o, s, i),
                    0 !== o.length && r.push(new t(e,o,s))
                }
            }
              , i = []
              , r = t.name || "default"
              , o = t.fps || 30
              , s = t.blendMode;
            let a = t.length || -1;
            const l = t.hierarchy || [];
            for (let t = 0; t < l.length; t++) {
                const r = l[t].keys;
                if (r && 0 !== r.length)
                    if (r[0].morphTargets) {
                        const t = {};
                        let e;
                        for (e = 0; e < r.length; e++)
                            if (r[e].morphTargets)
                                for (let n = 0; n < r[e].morphTargets.length; n++)
                                    t[r[e].morphTargets[n]] = -1;
                        for (const n in t) {
                            const t = []
                              , o = [];
                            for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                const i = r[e];
                                t.push(i.time),
                                o.push(i.morphTarget === n ? 1 : 0)
                            }
                            i.push(new pa(".morphTargetInfluence[" + n + "]",t,o))
                        }
                        a = t.length * (o || 1)
                    } else {
                        const o = ".bones[" + e[t].name + "]";
                        n(va, o + ".position", r, "pos", i),
                        n(ma, o + ".quaternion", r, "rot", i),
                        n(va, o + ".scale", r, "scl", i)
                    }
            }
            if (0 === i.length)
                return null;
            return new ya(r,a,i,s)
        }
    }),
    Object.assign(ya.prototype, {
        resetDuration: function() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                const n = this.tracks[e];
                t = Math.max(t, n.times[n.times.length - 1])
            }
            return this.duration = t,
            this
        },
        trim: function() {
            for (let t = 0; t < this.tracks.length; t++)
                this.tracks[t].trim(0, this.duration);
            return this
        },
        validate: function() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++)
                t = t && this.tracks[e].validate();
            return t
        },
        optimize: function() {
            for (let t = 0; t < this.tracks.length; t++)
                this.tracks[t].optimize();
            return this
        },
        clone: function() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++)
                t.push(this.tracks[e].clone());
            return new ya(this.name,this.duration,t,this.blendMode)
        },
        toJSON: function() {
            return ya.toJSON(this)
        }
    });
    const xa = {
        enabled: !1,
        files: {},
        add: function(t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        },
        get: function(t) {
            if (!1 !== this.enabled)
                return this.files[t]
        },
        remove: function(t) {
            delete this.files[t]
        },
        clear: function() {
            this.files = {}
        }
    };
    function ba(t, e, n) {
        const i = this;
        let r = !1
          , o = 0
          , s = 0
          , a = void 0;
        const l = [];
        this.onStart = void 0,
        this.onLoad = t,
        this.onProgress = e,
        this.onError = n,
        this.itemStart = function(t) {
            s++,
            !1 === r && void 0 !== i.onStart && i.onStart(t, o, s),
            r = !0
        }
        ,
        this.itemEnd = function(t) {
            o++,
            void 0 !== i.onProgress && i.onProgress(t, o, s),
            o === s && (r = !1,
            void 0 !== i.onLoad && i.onLoad())
        }
        ,
        this.itemError = function(t) {
            void 0 !== i.onError && i.onError(t)
        }
        ,
        this.resolveURL = function(t) {
            return a ? a(t) : t
        }
        ,
        this.setURLModifier = function(t) {
            return a = t,
            this
        }
        ,
        this.addHandler = function(t, e) {
            return l.push(t, e),
            this
        }
        ,
        this.removeHandler = function(t) {
            const e = l.indexOf(t);
            return -1 !== e && l.splice(e, 2),
            this
        }
        ,
        this.getHandler = function(t) {
            for (let e = 0, n = l.length; e < n; e += 2) {
                const n = l[e]
                  , i = l[e + 1];
                if (n.global && (n.lastIndex = 0),
                n.test(t))
                    return i
            }
            return null
        }
    }
    const wa = new ba;
    function Ma(t) {
        this.manager = void 0 !== t ? t : wa,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    Object.assign(Ma.prototype, {
        load: function() {},
        loadAsync: function(t, e) {
            const n = this;
            return new Promise((function(i, r) {
                n.load(t, i, e, r)
            }
            ))
        },
        parse: function() {},
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        },
        setResourcePath: function(t) {
            return this.resourcePath = t,
            this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t,
            this
        }
    });
    const Sa = {};
    function Ea(t) {
        Ma.call(this, t)
    }
    function Da(t) {
        Ma.call(this, t)
    }
    function Ta(t) {
        Ma.call(this, t)
    }
    function Aa(t) {
        Ma.call(this, t)
    }
    function Ca(t) {
        Ma.call(this, t)
    }
    function La(t) {
        Ma.call(this, t)
    }
    function Pa(t) {
        Ma.call(this, t)
    }
    function Ra() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function Oa(t, e, n, i, r, o, s, a) {
        Ra.call(this),
        this.type = "EllipseCurve",
        this.aX = t || 0,
        this.aY = e || 0,
        this.xRadius = n || 1,
        this.yRadius = i || 1,
        this.aStartAngle = r || 0,
        this.aEndAngle = o || 2 * Math.PI,
        this.aClockwise = s || !1,
        this.aRotation = a || 0
    }
    function Fa(t, e, n, i, r, o) {
        Oa.call(this, t, e, n, n, i, r, o),
        this.type = "ArcCurve"
    }
    function Na() {
        let t = 0
          , e = 0
          , n = 0
          , i = 0;
        function r(r, o, s, a) {
            t = r,
            e = s,
            n = -3 * r + 3 * o - 2 * s - a,
            i = 2 * r - 2 * o + s + a
        }
        return {
            initCatmullRom: function(t, e, n, i, o) {
                r(e, n, o * (n - t), o * (i - e))
            },
            initNonuniformCatmullRom: function(t, e, n, i, o, s, a) {
                let l = (e - t) / o - (n - t) / (o + s) + (n - e) / s
                  , c = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
                l *= s,
                c *= s,
                r(e, n, l, c)
            },
            calc: function(r) {
                const o = r * r;
                return t + e * r + n * o + i * (o * r)
            }
        }
    }
    Ea.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: Ea,
        load: function(t, e, n, i) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            const r = this
              , o = xa.get(t);
            if (void 0 !== o)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(o),
                    r.manager.itemEnd(t)
                }
                ), 0),
                o;
            if (void 0 !== Sa[t])
                return void Sa[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                });
            const s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
            let a;
            if (s) {
                const n = s[1]
                  , o = !!s[2];
                let a = s[3];
                a = decodeURIComponent(a),
                o && (a = atob(a));
                try {
                    let i;
                    const o = (this.responseType || "").toLowerCase();
                    switch (o) {
                    case "arraybuffer":
                    case "blob":
                        const t = new Uint8Array(a.length);
                        for (let e = 0; e < a.length; e++)
                            t[e] = a.charCodeAt(e);
                        i = "blob" === o ? new Blob([t.buffer],{
                            type: n
                        }) : t.buffer;
                        break;
                    case "document":
                        const e = new DOMParser;
                        i = e.parseFromString(a, n);
                        break;
                    case "json":
                        i = JSON.parse(a);
                        break;
                    default:
                        i = a
                    }
                    setTimeout((function() {
                        e && e(i),
                        r.manager.itemEnd(t)
                    }
                    ), 0)
                } catch (e) {
                    setTimeout((function() {
                        i && i(e),
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                    ), 0)
                }
            } else {
                Sa[t] = [],
                Sa[t].push({
                    onLoad: e,
                    onProgress: n,
                    onError: i
                }),
                a = new XMLHttpRequest,
                a.open("GET", t, !0),
                a.addEventListener("load", (function(e) {
                    const n = this.response
                      , i = Sa[t];
                    if (delete Sa[t],
                    200 === this.status || 0 === this.status) {
                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        xa.add(t, n);
                        for (let t = 0, e = i.length; t < e; t++) {
                            const e = i[t];
                            e.onLoad && e.onLoad(n)
                        }
                        r.manager.itemEnd(t)
                    } else {
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            n.onError && n.onError(e)
                        }
                        r.manager.itemError(t),
                        r.manager.itemEnd(t)
                    }
                }
                ), !1),
                a.addEventListener("progress", (function(e) {
                    const n = Sa[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onProgress && i.onProgress(e)
                    }
                }
                ), !1),
                a.addEventListener("error", (function(e) {
                    const n = Sa[t];
                    delete Sa[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                ), !1),
                a.addEventListener("abort", (function(e) {
                    const n = Sa[t];
                    delete Sa[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        i.onError && i.onError(e)
                    }
                    r.manager.itemError(t),
                    r.manager.itemEnd(t)
                }
                ), !1),
                void 0 !== this.responseType && (a.responseType = this.responseType),
                void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials),
                a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (const t in this.requestHeader)
                    a.setRequestHeader(t, this.requestHeader[t]);
                a.send(null)
            }
            return r.manager.itemStart(t),
            a
        },
        setResponseType: function(t) {
            return this.responseType = t,
            this
        },
        setMimeType: function(t) {
            return this.mimeType = t,
            this
        }
    }),
    Da.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: Da,
        load: function(t, e, n, i) {
            const r = this
              , o = new Ea(r.manager);
            o.setPath(r.path),
            o.setRequestHeader(r.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(t, (function(n) {
                try {
                    e(r.parse(JSON.parse(n)))
                } catch (e) {
                    i ? i(e) : console.error(e),
                    r.manager.itemError(t)
                }
            }
            ), n, i)
        },
        parse: function(t) {
            const e = [];
            for (let n = 0; n < t.length; n++) {
                const i = ya.parse(t[n]);
                e.push(i)
            }
            return e
        }
    }),
    Ta.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: Ta,
        load: function(t, e, n, i) {
            const r = this
              , o = []
              , s = new os
              , a = new Ea(this.manager);
            a.setPath(this.path),
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(r.withCredentials);
            let l = 0;
            function c(c) {
                a.load(t[c], (function(t) {
                    const n = r.parse(t, !0);
                    o[c] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    },
                    l += 1,
                    6 === l && (1 === n.mipmapCount && (s.minFilter = D),
                    s.image = o,
                    s.format = n.format,
                    s.needsUpdate = !0,
                    e && e(s))
                }
                ), n, i)
            }
            if (Array.isArray(t))
                for (let e = 0, n = t.length; e < n; ++e)
                    c(e);
            else
                a.load(t, (function(t) {
                    const n = r.parse(t, !0);
                    if (n.isCubemap) {
                        const t = n.mipmaps.length / n.mipmapCount;
                        for (let e = 0; e < t; e++) {
                            o[e] = {
                                mipmaps: []
                            };
                            for (let t = 0; t < n.mipmapCount; t++)
                                o[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                                o[e].format = n.format,
                                o[e].width = n.width,
                                o[e].height = n.height
                        }
                        s.image = o
                    } else
                        s.image.width = n.width,
                        s.image.height = n.height,
                        s.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (s.minFilter = D),
                    s.format = n.format,
                    s.needsUpdate = !0,
                    e && e(s)
                }
                ), n, i);
            return s
        }
    }),
    Aa.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: Aa,
        load: function(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            const r = this
              , o = xa.get(t);
            if (void 0 !== o)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(o),
                    r.manager.itemEnd(t)
                }
                ), 0),
                o;
            const s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            function a() {
                s.removeEventListener("load", a, !1),
                s.removeEventListener("error", l, !1),
                xa.add(t, this),
                e && e(this),
                r.manager.itemEnd(t)
            }
            function l(e) {
                s.removeEventListener("load", a, !1),
                s.removeEventListener("error", l, !1),
                i && i(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
            return s.addEventListener("load", a, !1),
            s.addEventListener("error", l, !1),
            "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
            r.manager.itemStart(t),
            s.src = t,
            s
        }
    }),
    Ca.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: Ca,
        load: function(t, e, n, i) {
            const r = new Hn
              , o = new Aa(this.manager);
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path);
            let s = 0;
            function a(n) {
                o.load(t[n], (function(t) {
                    r.images[n] = t,
                    s++,
                    6 === s && (r.needsUpdate = !0,
                    e && e(r))
                }
                ), void 0, i)
            }
            for (let e = 0; e < t.length; ++e)
                a(e);
            return r
        }
    }),
    La.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: La,
        load: function(t, e, n, i) {
            const r = this
              , o = new Vn
              , s = new Ea(this.manager);
            return s.setResponseType("arraybuffer"),
            s.setRequestHeader(this.requestHeader),
            s.setPath(this.path),
            s.setWithCredentials(r.withCredentials),
            s.load(t, (function(t) {
                const n = r.parse(t);
                n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width,
                o.image.height = n.height,
                o.image.data = n.data),
                o.wrapS = void 0 !== n.wrapS ? n.wrapS : b,
                o.wrapT = void 0 !== n.wrapT ? n.wrapT : b,
                o.magFilter = void 0 !== n.magFilter ? n.magFilter : D,
                o.minFilter = void 0 !== n.minFilter ? n.minFilter : D,
                o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                void 0 !== n.format && (o.format = n.format),
                void 0 !== n.type && (o.type = n.type),
                void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps,
                o.minFilter = T),
                1 === n.mipmapCount && (o.minFilter = D),
                o.needsUpdate = !0,
                e && e(o, n))
            }
            ), n, i),
            o
        }
    }),
    Pa.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: Pa,
        load: function(t, e, n, i) {
            const r = new lt
              , o = new Aa(this.manager);
            return o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(t, (function(n) {
                r.image = n;
                const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                r.format = i ? F : N,
                r.needsUpdate = !0,
                void 0 !== e && e(r)
            }
            ), n, i),
            r
        }
    }),
    Object.assign(Ra.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        },
        getPointAt: function(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getPoint(n, e)
        },
        getPoints: function(t=5) {
            const e = [];
            for (let n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return e
        },
        getSpacedPoints: function(t=5) {
            const e = [];
            for (let n = 0; n <= t; n++)
                e.push(this.getPointAt(n / t));
            return e
        },
        getLength: function() {
            const t = this.getLengths();
            return t[t.length - 1]
        },
        getLengths: function(t) {
            if (void 0 === t && (t = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let n, i = this.getPoint(0), r = 0;
            e.push(0);
            for (let o = 1; o <= t; o++)
                n = this.getPoint(o / t),
                r += n.distanceTo(i),
                e.push(r),
                i = n;
            return this.cacheArcLengths = e,
            e
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(t, e) {
            const n = this.getLengths();
            let i = 0;
            const r = n.length;
            let o;
            o = e || t * n[r - 1];
            let s, a = 0, l = r - 1;
            for (; a <= l; )
                if (i = Math.floor(a + (l - a) / 2),
                s = n[i] - o,
                s < 0)
                    a = i + 1;
                else {
                    if (!(s > 0)) {
                        l = i;
                        break
                    }
                    l = i - 1
                }
            if (i = l,
            n[i] === o)
                return i / (r - 1);
            const c = n[i];
            return (i + (o - c) / (n[i + 1] - c)) / (r - 1)
        },
        getTangent: function(t, e) {
            const n = 1e-4;
            let i = t - n
              , r = t + n;
            i < 0 && (i = 0),
            r > 1 && (r = 1);
            const o = this.getPoint(i)
              , s = this.getPoint(r)
              , a = e || (o.isVector2 ? new it : new ft);
            return a.copy(s).sub(o).normalize(),
            a
        },
        getTangentAt: function(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getTangent(n, e)
        },
        computeFrenetFrames: function(t, e) {
            const n = new ft
              , i = []
              , r = []
              , o = []
              , s = new ft
              , a = new Gt;
            for (let e = 0; e <= t; e++) {
                const n = e / t;
                i[e] = this.getTangentAt(n, new ft),
                i[e].normalize()
            }
            r[0] = new ft,
            o[0] = new ft;
            let l = Number.MAX_VALUE;
            const c = Math.abs(i[0].x)
              , u = Math.abs(i[0].y)
              , h = Math.abs(i[0].z);
            c <= l && (l = c,
            n.set(1, 0, 0)),
            u <= l && (l = u,
            n.set(0, 1, 0)),
            h <= l && n.set(0, 0, 1),
            s.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], s),
            o[0].crossVectors(i[0], r[0]);
            for (let e = 1; e <= t; e++) {
                if (r[e] = r[e - 1].clone(),
                o[e] = o[e - 1].clone(),
                s.crossVectors(i[e - 1], i[e]),
                s.length() > Number.EPSILON) {
                    s.normalize();
                    const t = Math.acos(nt.clamp(i[e - 1].dot(i[e]), -1, 1));
                    r[e].applyMatrix4(a.makeRotationAxis(s, t))
                }
                o[e].crossVectors(i[e], r[e])
            }
            if (!0 === e) {
                let e = Math.acos(nt.clamp(r[0].dot(r[t]), -1, 1));
                e /= t,
                i[0].dot(s.crossVectors(r[0], r[t])) > 0 && (e = -e);
                for (let n = 1; n <= t; n++)
                    r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)),
                    o[n].crossVectors(i[n], r[n])
            }
            return {
                tangents: i,
                normals: r,
                binormals: o
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        },
        toJSON: function() {
            const t = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return t.arcLengthDivisions = this.arcLengthDivisions,
            t.type = this.type,
            t
        },
        fromJSON: function(t) {
            return this.arcLengthDivisions = t.arcLengthDivisions,
            this
        }
    }),
    Oa.prototype = Object.create(Ra.prototype),
    Oa.prototype.constructor = Oa,
    Oa.prototype.isEllipseCurve = !0,
    Oa.prototype.getPoint = function(t, e) {
        const n = e || new it
          , i = 2 * Math.PI;
        let r = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(r) < Number.EPSILON;
        for (; r < 0; )
            r += i;
        for (; r > i; )
            r -= i;
        r < Number.EPSILON && (r = o ? 0 : i),
        !0 !== this.aClockwise || o || (r === i ? r = -i : r -= i);
        const s = this.aStartAngle + t * r;
        let a = this.aX + this.xRadius * Math.cos(s)
          , l = this.aY + this.yRadius * Math.sin(s);
        if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation)
              , e = Math.sin(this.aRotation)
              , n = a - this.aX
              , i = l - this.aY;
            a = n * t - i * e + this.aX,
            l = n * e + i * t + this.aY
        }
        return n.set(a, l)
    }
    ,
    Oa.prototype.copy = function(t) {
        return Ra.prototype.copy.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    Oa.prototype.toJSON = function() {
        const t = Ra.prototype.toJSON.call(this);
        return t.aX = this.aX,
        t.aY = this.aY,
        t.xRadius = this.xRadius,
        t.yRadius = this.yRadius,
        t.aStartAngle = this.aStartAngle,
        t.aEndAngle = this.aEndAngle,
        t.aClockwise = this.aClockwise,
        t.aRotation = this.aRotation,
        t
    }
    ,
    Oa.prototype.fromJSON = function(t) {
        return Ra.prototype.fromJSON.call(this, t),
        this.aX = t.aX,
        this.aY = t.aY,
        this.xRadius = t.xRadius,
        this.yRadius = t.yRadius,
        this.aStartAngle = t.aStartAngle,
        this.aEndAngle = t.aEndAngle,
        this.aClockwise = t.aClockwise,
        this.aRotation = t.aRotation,
        this
    }
    ,
    Fa.prototype = Object.create(Oa.prototype),
    Fa.prototype.constructor = Fa,
    Fa.prototype.isArcCurve = !0;
    const Ia = new ft
      , Ba = new Na
      , ka = new Na
      , za = new Na;
    function Ua(t=[], e=!1, n="centripetal", i=.5) {
        Ra.call(this),
        this.type = "CatmullRomCurve3",
        this.points = t,
        this.closed = e,
        this.curveType = n,
        this.tension = i
    }
    function Ha(t, e, n, i, r) {
        const o = .5 * (i - e)
          , s = .5 * (r - n)
          , a = t * t;
        return (2 * n - 2 * i + o + s) * (t * a) + (-3 * n + 3 * i - 2 * o - s) * a + o * t + n
    }
    function Ga(t, e, n, i) {
        return function(t, e) {
            const n = 1 - t;
            return n * n * e
        }(t, e) + function(t, e) {
            return 2 * (1 - t) * t * e
        }(t, n) + function(t, e) {
            return t * t * e
        }(t, i)
    }
    function Va(t, e, n, i, r) {
        return function(t, e) {
            const n = 1 - t;
            return n * n * n * e
        }(t, e) + function(t, e) {
            const n = 1 - t;
            return 3 * n * n * t * e
        }(t, n) + function(t, e) {
            return 3 * (1 - t) * t * t * e
        }(t, i) + function(t, e) {
            return t * t * t * e
        }(t, r)
    }
    function ja(t=new it, e=new it, n=new it, i=new it) {
        Ra.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = t,
        this.v1 = e,
        this.v2 = n,
        this.v3 = i
    }
    function Wa(t=new ft, e=new ft, n=new ft, i=new ft) {
        Ra.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = t,
        this.v1 = e,
        this.v2 = n,
        this.v3 = i
    }
    function qa(t=new it, e=new it) {
        Ra.call(this),
        this.type = "LineCurve",
        this.v1 = t,
        this.v2 = e
    }
    function Xa(t=new ft, e=new ft) {
        Ra.call(this),
        this.type = "LineCurve3",
        this.v1 = t,
        this.v2 = e
    }
    function Ya(t=new it, e=new it, n=new it) {
        Ra.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = t,
        this.v1 = e,
        this.v2 = n
    }
    function Za(t=new ft, e=new ft, n=new ft) {
        Ra.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = t,
        this.v1 = e,
        this.v2 = n
    }
    function Ja(t=[]) {
        Ra.call(this),
        this.type = "SplineCurve",
        this.points = t
    }
    Ua.prototype = Object.create(Ra.prototype),
    Ua.prototype.constructor = Ua,
    Ua.prototype.isCatmullRomCurve3 = !0,
    Ua.prototype.getPoint = function(t, e=new ft) {
        const n = e
          , i = this.points
          , r = i.length
          , o = (r - (this.closed ? 0 : 1)) * t;
        let s, a, l = Math.floor(o), c = o - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2,
        c = 1),
        this.closed || l > 0 ? s = i[(l - 1) % r] : (Ia.subVectors(i[0], i[1]).add(i[0]),
        s = Ia);
        const u = i[l % r]
          , h = i[(l + 1) % r];
        if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (Ia.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
        a = Ia),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
            const t = "chordal" === this.curveType ? .5 : .25;
            let e = Math.pow(s.distanceToSquared(u), t)
              , n = Math.pow(u.distanceToSquared(h), t)
              , i = Math.pow(h.distanceToSquared(a), t);
            n < 1e-4 && (n = 1),
            e < 1e-4 && (e = n),
            i < 1e-4 && (i = n),
            Ba.initNonuniformCatmullRom(s.x, u.x, h.x, a.x, e, n, i),
            ka.initNonuniformCatmullRom(s.y, u.y, h.y, a.y, e, n, i),
            za.initNonuniformCatmullRom(s.z, u.z, h.z, a.z, e, n, i)
        } else
            "catmullrom" === this.curveType && (Ba.initCatmullRom(s.x, u.x, h.x, a.x, this.tension),
            ka.initCatmullRom(s.y, u.y, h.y, a.y, this.tension),
            za.initCatmullRom(s.z, u.z, h.z, a.z, this.tension));
        return n.set(Ba.calc(c), ka.calc(c), za.calc(c)),
        n
    }
    ,
    Ua.prototype.copy = function(t) {
        Ra.prototype.copy.call(this, t),
        this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone())
        }
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    Ua.prototype.toJSON = function() {
        const t = Ra.prototype.toJSON.call(this);
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray())
        }
        return t.closed = this.closed,
        t.curveType = this.curveType,
        t.tension = this.tension,
        t
    }
    ,
    Ua.prototype.fromJSON = function(t) {
        Ra.prototype.fromJSON.call(this, t),
        this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push((new ft).fromArray(n))
        }
        return this.closed = t.closed,
        this.curveType = t.curveType,
        this.tension = t.tension,
        this
    }
    ,
    ja.prototype = Object.create(Ra.prototype),
    ja.prototype.constructor = ja,
    ja.prototype.isCubicBezierCurve = !0,
    ja.prototype.getPoint = function(t, e=new it) {
        const n = e
          , i = this.v0
          , r = this.v1
          , o = this.v2
          , s = this.v3;
        return n.set(Va(t, i.x, r.x, o.x, s.x), Va(t, i.y, r.y, o.y, s.y)),
        n
    }
    ,
    ja.prototype.copy = function(t) {
        return Ra.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    ja.prototype.toJSON = function() {
        const t = Ra.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    ja.prototype.fromJSON = function(t) {
        return Ra.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    Wa.prototype = Object.create(Ra.prototype),
    Wa.prototype.constructor = Wa,
    Wa.prototype.isCubicBezierCurve3 = !0,
    Wa.prototype.getPoint = function(t, e=new ft) {
        const n = e
          , i = this.v0
          , r = this.v1
          , o = this.v2
          , s = this.v3;
        return n.set(Va(t, i.x, r.x, o.x, s.x), Va(t, i.y, r.y, o.y, s.y), Va(t, i.z, r.z, o.z, s.z)),
        n
    }
    ,
    Wa.prototype.copy = function(t) {
        return Ra.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
    }
    ,
    Wa.prototype.toJSON = function() {
        const t = Ra.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t.v3 = this.v3.toArray(),
        t
    }
    ,
    Wa.prototype.fromJSON = function(t) {
        return Ra.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
    }
    ,
    qa.prototype = Object.create(Ra.prototype),
    qa.prototype.constructor = qa,
    qa.prototype.isLineCurve = !0,
    qa.prototype.getPoint = function(t, e=new it) {
        const n = e;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(t).add(this.v1)),
        n
    }
    ,
    qa.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    qa.prototype.getTangent = function(t, e) {
        const n = e || new it;
        return n.copy(this.v2).sub(this.v1).normalize(),
        n
    }
    ,
    qa.prototype.copy = function(t) {
        return Ra.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    qa.prototype.toJSON = function() {
        const t = Ra.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    qa.prototype.fromJSON = function(t) {
        return Ra.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Xa.prototype = Object.create(Ra.prototype),
    Xa.prototype.constructor = Xa,
    Xa.prototype.isLineCurve3 = !0,
    Xa.prototype.getPoint = function(t, e=new ft) {
        const n = e;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(t).add(this.v1)),
        n
    }
    ,
    Xa.prototype.getPointAt = function(t, e) {
        return this.getPoint(t, e)
    }
    ,
    Xa.prototype.copy = function(t) {
        return Ra.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    Xa.prototype.toJSON = function() {
        const t = Ra.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    Xa.prototype.fromJSON = function(t) {
        return Ra.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Ya.prototype = Object.create(Ra.prototype),
    Ya.prototype.constructor = Ya,
    Ya.prototype.isQuadraticBezierCurve = !0,
    Ya.prototype.getPoint = function(t, e=new it) {
        const n = e
          , i = this.v0
          , r = this.v1
          , o = this.v2;
        return n.set(Ga(t, i.x, r.x, o.x), Ga(t, i.y, r.y, o.y)),
        n
    }
    ,
    Ya.prototype.copy = function(t) {
        return Ra.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    Ya.prototype.toJSON = function() {
        const t = Ra.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    Ya.prototype.fromJSON = function(t) {
        return Ra.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Za.prototype = Object.create(Ra.prototype),
    Za.prototype.constructor = Za,
    Za.prototype.isQuadraticBezierCurve3 = !0,
    Za.prototype.getPoint = function(t, e=new ft) {
        const n = e
          , i = this.v0
          , r = this.v1
          , o = this.v2;
        return n.set(Ga(t, i.x, r.x, o.x), Ga(t, i.y, r.y, o.y), Ga(t, i.z, r.z, o.z)),
        n
    }
    ,
    Za.prototype.copy = function(t) {
        return Ra.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
    }
    ,
    Za.prototype.toJSON = function() {
        const t = Ra.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(),
        t.v1 = this.v1.toArray(),
        t.v2 = this.v2.toArray(),
        t
    }
    ,
    Za.prototype.fromJSON = function(t) {
        return Ra.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
    }
    ,
    Ja.prototype = Object.create(Ra.prototype),
    Ja.prototype.constructor = Ja,
    Ja.prototype.isSplineCurve = !0,
    Ja.prototype.getPoint = function(t, e=new it) {
        const n = e
          , i = this.points
          , r = (i.length - 1) * t
          , o = Math.floor(r)
          , s = r - o
          , a = i[0 === o ? o : o - 1]
          , l = i[o]
          , c = i[o > i.length - 2 ? i.length - 1 : o + 1]
          , u = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return n.set(Ha(s, a.x, l.x, c.x, u.x), Ha(s, a.y, l.y, c.y, u.y)),
        n
    }
    ,
    Ja.prototype.copy = function(t) {
        Ra.prototype.copy.call(this, t),
        this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push(n.clone())
        }
        return this
    }
    ,
    Ja.prototype.toJSON = function() {
        const t = Ra.prototype.toJSON.call(this);
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
            const n = this.points[e];
            t.points.push(n.toArray())
        }
        return t
    }
    ,
    Ja.prototype.fromJSON = function(t) {
        Ra.prototype.fromJSON.call(this, t),
        this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
            const n = t.points[e];
            this.points.push((new it).fromArray(n))
        }
        return this
    }
    ;
    var Qa = Object.freeze({
        __proto__: null,
        ArcCurve: Fa,
        CatmullRomCurve3: Ua,
        CubicBezierCurve: ja,
        CubicBezierCurve3: Wa,
        EllipseCurve: Oa,
        LineCurve: qa,
        LineCurve3: Xa,
        QuadraticBezierCurve: Ya,
        QuadraticBezierCurve3: Za,
        SplineCurve: Ja
    });
    function Ka() {
        Ra.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function $a(t) {
        Ka.call(this),
        this.type = "Path",
        this.currentPoint = new it,
        t && this.setFromPoints(t)
    }
    function tl(t) {
        $a.call(this, t),
        this.uuid = nt.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function el(t, e=1) {
        pe.call(this),
        this.type = "Light",
        this.color = new Ne(t),
        this.intensity = e
    }
    function nl(t, e, n) {
        el.call(this, t, n),
        this.type = "HemisphereLight",
        this.position.copy(pe.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new Ne(e)
    }
    function il(t) {
        this.camera = t,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.mapSize = new it(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Gt,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new qn,
        this._frameExtents = new it(1,1),
        this._viewportCount = 1,
        this._viewports = [new ut(0,0,1,1)]
    }
    function rl() {
        il.call(this, new kn(50,1,.5,500)),
        this.focus = 1
    }
    function ol(t, e, n, i, r, o) {
        el.call(this, t, e),
        this.type = "SpotLight",
        this.position.copy(pe.DefaultUp),
        this.updateMatrix(),
        this.target = new pe,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.angle = void 0 !== i ? i : Math.PI / 3,
        this.penumbra = void 0 !== r ? r : 0,
        this.decay = void 0 !== o ? o : 1,
        this.shadow = new rl
    }
    function sl() {
        il.call(this, new kn(90,1,.5,500)),
        this._frameExtents = new it(4,2),
        this._viewportCount = 6,
        this._viewports = [new ut(2,1,1,1), new ut(0,1,1,1), new ut(3,1,1,1), new ut(1,1,1,1), new ut(3,0,1,1), new ut(1,0,1,1)],
        this._cubeDirections = [new ft(1,0,0), new ft(-1,0,0), new ft(0,0,1), new ft(0,0,-1), new ft(0,1,0), new ft(0,-1,0)],
        this._cubeUps = [new ft(0,1,0), new ft(0,1,0), new ft(0,1,0), new ft(0,1,0), new ft(0,0,1), new ft(0,0,-1)]
    }
    function al(t, e, n, i) {
        el.call(this, t, e),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== n ? n : 0,
        this.decay = void 0 !== i ? i : 1,
        this.shadow = new sl
    }
    function ll(t=-1, e=1, n=1, i=-1, r=.1, o=2e3) {
        Bn.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = t,
        this.right = e,
        this.top = n,
        this.bottom = i,
        this.near = r,
        this.far = o,
        this.updateProjectionMatrix()
    }
    function cl() {
        il.call(this, new ll(-5,5,5,-5,.5,500))
    }
    function ul(t, e) {
        el.call(this, t, e),
        this.type = "DirectionalLight",
        this.position.copy(pe.DefaultUp),
        this.updateMatrix(),
        this.target = new pe,
        this.shadow = new cl
    }
    function hl(t, e) {
        el.call(this, t, e),
        this.type = "AmbientLight"
    }
    function dl(t, e, n, i) {
        el.call(this, t, e),
        this.type = "RectAreaLight",
        this.width = void 0 !== n ? n : 10,
        this.height = void 0 !== i ? i : 10
    }
    Ka.prototype = Object.assign(Object.create(Ra.prototype), {
        constructor: Ka,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            const t = this.curves[0].getPoint(0)
              , e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new qa(e,t))
        },
        getPoint: function(t) {
            const e = t * this.getLength()
              , n = this.getCurveLengths();
            let i = 0;
            for (; i < n.length; ) {
                if (n[i] >= e) {
                    const t = n[i] - e
                      , r = this.curves[i]
                      , o = r.getLength()
                      , s = 0 === o ? 0 : 1 - t / o;
                    return r.getPointAt(s)
                }
                i++
            }
            return null
        },
        getLength: function() {
            const t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            const t = [];
            let e = 0;
            for (let n = 0, i = this.curves.length; n < i; n++)
                e += this.curves[n].getLength(),
                t.push(e);
            return this.cacheLengths = t,
            t
        },
        getSpacedPoints: function(t=40) {
            const e = [];
            for (let n = 0; n <= t; n++)
                e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]),
            e
        },
        getPoints: function(t=12) {
            const e = [];
            let n;
            for (let i = 0, r = this.curves; i < r.length; i++) {
                const o = r[i]
                  , s = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t
                  , a = o.getPoints(s);
                for (let t = 0; t < a.length; t++) {
                    const i = a[t];
                    n && n.equals(i) || (e.push(i),
                    n = i)
                }
            }
            return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]),
            e
        },
        copy: function(t) {
            Ra.prototype.copy.call(this, t),
            this.curves = [];
            for (let e = 0, n = t.curves.length; e < n; e++) {
                const n = t.curves[e];
                this.curves.push(n.clone())
            }
            return this.autoClose = t.autoClose,
            this
        },
        toJSON: function() {
            const t = Ra.prototype.toJSON.call(this);
            t.autoClose = this.autoClose,
            t.curves = [];
            for (let e = 0, n = this.curves.length; e < n; e++) {
                const n = this.curves[e];
                t.curves.push(n.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            Ra.prototype.fromJSON.call(this, t),
            this.autoClose = t.autoClose,
            this.curves = [];
            for (let e = 0, n = t.curves.length; e < n; e++) {
                const n = t.curves[e];
                this.curves.push((new Qa[n.type]).fromJSON(n))
            }
            return this
        }
    }),
    $a.prototype = Object.assign(Object.create(Ka.prototype), {
        constructor: $a,
        setFromPoints: function(t) {
            this.moveTo(t[0].x, t[0].y);
            for (let e = 1, n = t.length; e < n; e++)
                this.lineTo(t[e].x, t[e].y);
            return this
        },
        moveTo: function(t, e) {
            return this.currentPoint.set(t, e),
            this
        },
        lineTo: function(t, e) {
            const n = new qa(this.currentPoint.clone(),new it(t,e));
            return this.curves.push(n),
            this.currentPoint.set(t, e),
            this
        },
        quadraticCurveTo: function(t, e, n, i) {
            const r = new Ya(this.currentPoint.clone(),new it(t,e),new it(n,i));
            return this.curves.push(r),
            this.currentPoint.set(n, i),
            this
        },
        bezierCurveTo: function(t, e, n, i, r, o) {
            const s = new ja(this.currentPoint.clone(),new it(t,e),new it(n,i),new it(r,o));
            return this.curves.push(s),
            this.currentPoint.set(r, o),
            this
        },
        splineThru: function(t) {
            const e = new Ja([this.currentPoint.clone()].concat(t));
            return this.curves.push(e),
            this.currentPoint.copy(t[t.length - 1]),
            this
        },
        arc: function(t, e, n, i, r, o) {
            const s = this.currentPoint.x
              , a = this.currentPoint.y;
            return this.absarc(t + s, e + a, n, i, r, o),
            this
        },
        absarc: function(t, e, n, i, r, o) {
            return this.absellipse(t, e, n, n, i, r, o),
            this
        },
        ellipse: function(t, e, n, i, r, o, s, a) {
            const l = this.currentPoint.x
              , c = this.currentPoint.y;
            return this.absellipse(t + l, e + c, n, i, r, o, s, a),
            this
        },
        absellipse: function(t, e, n, i, r, o, s, a) {
            const l = new Oa(t,e,n,i,r,o,s,a);
            if (this.curves.length > 0) {
                const t = l.getPoint(0);
                t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
            }
            this.curves.push(l);
            const c = l.getPoint(1);
            return this.currentPoint.copy(c),
            this
        },
        copy: function(t) {
            return Ka.prototype.copy.call(this, t),
            this.currentPoint.copy(t.currentPoint),
            this
        },
        toJSON: function() {
            const t = Ka.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(),
            t
        },
        fromJSON: function(t) {
            return Ka.prototype.fromJSON.call(this, t),
            this.currentPoint.fromArray(t.currentPoint),
            this
        }
    }),
    tl.prototype = Object.assign(Object.create($a.prototype), {
        constructor: tl,
        getPointsHoles: function(t) {
            const e = [];
            for (let n = 0, i = this.holes.length; n < i; n++)
                e[n] = this.holes[n].getPoints(t);
            return e
        },
        extractPoints: function(t) {
            return {
                shape: this.getPoints(t),
                holes: this.getPointsHoles(t)
            }
        },
        copy: function(t) {
            $a.prototype.copy.call(this, t),
            this.holes = [];
            for (let e = 0, n = t.holes.length; e < n; e++) {
                const n = t.holes[e];
                this.holes.push(n.clone())
            }
            return this
        },
        toJSON: function() {
            const t = $a.prototype.toJSON.call(this);
            t.uuid = this.uuid,
            t.holes = [];
            for (let e = 0, n = this.holes.length; e < n; e++) {
                const n = this.holes[e];
                t.holes.push(n.toJSON())
            }
            return t
        },
        fromJSON: function(t) {
            $a.prototype.fromJSON.call(this, t),
            this.uuid = t.uuid,
            this.holes = [];
            for (let e = 0, n = t.holes.length; e < n; e++) {
                const n = t.holes[e];
                this.holes.push((new $a).fromJSON(n))
            }
            return this
        }
    }),
    el.prototype = Object.assign(Object.create(pe.prototype), {
        constructor: el,
        isLight: !0,
        copy: function(t) {
            return pe.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.intensity = t.intensity,
            this
        },
        toJSON: function(t) {
            const e = pe.prototype.toJSON.call(this, t);
            return e.object.color = this.color.getHex(),
            e.object.intensity = this.intensity,
            void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
        }
    }),
    nl.prototype = Object.assign(Object.create(el.prototype), {
        constructor: nl,
        isHemisphereLight: !0,
        copy: function(t) {
            return el.prototype.copy.call(this, t),
            this.groundColor.copy(t.groundColor),
            this
        }
    }),
    Object.assign(il.prototype, {
        _projScreenMatrix: new Gt,
        _lightPositionWorld: new ft,
        _lookTarget: new ft,
        getViewportCount: function() {
            return this._viewportCount
        },
        getFrustum: function() {
            return this._frustum
        },
        updateMatrices: function(t) {
            const e = this.camera
              , n = this.matrix
              , i = this._projScreenMatrix
              , r = this._lookTarget
              , o = this._lightPositionWorld;
            o.setFromMatrixPosition(t.matrixWorld),
            e.position.copy(o),
            r.setFromMatrixPosition(t.target.matrixWorld),
            e.lookAt(r),
            e.updateMatrixWorld(),
            i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(i),
            n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            n.multiply(e.projectionMatrix),
            n.multiply(e.matrixWorldInverse)
        },
        getViewport: function(t) {
            return this._viewports[t]
        },
        getFrameExtents: function() {
            return this._frameExtents
        },
        copy: function(t) {
            return this.camera = t.camera.clone(),
            this.bias = t.bias,
            this.radius = t.radius,
            this.mapSize.copy(t.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            const t = {};
            return 0 !== this.bias && (t.bias = this.bias),
            0 !== this.normalBias && (t.normalBias = this.normalBias),
            1 !== this.radius && (t.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
            t.camera = this.camera.toJSON(!1).object,
            delete t.camera.matrix,
            t
        }
    }),
    rl.prototype = Object.assign(Object.create(il.prototype), {
        constructor: rl,
        isSpotLightShadow: !0,
        updateMatrices: function(t) {
            const e = this.camera
              , n = 2 * nt.RAD2DEG * t.angle * this.focus
              , i = this.mapSize.width / this.mapSize.height
              , r = t.distance || e.far;
            n === e.fov && i === e.aspect && r === e.far || (e.fov = n,
            e.aspect = i,
            e.far = r,
            e.updateProjectionMatrix()),
            il.prototype.updateMatrices.call(this, t)
        }
    }),
    ol.prototype = Object.assign(Object.create(el.prototype), {
        constructor: ol,
        isSpotLight: !0,
        copy: function(t) {
            return el.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.angle = t.angle,
            this.penumbra = t.penumbra,
            this.decay = t.decay,
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    sl.prototype = Object.assign(Object.create(il.prototype), {
        constructor: sl,
        isPointLightShadow: !0,
        updateMatrices: function(t, e=0) {
            const n = this.camera
              , i = this.matrix
              , r = this._lightPositionWorld
              , o = this._lookTarget
              , s = this._projScreenMatrix;
            r.setFromMatrixPosition(t.matrixWorld),
            n.position.copy(r),
            o.copy(n.position),
            o.add(this._cubeDirections[e]),
            n.up.copy(this._cubeUps[e]),
            n.lookAt(o),
            n.updateMatrixWorld(),
            i.makeTranslation(-r.x, -r.y, -r.z),
            s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(s)
        }
    }),
    al.prototype = Object.assign(Object.create(el.prototype), {
        constructor: al,
        isPointLight: !0,
        copy: function(t) {
            return el.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.decay = t.decay,
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    ll.prototype = Object.assign(Object.create(Bn.prototype), {
        constructor: ll,
        isOrthographicCamera: !0,
        copy: function(t, e) {
            return Bn.prototype.copy.call(this, t, e),
            this.left = t.left,
            this.right = t.right,
            this.top = t.top,
            this.bottom = t.bottom,
            this.near = t.near,
            this.far = t.far,
            this.zoom = t.zoom,
            this.view = null === t.view ? null : Object.assign({}, t.view),
            this
        },
        setViewOffset: function(t, e, n, i, r, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = t,
            this.view.fullHeight = e,
            this.view.offsetX = n,
            this.view.offsetY = i,
            this.view.width = r,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            const t = (this.right - this.left) / (2 * this.zoom)
              , e = (this.top - this.bottom) / (2 * this.zoom)
              , n = (this.right + this.left) / 2
              , i = (this.top + this.bottom) / 2;
            let r = n - t
              , o = n + t
              , s = i + e
              , a = i - e;
            if (null !== this.view && this.view.enabled) {
                const t = (this.right - this.left) / this.view.fullWidth / this.zoom
                  , e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                r += t * this.view.offsetX,
                o = r + t * this.view.width,
                s -= e * this.view.offsetY,
                a = s - e * this.view.height
            }
            this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        },
        toJSON: function(t) {
            const e = pe.prototype.toJSON.call(this, t);
            return e.object.zoom = this.zoom,
            e.object.left = this.left,
            e.object.right = this.right,
            e.object.top = this.top,
            e.object.bottom = this.bottom,
            e.object.near = this.near,
            e.object.far = this.far,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e
        }
    }),
    cl.prototype = Object.assign(Object.create(il.prototype), {
        constructor: cl,
        isDirectionalLightShadow: !0,
        updateMatrices: function(t) {
            il.prototype.updateMatrices.call(this, t)
        }
    }),
    ul.prototype = Object.assign(Object.create(el.prototype), {
        constructor: ul,
        isDirectionalLight: !0,
        copy: function(t) {
            return el.prototype.copy.call(this, t),
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    }),
    hl.prototype = Object.assign(Object.create(el.prototype), {
        constructor: hl,
        isAmbientLight: !0
    }),
    dl.prototype = Object.assign(Object.create(el.prototype), {
        constructor: dl,
        isRectAreaLight: !0,
        copy: function(t) {
            return el.prototype.copy.call(this, t),
            this.width = t.width,
            this.height = t.height,
            this
        },
        toJSON: function(t) {
            const e = el.prototype.toJSON.call(this, t);
            return e.object.width = this.width,
            e.object.height = this.height,
            e
        }
    });
    class pl {
        constructor() {
            Object.defineProperty(this, "isSphericalHarmonics3", {
                value: !0
            }),
            this.coefficients = [];
            for (let t = 0; t < 9; t++)
                this.coefficients.push(new ft)
        }
        set(t) {
            for (let e = 0; e < 9; e++)
                this.coefficients[e].copy(t[e]);
            return this
        }
        zero() {
            for (let t = 0; t < 9; t++)
                this.coefficients[t].set(0, 0, 0);
            return this
        }
        getAt(t, e) {
            const n = t.x
              , i = t.y
              , r = t.z
              , o = this.coefficients;
            return e.copy(o[0]).multiplyScalar(.282095),
            e.addScaledVector(o[1], .488603 * i),
            e.addScaledVector(o[2], .488603 * r),
            e.addScaledVector(o[3], .488603 * n),
            e.addScaledVector(o[4], n * i * 1.092548),
            e.addScaledVector(o[5], i * r * 1.092548),
            e.addScaledVector(o[6], .315392 * (3 * r * r - 1)),
            e.addScaledVector(o[7], n * r * 1.092548),
            e.addScaledVector(o[8], .546274 * (n * n - i * i)),
            e
        }
        getIrradianceAt(t, e) {
            const n = t.x
              , i = t.y
              , r = t.z
              , o = this.coefficients;
            return e.copy(o[0]).multiplyScalar(.886227),
            e.addScaledVector(o[1], 1.023328 * i),
            e.addScaledVector(o[2], 1.023328 * r),
            e.addScaledVector(o[3], 1.023328 * n),
            e.addScaledVector(o[4], .858086 * n * i),
            e.addScaledVector(o[5], .858086 * i * r),
            e.addScaledVector(o[6], .743125 * r * r - .247708),
            e.addScaledVector(o[7], .858086 * n * r),
            e.addScaledVector(o[8], .429043 * (n * n - i * i)),
            e
        }
        add(t) {
            for (let e = 0; e < 9; e++)
                this.coefficients[e].add(t.coefficients[e]);
            return this
        }
        addScaledSH(t, e) {
            for (let n = 0; n < 9; n++)
                this.coefficients[n].addScaledVector(t.coefficients[n], e);
            return this
        }
        scale(t) {
            for (let e = 0; e < 9; e++)
                this.coefficients[e].multiplyScalar(t);
            return this
        }
        lerp(t, e) {
            for (let n = 0; n < 9; n++)
                this.coefficients[n].lerp(t.coefficients[n], e);
            return this
        }
        equals(t) {
            for (let e = 0; e < 9; e++)
                if (!this.coefficients[e].equals(t.coefficients[e]))
                    return !1;
            return !0
        }
        copy(t) {
            return this.set(t.coefficients)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        fromArray(t, e=0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++)
                n[i].fromArray(t, e + 3 * i);
            return this
        }
        toArray(t=[], e=0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++)
                n[i].toArray(t, e + 3 * i);
            return t
        }
        static getBasisAt(t, e) {
            const n = t.x
              , i = t.y
              , r = t.z;
            e[0] = .282095,
            e[1] = .488603 * i,
            e[2] = .488603 * r,
            e[3] = .488603 * n,
            e[4] = 1.092548 * n * i,
            e[5] = 1.092548 * i * r,
            e[6] = .315392 * (3 * r * r - 1),
            e[7] = 1.092548 * n * r,
            e[8] = .546274 * (n * n - i * i)
        }
    }
    function fl(t, e) {
        el.call(this, void 0, e),
        this.type = "LightProbe",
        this.sh = void 0 !== t ? t : new pl
    }
    function ml(t) {
        Ma.call(this, t),
        this.textures = {}
    }
    fl.prototype = Object.assign(Object.create(el.prototype), {
        constructor: fl,
        isLightProbe: !0,
        copy: function(t) {
            return el.prototype.copy.call(this, t),
            this.sh.copy(t.sh),
            this
        },
        fromJSON: function(t) {
            return this.intensity = t.intensity,
            this.sh.fromArray(t.sh),
            this
        },
        toJSON: function(t) {
            const e = el.prototype.toJSON.call(this, t);
            return e.object.sh = this.sh.toArray(),
            e
        }
    }),
    ml.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: ml,
        load: function(t, e, n, i) {
            const r = this
              , o = new Ea(r.manager);
            o.setPath(r.path),
            o.setRequestHeader(r.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(t, (function(n) {
                try {
                    e(r.parse(JSON.parse(n)))
                } catch (e) {
                    i ? i(e) : console.error(e),
                    r.manager.itemError(t)
                }
            }
            ), n, i)
        },
        parse: function(t) {
            const e = this.textures;
            function n(t) {
                return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t),
                e[t]
            }
            const i = new ra[t.type];
            if (void 0 !== t.uuid && (i.uuid = t.uuid),
            void 0 !== t.name && (i.name = t.name),
            void 0 !== t.color && void 0 !== i.color && i.color.setHex(t.color),
            void 0 !== t.roughness && (i.roughness = t.roughness),
            void 0 !== t.metalness && (i.metalness = t.metalness),
            void 0 !== t.sheen && (i.sheen = (new Ne).setHex(t.sheen)),
            void 0 !== t.emissive && void 0 !== i.emissive && i.emissive.setHex(t.emissive),
            void 0 !== t.specular && void 0 !== i.specular && i.specular.setHex(t.specular),
            void 0 !== t.shininess && (i.shininess = t.shininess),
            void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
            void 0 !== t.clearcoatRoughness && (i.clearcoatRoughness = t.clearcoatRoughness),
            void 0 !== t.fog && (i.fog = t.fog),
            void 0 !== t.flatShading && (i.flatShading = t.flatShading),
            void 0 !== t.blending && (i.blending = t.blending),
            void 0 !== t.combine && (i.combine = t.combine),
            void 0 !== t.side && (i.side = t.side),
            void 0 !== t.opacity && (i.opacity = t.opacity),
            void 0 !== t.transparent && (i.transparent = t.transparent),
            void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
            void 0 !== t.depthTest && (i.depthTest = t.depthTest),
            void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
            void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
            void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
            void 0 !== t.stencilWriteMask && (i.stencilWriteMask = t.stencilWriteMask),
            void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
            void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
            void 0 !== t.stencilFuncMask && (i.stencilFuncMask = t.stencilFuncMask),
            void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
            void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
            void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
            void 0 !== t.wireframe && (i.wireframe = t.wireframe),
            void 0 !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth),
            void 0 !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap),
            void 0 !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin),
            void 0 !== t.rotation && (i.rotation = t.rotation),
            1 !== t.linewidth && (i.linewidth = t.linewidth),
            void 0 !== t.dashSize && (i.dashSize = t.dashSize),
            void 0 !== t.gapSize && (i.gapSize = t.gapSize),
            void 0 !== t.scale && (i.scale = t.scale),
            void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
            void 0 !== t.polygonOffsetFactor && (i.polygonOffsetFactor = t.polygonOffsetFactor),
            void 0 !== t.polygonOffsetUnits && (i.polygonOffsetUnits = t.polygonOffsetUnits),
            void 0 !== t.skinning && (i.skinning = t.skinning),
            void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
            void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
            void 0 !== t.dithering && (i.dithering = t.dithering),
            void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents),
            void 0 !== t.visible && (i.visible = t.visible),
            void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
            void 0 !== t.userData && (i.userData = t.userData),
            void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? i.vertexColors = t.vertexColors > 0 : i.vertexColors = t.vertexColors),
            void 0 !== t.uniforms)
                for (const e in t.uniforms) {
                    const r = t.uniforms[e];
                    switch (i.uniforms[e] = {},
                    r.type) {
                    case "t":
                        i.uniforms[e].value = n(r.value);
                        break;
                    case "c":
                        i.uniforms[e].value = (new Ne).setHex(r.value);
                        break;
                    case "v2":
                        i.uniforms[e].value = (new it).fromArray(r.value);
                        break;
                    case "v3":
                        i.uniforms[e].value = (new ft).fromArray(r.value);
                        break;
                    case "v4":
                        i.uniforms[e].value = (new ut).fromArray(r.value);
                        break;
                    case "m3":
                        i.uniforms[e].value = (new rt).fromArray(r.value);
                        break;
                    case "m4":
                        i.uniforms[e].value = (new Gt).fromArray(r.value);
                        break;
                    default:
                        i.uniforms[e].value = r.value
                    }
                }
            if (void 0 !== t.defines && (i.defines = t.defines),
            void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
            void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader),
            void 0 !== t.extensions)
                for (const e in t.extensions)
                    i.extensions[e] = t.extensions[e];
            if (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
            void 0 !== t.size && (i.size = t.size),
            void 0 !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation),
            void 0 !== t.map && (i.map = n(t.map)),
            void 0 !== t.matcap && (i.matcap = n(t.matcap)),
            void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
            void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
            void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
            void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
            void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
            void 0 !== t.normalScale) {
                let e = t.normalScale;
                !1 === Array.isArray(e) && (e = [e, e]),
                i.normalScale = (new it).fromArray(e)
            }
            return void 0 !== t.displacementMap && (i.displacementMap = n(t.displacementMap)),
            void 0 !== t.displacementScale && (i.displacementScale = t.displacementScale),
            void 0 !== t.displacementBias && (i.displacementBias = t.displacementBias),
            void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
            void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
            void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
            void 0 !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity),
            void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
            void 0 !== t.envMap && (i.envMap = n(t.envMap)),
            void 0 !== t.envMapIntensity && (i.envMapIntensity = t.envMapIntensity),
            void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
            void 0 !== t.refractionRatio && (i.refractionRatio = t.refractionRatio),
            void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
            void 0 !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity),
            void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
            void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity),
            void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
            void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
            void 0 !== t.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
            void 0 !== t.clearcoatNormalMap && (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
            void 0 !== t.clearcoatNormalScale && (i.clearcoatNormalScale = (new it).fromArray(t.clearcoatNormalScale)),
            void 0 !== t.transmission && (i.transmission = t.transmission),
            void 0 !== t.transmissionMap && (i.transmissionMap = n(t.transmissionMap)),
            i
        },
        setTextures: function(t) {
            return this.textures = t,
            this
        }
    });
    const gl = function(t) {
        const e = t.lastIndexOf("/");
        return -1 === e ? "./" : t.substr(0, e + 1)
    };
    function vl() {
        hn.call(this),
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    function yl(t, e, n, i) {
        "number" == typeof n && (i = n,
        n = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        Ge.call(this, t, e, n),
        this.meshPerAttribute = i || 1
    }
    function _l(t) {
        Ma.call(this, t)
    }
    vl.prototype = Object.assign(Object.create(hn.prototype), {
        constructor: vl,
        isInstancedBufferGeometry: !0,
        copy: function(t) {
            return hn.prototype.copy.call(this, t),
            this.instanceCount = t.instanceCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            const t = hn.prototype.toJSON.call(this);
            return t.instanceCount = this.instanceCount,
            t.isInstancedBufferGeometry = !0,
            t
        }
    }),
    yl.prototype = Object.assign(Object.create(Ge.prototype), {
        constructor: yl,
        isInstancedBufferAttribute: !0,
        copy: function(t) {
            return Ge.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        },
        toJSON: function() {
            const t = Ge.prototype.toJSON.call(this);
            return t.meshPerAttribute = this.meshPerAttribute,
            t.isInstancedBufferAttribute = !0,
            t
        }
    }),
    _l.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: _l,
        load: function(t, e, n, i) {
            const r = this
              , o = new Ea(r.manager);
            o.setPath(r.path),
            o.setRequestHeader(r.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(t, (function(n) {
                try {
                    e(r.parse(JSON.parse(n)))
                } catch (e) {
                    i ? i(e) : console.error(e),
                    r.manager.itemError(t)
                }
            }
            ), n, i)
        },
        parse: function(t) {
            const e = {}
              , n = {};
            function i(t, i) {
                if (void 0 !== e[i])
                    return e[i];
                const r = t.interleavedBuffers[i]
                  , o = function(t, e) {
                    if (void 0 !== n[e])
                        return n[e];
                    const i = t.arrayBuffers[e]
                      , r = new Uint32Array(i).buffer;
                    return n[e] = r,
                    r
                }(t, r.buffer)
                  , s = new no(nn(r.type, o),r.stride);
                return s.uuid = r.uuid,
                e[i] = s,
                s
            }
            const r = t.isInstancedBufferGeometry ? new vl : new hn
              , o = t.data.index;
            if (void 0 !== o) {
                const t = nn(o.type, o.array);
                r.setIndex(new Ge(t,1))
            }
            const s = t.data.attributes;
            for (const e in s) {
                const n = s[e];
                let o;
                if (n.isInterleavedBufferAttribute) {
                    o = new ro(i(t.data, n.data),n.itemSize,n.offset,n.normalized)
                } else {
                    const t = nn(n.type, n.array);
                    o = new (n.isInstancedBufferAttribute ? yl : Ge)(t,n.itemSize,n.normalized)
                }
                void 0 !== n.name && (o.name = n.name),
                r.setAttribute(e, o)
            }
            const a = t.data.morphAttributes;
            if (a)
                for (const e in a) {
                    const n = a[e]
                      , o = [];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        let s;
                        if (r.isInterleavedBufferAttribute) {
                            s = new ro(i(t.data, r.data),r.itemSize,r.offset,r.normalized)
                        } else {
                            s = new Ge(nn(r.type, r.array),r.itemSize,r.normalized)
                        }
                        void 0 !== r.name && (s.name = r.name),
                        o.push(s)
                    }
                    r.morphAttributes[e] = o
                }
            t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
            const l = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== l)
                for (let t = 0, e = l.length; t !== e; ++t) {
                    const e = l[t];
                    r.addGroup(e.start, e.count, e.materialIndex)
                }
            const c = t.data.boundingSphere;
            if (void 0 !== c) {
                const t = new ft;
                void 0 !== c.center && t.fromArray(c.center),
                r.boundingSphere = new Ot(t,c.radius)
            }
            return t.name && (r.name = t.name),
            t.userData && (r.userData = t.userData),
            r
        }
    });
    function xl(t) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        Ma.call(this, t),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    function bl() {
        this.type = "ShapePath",
        this.color = new Ne,
        this.subPaths = [],
        this.currentPath = null
    }
    function wl(t) {
        this.type = "Font",
        this.data = t
    }
    function Ml(t, e, n, i, r) {
        const o = r.glyphs[t] || r.glyphs["?"];
        if (!o)
            return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
        const s = new bl;
        let a, l, c, u, h, d, p, f;
        if (o.o) {
            const t = o._cachedOutline || (o._cachedOutline = o.o.split(" "));
            for (let r = 0, o = t.length; r < o; ) {
                switch (t[r++]) {
                case "m":
                    a = t[r++] * e + n,
                    l = t[r++] * e + i,
                    s.moveTo(a, l);
                    break;
                case "l":
                    a = t[r++] * e + n,
                    l = t[r++] * e + i,
                    s.lineTo(a, l);
                    break;
                case "q":
                    c = t[r++] * e + n,
                    u = t[r++] * e + i,
                    h = t[r++] * e + n,
                    d = t[r++] * e + i,
                    s.quadraticCurveTo(h, d, c, u);
                    break;
                case "b":
                    c = t[r++] * e + n,
                    u = t[r++] * e + i,
                    h = t[r++] * e + n,
                    d = t[r++] * e + i,
                    p = t[r++] * e + n,
                    f = t[r++] * e + i,
                    s.bezierCurveTo(h, d, p, f, c, u)
                }
            }
        }
        return {
            offsetX: o.ha * e,
            path: s
        }
    }
    function Sl(t) {
        Ma.call(this, t)
    }
    let El;
    xl.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: xl,
        isImageBitmapLoader: !0,
        setOptions: function(t) {
            return this.options = t,
            this
        },
        load: function(t, e, n, i) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            const r = this
              , o = xa.get(t);
            if (void 0 !== o)
                return r.manager.itemStart(t),
                setTimeout((function() {
                    e && e(o),
                    r.manager.itemEnd(t)
                }
                ), 0),
                o;
            const s = {};
            s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
            fetch(t, s).then((function(t) {
                return t.blob()
            }
            )).then((function(t) {
                return createImageBitmap(t, r.options)
            }
            )).then((function(n) {
                xa.add(t, n),
                e && e(n),
                r.manager.itemEnd(t)
            }
            )).catch((function(e) {
                i && i(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            }
            )),
            r.manager.itemStart(t)
        }
    }),
    Object.assign(bl.prototype, {
        moveTo: function(t, e) {
            return this.currentPath = new $a,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e),
            this
        },
        lineTo: function(t, e) {
            return this.currentPath.lineTo(t, e),
            this
        },
        quadraticCurveTo: function(t, e, n, i) {
            return this.currentPath.quadraticCurveTo(t, e, n, i),
            this
        },
        bezierCurveTo: function(t, e, n, i, r, o) {
            return this.currentPath.bezierCurveTo(t, e, n, i, r, o),
            this
        },
        splineThru: function(t) {
            return this.currentPath.splineThru(t),
            this
        },
        toShapes: function(t, e) {
            function n(t) {
                const e = [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n]
                      , r = new tl;
                    r.curves = i.curves,
                    e.push(r)
                }
                return e
            }
            function i(t, e) {
                const n = e.length;
                let i = !1;
                for (let r = n - 1, o = 0; o < n; r = o++) {
                    let n = e[r]
                      , s = e[o]
                      , a = s.x - n.x
                      , l = s.y - n.y;
                    if (Math.abs(l) > Number.EPSILON) {
                        if (l < 0 && (n = e[o],
                        a = -a,
                        s = e[r],
                        l = -l),
                        t.y < n.y || t.y > s.y)
                            continue;
                        if (t.y === n.y) {
                            if (t.x === n.x)
                                return !0
                        } else {
                            const e = l * (t.x - n.x) - a * (t.y - n.y);
                            if (0 === e)
                                return !0;
                            if (e < 0)
                                continue;
                            i = !i
                        }
                    } else {
                        if (t.y !== n.y)
                            continue;
                        if (s.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= s.x)
                            return !0
                    }
                }
                return i
            }
            const r = ks.isClockWise
              , o = this.subPaths;
            if (0 === o.length)
                return [];
            if (!0 === e)
                return n(o);
            let s, a, l;
            const c = [];
            if (1 === o.length)
                return a = o[0],
                l = new tl,
                l.curves = a.curves,
                c.push(l),
                c;
            let u = !r(o[0].getPoints());
            u = t ? !u : u;
            const h = []
              , d = [];
            let p, f, m = [], g = 0;
            d[g] = void 0,
            m[g] = [];
            for (let e = 0, n = o.length; e < n; e++)
                a = o[e],
                p = a.getPoints(),
                s = r(p),
                s = t ? !s : s,
                s ? (!u && d[g] && g++,
                d[g] = {
                    s: new tl,
                    p: p
                },
                d[g].s.curves = a.curves,
                u && g++,
                m[g] = []) : m[g].push({
                    h: a,
                    p: p[0]
                });
            if (!d[0])
                return n(o);
            if (d.length > 1) {
                let t = !1;
                const e = [];
                for (let t = 0, e = d.length; t < e; t++)
                    h[t] = [];
                for (let n = 0, r = d.length; n < r; n++) {
                    const r = m[n];
                    for (let o = 0; o < r.length; o++) {
                        const s = r[o];
                        let a = !0;
                        for (let r = 0; r < d.length; r++)
                            i(s.p, d[r].p) && (n !== r && e.push({
                                froms: n,
                                tos: r,
                                hole: o
                            }),
                            a ? (a = !1,
                            h[r].push(s)) : t = !0);
                        a && h[n].push(s)
                    }
                }
                e.length > 0 && (t || (m = h))
            }
            for (let t = 0, e = d.length; t < e; t++) {
                l = d[t].s,
                c.push(l),
                f = m[t];
                for (let t = 0, e = f.length; t < e; t++)
                    l.holes.push(f[t].h)
            }
            return c
        }
    }),
    Object.assign(wl.prototype, {
        isFont: !0,
        generateShapes: function(t, e=100) {
            const n = []
              , i = function(t, e, n) {
                const i = Array.from ? Array.from(t) : String(t).split("")
                  , r = e / n.resolution
                  , o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r
                  , s = [];
                let a = 0
                  , l = 0;
                for (let t = 0; t < i.length; t++) {
                    const e = i[t];
                    if ("\n" === e)
                        a = 0,
                        l -= o;
                    else {
                        const t = Ml(e, r, a, l, n);
                        a += t.offsetX,
                        s.push(t.path)
                    }
                }
                return s
            }(t, e, this.data);
            for (let t = 0, e = i.length; t < e; t++)
                Array.prototype.push.apply(n, i[t].toShapes());
            return n
        }
    }),
    Sl.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: Sl,
        load: function(t, e, n, i) {
            const r = this
              , o = new Ea(this.manager);
            o.setPath(this.path),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(t, (function(t) {
                let n;
                try {
                    n = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                    n = JSON.parse(t.substring(65, t.length - 2))
                }
                const i = r.parse(n);
                e && e(i)
            }
            ), n, i)
        },
        parse: function(t) {
            return new wl(t)
        }
    });
    const Dl = function() {
        return void 0 === El && (El = new (window.AudioContext || window.webkitAudioContext)),
        El
    };
    function Tl(t) {
        Ma.call(this, t)
    }
    function Al(t, e, n) {
        fl.call(this, void 0, n);
        const i = (new Ne).set(t)
          , r = (new Ne).set(e)
          , o = new ft(i.r,i.g,i.b)
          , s = new ft(r.r,r.g,r.b)
          , a = Math.sqrt(Math.PI)
          , l = a * Math.sqrt(.75);
        this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),
        this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(l)
    }
    function Cl(t, e) {
        fl.call(this, void 0, e);
        const n = (new Ne).set(t);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
    }
    Tl.prototype = Object.assign(Object.create(Ma.prototype), {
        constructor: Tl,
        load: function(t, e, n, i) {
            const r = this
              , o = new Ea(r.manager);
            o.setResponseType("arraybuffer"),
            o.setPath(r.path),
            o.setRequestHeader(r.requestHeader),
            o.setWithCredentials(r.withCredentials),
            o.load(t, (function(n) {
                try {
                    const t = n.slice(0);
                    Dl().decodeAudioData(t, (function(t) {
                        e(t)
                    }
                    ))
                } catch (e) {
                    i ? i(e) : console.error(e),
                    r.manager.itemError(t)
                }
            }
            ), n, i)
        }
    }),
    Al.prototype = Object.assign(Object.create(fl.prototype), {
        constructor: Al,
        isHemisphereLightProbe: !0,
        copy: function(t) {
            return fl.prototype.copy.call(this, t),
            this
        },
        toJSON: function(t) {
            return fl.prototype.toJSON.call(this, t)
        }
    }),
    Cl.prototype = Object.assign(Object.create(fl.prototype), {
        constructor: Cl,
        isAmbientLightProbe: !0,
        copy: function(t) {
            return fl.prototype.copy.call(this, t),
            this
        },
        toJSON: function(t) {
            return fl.prototype.toJSON.call(this, t)
        }
    });
    const Ll = new Gt
      , Pl = new Gt;
    Object.assign(function() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new kn,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new kn,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1,
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    .prototype, {
        update: function(t) {
            const e = this._cache;
            if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
                e.focus = t.focus,
                e.fov = t.fov,
                e.aspect = t.aspect * this.aspect,
                e.near = t.near,
                e.far = t.far,
                e.zoom = t.zoom,
                e.eyeSep = this.eyeSep;
                const n = t.projectionMatrix.clone()
                  , i = e.eyeSep / 2
                  , r = i * e.near / e.focus
                  , o = e.near * Math.tan(nt.DEG2RAD * e.fov * .5) / e.zoom;
                let s, a;
                Pl.elements[12] = -i,
                Ll.elements[12] = i,
                s = -o * e.aspect + r,
                a = o * e.aspect + r,
                n.elements[0] = 2 * e.near / (a - s),
                n.elements[8] = (a + s) / (a - s),
                this.cameraL.projectionMatrix.copy(n),
                s = -o * e.aspect - r,
                a = o * e.aspect - r,
                n.elements[0] = 2 * e.near / (a - s),
                n.elements[8] = (a + s) / (a - s),
                this.cameraR.projectionMatrix.copy(n)
            }
            this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Pl),
            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Ll)
        }
    });
    class Rl {
        constructor(t) {
            this.autoStart = void 0 === t || t,
            this.startTime = 0,
            this.oldTime = 0,
            this.elapsedTime = 0,
            this.running = !1
        }
        start() {
            this.startTime = Ol(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        }
        stop() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        }
        getElapsedTime() {
            return this.getDelta(),
            this.elapsedTime
        }
        getDelta() {
            let t = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                const e = Ol();
                t = (e - this.oldTime) / 1e3,
                this.oldTime = e,
                this.elapsedTime += t
            }
            return t
        }
    }
    function Ol() {
        return ("undefined" == typeof performance ? Date : performance).now()
    }
    class Fl extends pe {
        constructor(t) {
            super(),
            this.type = "Audio",
            this.listener = t,
            this.context = t.context,
            this.gain = this.context.createGain(),
            this.gain.connect(t.getInput()),
            this.autoplay = !1,
            this.buffer = null,
            this.detune = 0,
            this.loop = !1,
            this.loopStart = 0,
            this.loopEnd = 0,
            this.offset = 0,
            this.duration = void 0,
            this.playbackRate = 1,
            this.isPlaying = !1,
            this.hasPlaybackControl = !0,
            this.source = null,
            this.sourceType = "empty",
            this._startedAt = 0,
            this._progress = 0,
            this._connected = !1,
            this.filters = []
        }
        getOutput() {
            return this.gain
        }
        setNodeSource(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = t,
            this.connect(),
            this
        }
        setMediaElementSource(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(t),
            this.connect(),
            this
        }
        setMediaStreamSource(t) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaStreamNode",
            this.source = this.context.createMediaStreamSource(t),
            this.connect(),
            this
        }
        setBuffer(t) {
            return this.buffer = t,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        }
        play(t=0) {
            if (!0 === this.isPlaying)
                return void console.warn("THREE.Audio: Audio is already playing.");
            if (!1 === this.hasPlaybackControl)
                return void console.warn("THREE.Audio: this Audio has no playback control.");
            this._startedAt = this.context.currentTime + t;
            const e = this.context.createBufferSource();
            return e.buffer = this.buffer,
            e.loop = this.loop,
            e.loopStart = this.loopStart,
            e.loopEnd = this.loopEnd,
            e.onended = this.onEnded.bind(this),
            e.start(this._startedAt, this._progress + this.offset, this.duration),
            this.isPlaying = !0,
            this.source = e,
            this.setDetune(this.detune),
            this.setPlaybackRate(this.playbackRate),
            this.connect()
        }
        pause() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        stop() {
            if (!1 !== this.hasPlaybackControl)
                return this._progress = 0,
                this.source.stop(),
                this.source.onended = null,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        connect() {
            if (this.filters.length > 0) {
                this.source.connect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this._connected = !0,
            this
        }
        disconnect() {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let t = 1, e = this.filters.length; t < e; t++)
                    this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this._connected = !1,
            this
        }
        getFilters() {
            return this.filters
        }
        setFilters(t) {
            return t || (t = []),
            !0 === this._connected ? (this.disconnect(),
            this.filters = t.slice(),
            this.connect()) : this.filters = t.slice(),
            this
        }
        setDetune(t) {
            if (this.detune = t,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        }
        getDetune() {
            return this.detune
        }
        getFilter() {
            return this.getFilters()[0]
        }
        setFilter(t) {
            return this.setFilters(t ? [t] : [])
        }
        setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = t,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        getPlaybackRate() {
            return this.playbackRate
        }
        onEnded() {
            this.isPlaying = !1
        }
        getLoop() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        }
        setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = t,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }
        setLoopStart(t) {
            return this.loopStart = t,
            this
        }
        setLoopEnd(t) {
            return this.loopEnd = t,
            this
        }
        getVolume() {
            return this.gain.gain.value
        }
        setVolume(t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01),
            this
        }
    }
    function Nl(t, e, n) {
        let i, r, o;
        switch (this.binding = t,
        this.valueSize = n,
        e) {
        case "quaternion":
            i = this._slerp,
            r = this._slerpAdditive,
            o = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(6 * n),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            i = this._select,
            r = this._select,
            o = this._setAdditiveIdentityOther,
            this.buffer = new Array(5 * n);
            break;
        default:
            i = this._lerp,
            r = this._lerpAdditive,
            o = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(5 * n)
        }
        this._mixBufferRegion = i,
        this._mixBufferRegionAdditive = r,
        this._setIdentity = o,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    Object.assign(Nl.prototype, {
        accumulate: function(t, e) {
            const n = this.buffer
              , i = this.valueSize
              , r = t * i + i;
            let o = this.cumulativeWeight;
            if (0 === o) {
                for (let t = 0; t !== i; ++t)
                    n[r + t] = n[t];
                o = e
            } else {
                o += e;
                const t = e / o;
                this._mixBufferRegion(n, r, 0, t, i)
            }
            this.cumulativeWeight = o
        },
        accumulateAdditive: function(t) {
            const e = this.buffer
              , n = this.valueSize
              , i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(e, i, 0, t, n),
            this.cumulativeWeightAdditive += t
        },
        apply: function(t) {
            const e = this.valueSize
              , n = this.buffer
              , i = t * e + e
              , r = this.cumulativeWeight
              , o = this.cumulativeWeightAdditive
              , s = this.binding;
            if (this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0,
            r < 1) {
                const t = e * this._origIndex;
                this._mixBufferRegion(n, i, t, 1 - r, e)
            }
            o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
            for (let t = e, r = e + e; t !== r; ++t)
                if (n[t] !== n[t + e]) {
                    s.setValue(n, i);
                    break
                }
        },
        saveOriginalState: function() {
            const t = this.binding
              , e = this.buffer
              , n = this.valueSize
              , i = n * this._origIndex;
            t.getValue(e, i);
            for (let t = n, r = i; t !== r; ++t)
                e[t] = e[i + t % n];
            this._setIdentity(),
            this.cumulativeWeight = 0,
            this.cumulativeWeightAdditive = 0
        },
        restoreOriginalState: function() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t)
        },
        _setAdditiveIdentityNumeric: function() {
            const t = this._addIndex * this.valueSize
              , e = t + this.valueSize;
            for (let n = t; n < e; n++)
                this.buffer[n] = 0
        },
        _setAdditiveIdentityQuaternion: function() {
            this._setAdditiveIdentityNumeric(),
            this.buffer[this._addIndex * this.valueSize + 3] = 1
        },
        _setAdditiveIdentityOther: function() {
            const t = this._origIndex * this.valueSize
              , e = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++)
                this.buffer[e + n] = this.buffer[t + n]
        },
        _select: function(t, e, n, i, r) {
            if (i >= .5)
                for (let i = 0; i !== r; ++i)
                    t[e + i] = t[n + i]
        },
        _slerp: function(t, e, n, i) {
            pt.slerpFlat(t, e, t, e, t, n, i)
        },
        _slerpAdditive: function(t, e, n, i, r) {
            const o = this._workIndex * r;
            pt.multiplyQuaternionsFlat(t, o, t, e, t, n),
            pt.slerpFlat(t, e, t, e, t, o, i)
        },
        _lerp: function(t, e, n, i, r) {
            const o = 1 - i;
            for (let s = 0; s !== r; ++s) {
                const r = e + s;
                t[r] = t[r] * o + t[n + s] * i
            }
        },
        _lerpAdditive: function(t, e, n, i, r) {
            for (let o = 0; o !== r; ++o) {
                const r = e + o;
                t[r] = t[r] + t[n + o] * i
            }
        }
    });
    const Il = "\\[\\]\\.:\\/"
      , Bl = new RegExp("[\\[\\]\\.:\\/]","g")
      , kl = "[^\\[\\]\\.:\\/]"
      , zl = "[^" + Il.replace("\\.", "") + "]"
      , Ul = /((?:WC+[\/:])*)/.source.replace("WC", kl)
      , Hl = /(WCOD+)?/.source.replace("WCOD", zl)
      , Gl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", kl)
      , Vl = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", kl)
      , jl = new RegExp("^" + Ul + Hl + Gl + Vl + "$")
      , Wl = ["material", "materials", "bones"];
    function ql(t, e, n) {
        const i = n || Xl.parseTrackName(e);
        this._targetGroup = t,
        this._bindings = t.subscribe_(e, i)
    }
    function Xl(t, e, n) {
        this.path = e,
        this.parsedPath = n || Xl.parseTrackName(e),
        this.node = Xl.findNode(t, this.parsedPath.nodeName) || t,
        this.rootNode = t
    }
    Object.assign(ql.prototype, {
        getValue: function(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_
              , i = this._bindings[n];
            void 0 !== i && i.getValue(t, e)
        },
        setValue: function(t, e) {
            const n = this._bindings;
            for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                n[i].setValue(t, e)
        },
        bind: function() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].bind()
        },
        unbind: function() {
            const t = this._bindings;
            for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)
                t[e].unbind()
        }
    }),
    Object.assign(Xl, {
        Composite: ql,
        create: function(t, e, n) {
            return t && t.isAnimationObjectGroup ? new Xl.Composite(t,e,n) : new Xl(t,e,n)
        },
        sanitizeNodeName: function(t) {
            return t.replace(/\s/g, "_").replace(Bl, "")
        },
        parseTrackName: function(t) {
            const e = jl.exec(t);
            if (!e)
                throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6]
            }
              , i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
                const t = n.nodeName.substring(i + 1);
                -1 !== Wl.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i),
                n.objectName = t)
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
            return n
        },
        findNode: function(t, e) {
            if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid)
                return t;
            if (t.skeleton) {
                const n = t.skeleton.getBoneByName(e);
                if (void 0 !== n)
                    return n
            }
            if (t.children) {
                const n = function(t) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        if (r.name === e || r.uuid === e)
                            return r;
                        const o = n(r.children);
                        if (o)
                            return o
                    }
                    return null
                }
                  , i = n(t.children);
                if (i)
                    return i
            }
            return null
        }
    }),
    Object.assign(Xl.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(t, e) {
            t[e] = this.node[this.propertyName]
        }
        , function(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i)
                t[e++] = n[i]
        }
        , function(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }
        , function(t, e) {
            this.resolvedProperty.toArray(t, e)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(t, e) {
            this.targetObject[this.propertyName] = t[e]
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.targetObject[this.propertyName] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++]
        }
        , function(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++];
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i)
                n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e]
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(t, e) {
            this.resolvedProperty.fromArray(t, e)
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.needsUpdate = !0
        }
        , function(t, e) {
            this.resolvedProperty.fromArray(t, e),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(t, e) {
            this.bind(),
            this.getValue(t, e)
        },
        setValue: function(t, e) {
            this.bind(),
            this.setValue(t, e)
        },
        bind: function() {
            let t = this.node;
            const e = this.parsedPath
              , n = e.objectName
              , i = e.propertyName;
            let r = e.propertyIndex;
            if (t || (t = Xl.findNode(this.rootNode, e.nodeName) || this.rootNode,
            this.node = t),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            !t)
                return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (n) {
                let i = e.objectIndex;
                switch (n) {
                case "materials":
                    if (!t.material)
                        return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!t.material.materials)
                        return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    t = t.material.materials;
                    break;
                case "bones":
                    if (!t.skeleton)
                        return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    t = t.skeleton.bones;
                    for (let e = 0; e < t.length; e++)
                        if (t[e].name === i) {
                            i = e;
                            break
                        }
                    break;
                default:
                    if (void 0 === t[n])
                        return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    t = t[n]
                }
                if (void 0 !== i) {
                    if (void 0 === t[i])
                        return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                    t = t[i]
                }
            }
            const o = t[i];
            if (void 0 === o) {
                const n = e.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
            }
            let s = this.Versioning.None;
            this.targetObject = t,
            void 0 !== t.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
            let a = this.BindingType.Direct;
            if (void 0 !== r) {
                if ("morphTargetInfluences" === i) {
                    if (!t.geometry)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (!t.geometry.isBufferGeometry)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    if (!t.geometry.morphAttributes)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                }
                a = this.BindingType.ArrayElement,
                this.resolvedProperty = o,
                this.propertyIndex = r
            } else
                void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray,
                this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray,
                this.resolvedProperty = o) : this.propertyName = i;
            this.getValue = this.GetterByBindingType[a],
            this.setValue = this.SetterByBindingTypeAndVersioning[a][s]
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(Xl.prototype, {
        _getValue_unbound: Xl.prototype.getValue,
        _setValue_unbound: Xl.prototype.setValue
    }),
    Object.assign(function() {
        this.uuid = nt.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        const t = {};
        this._indicesByUUID = t;
        for (let e = 0, n = arguments.length; e !== n; ++e)
            t[arguments[e].uuid] = e;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        const e = this;
        this.stats = {
            objects: {
                get total() {
                    return e._objects.length
                },
                get inUse() {
                    return this.total - e.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return e._bindings.length
            }
        }
    }
    .prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            const t = this._objects
              , e = this._indicesByUUID
              , n = this._paths
              , i = this._parsedPaths
              , r = this._bindings
              , o = r.length;
            let s = void 0
              , a = t.length
              , l = this.nCachedObjects_;
            for (let c = 0, u = arguments.length; c !== u; ++c) {
                const u = arguments[c]
                  , h = u.uuid;
                let d = e[h];
                if (void 0 === d) {
                    d = a++,
                    e[h] = d,
                    t.push(u);
                    for (let t = 0, e = o; t !== e; ++t)
                        r[t].push(new Xl(u,n[t],i[t]))
                } else if (d < l) {
                    s = t[d];
                    const a = --l
                      , c = t[a];
                    e[c.uuid] = d,
                    t[d] = c,
                    e[h] = a,
                    t[a] = u;
                    for (let t = 0, e = o; t !== e; ++t) {
                        const e = r[t]
                          , o = e[a];
                        let s = e[d];
                        e[d] = o,
                        void 0 === s && (s = new Xl(u,n[t],i[t])),
                        e[a] = s
                    }
                } else
                    t[d] !== s && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = l
        },
        remove: function() {
            const t = this._objects
              , e = this._indicesByUUID
              , n = this._bindings
              , i = n.length;
            let r = this.nCachedObjects_;
            for (let o = 0, s = arguments.length; o !== s; ++o) {
                const s = arguments[o]
                  , a = s.uuid
                  , l = e[a];
                if (void 0 !== l && l >= r) {
                    const o = r++
                      , c = t[o];
                    e[c.uuid] = l,
                    t[l] = c,
                    e[a] = o,
                    t[o] = s;
                    for (let t = 0, e = i; t !== e; ++t) {
                        const e = n[t]
                          , i = e[o]
                          , r = e[l];
                        e[l] = i,
                        e[o] = r
                    }
                }
            }
            this.nCachedObjects_ = r
        },
        uncache: function() {
            const t = this._objects
              , e = this._indicesByUUID
              , n = this._bindings
              , i = n.length;
            let r = this.nCachedObjects_
              , o = t.length;
            for (let s = 0, a = arguments.length; s !== a; ++s) {
                const a = arguments[s].uuid
                  , l = e[a];
                if (void 0 !== l)
                    if (delete e[a],
                    l < r) {
                        const s = --r
                          , a = t[s]
                          , c = --o
                          , u = t[c];
                        e[a.uuid] = l,
                        t[l] = a,
                        e[u.uuid] = s,
                        t[s] = u,
                        t.pop();
                        for (let t = 0, e = i; t !== e; ++t) {
                            const e = n[t]
                              , i = e[s]
                              , r = e[c];
                            e[l] = i,
                            e[s] = r,
                            e.pop()
                        }
                    } else {
                        const r = --o
                          , s = t[r];
                        r > 0 && (e[s.uuid] = l),
                        t[l] = s,
                        t.pop();
                        for (let t = 0, e = i; t !== e; ++t) {
                            const e = n[t];
                            e[l] = e[r],
                            e.pop()
                        }
                    }
            }
            this.nCachedObjects_ = r
        },
        subscribe_: function(t, e) {
            const n = this._bindingsIndicesByPath;
            let i = n[t];
            const r = this._bindings;
            if (void 0 !== i)
                return r[i];
            const o = this._paths
              , s = this._parsedPaths
              , a = this._objects
              , l = a.length
              , c = this.nCachedObjects_
              , u = new Array(l);
            i = r.length,
            n[t] = i,
            o.push(t),
            s.push(e),
            r.push(u);
            for (let n = c, i = a.length; n !== i; ++n) {
                const i = a[n];
                u[n] = new Xl(i,t,e)
            }
            return u
        },
        unsubscribe_: function(t) {
            const e = this._bindingsIndicesByPath
              , n = e[t];
            if (void 0 !== n) {
                const i = this._paths
                  , r = this._parsedPaths
                  , o = this._bindings
                  , s = o.length - 1
                  , a = o[s];
                e[t[s]] = n,
                o[n] = a,
                o.pop(),
                r[n] = r[s],
                r.pop(),
                i[n] = i[s],
                i.pop()
            }
        }
    });
    class Yl {
        constructor(t, e, n=null, i=e.blendMode) {
            this._mixer = t,
            this._clip = e,
            this._localRoot = n,
            this.blendMode = i;
            const r = e.tracks
              , o = r.length
              , s = new Array(o)
              , a = {
                endingStart: H,
                endingEnd: H
            };
            for (let t = 0; t !== o; ++t) {
                const e = r[t].createInterpolant(null);
                s[t] = e,
                e.settings = a
            }
            this._interpolantSettings = a,
            this._interpolants = s,
            this._propertyBindings = new Array(o),
            this._cacheIndex = null,
            this._byClipCacheIndex = null,
            this._timeScaleInterpolant = null,
            this._weightInterpolant = null,
            this.loop = 2201,
            this._loopCount = -1,
            this._startTime = null,
            this.time = 0,
            this.timeScale = 1,
            this._effectiveTimeScale = 1,
            this.weight = 1,
            this._effectiveWeight = 1,
            this.repetitions = 1 / 0,
            this.paused = !1,
            this.enabled = !0,
            this.clampWhenFinished = !1,
            this.zeroSlopeAtStart = !0,
            this.zeroSlopeAtEnd = !0
        }
        play() {
            return this._mixer._activateAction(this),
            this
        }
        stop() {
            return this._mixer._deactivateAction(this),
            this.reset()
        }
        reset() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        }
        isRunning() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        }
        isScheduled() {
            return this._mixer._isActiveAction(this)
        }
        startAt(t) {
            return this._startTime = t,
            this
        }
        setLoop(t, e) {
            return this.loop = t,
            this.repetitions = e,
            this
        }
        setEffectiveWeight(t) {
            return this.weight = t,
            this._effectiveWeight = this.enabled ? t : 0,
            this.stopFading()
        }
        getEffectiveWeight() {
            return this._effectiveWeight
        }
        fadeIn(t) {
            return this._scheduleFading(t, 0, 1)
        }
        fadeOut(t) {
            return this._scheduleFading(t, 1, 0)
        }
        crossFadeFrom(t, e, n) {
            if (t.fadeOut(e),
            this.fadeIn(e),
            n) {
                const n = this._clip.duration
                  , i = t._clip.duration
                  , r = i / n
                  , o = n / i;
                t.warp(1, r, e),
                this.warp(o, 1, e)
            }
            return this
        }
        crossFadeTo(t, e, n) {
            return t.crossFadeFrom(this, e, n)
        }
        stopFading() {
            const t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        }
        setEffectiveTimeScale(t) {
            return this.timeScale = t,
            this._effectiveTimeScale = this.paused ? 0 : t,
            this.stopWarping()
        }
        getEffectiveTimeScale() {
            return this._effectiveTimeScale
        }
        setDuration(t) {
            return this.timeScale = this._clip.duration / t,
            this.stopWarping()
        }
        syncWith(t) {
            return this.time = t.time,
            this.timeScale = t.timeScale,
            this.stopWarping()
        }
        halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        }
        warp(t, e, n) {
            const i = this._mixer
              , r = i.time
              , o = this.timeScale;
            let s = this._timeScaleInterpolant;
            null === s && (s = i._lendControlInterpolant(),
            this._timeScaleInterpolant = s);
            const a = s.parameterPositions
              , l = s.sampleValues;
            return a[0] = r,
            a[1] = r + n,
            l[0] = t / o,
            l[1] = e / o,
            this
        }
        stopWarping() {
            const t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(t)),
            this
        }
        getMixer() {
            return this._mixer
        }
        getClip() {
            return this._clip
        }
        getRoot() {
            return this._localRoot || this._mixer._root
        }
        _update(t, e, n, i) {
            if (!this.enabled)
                return void this._updateWeight(t);
            const r = this._startTime;
            if (null !== r) {
                const i = (t - r) * n;
                if (i < 0 || 0 === n)
                    return;
                this._startTime = null,
                e = n * i
            }
            e *= this._updateTimeScale(t);
            const o = this._updateTime(e)
              , s = this._updateWeight(t);
            if (s > 0) {
                const t = this._interpolants
                  , e = this._propertyBindings;
                switch (this.blendMode) {
                case 2501:
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n].evaluate(o),
                        e[n].accumulateAdditive(s);
                    break;
                case j:
                default:
                    for (let n = 0, r = t.length; n !== r; ++n)
                        t[n].evaluate(o),
                        e[n].accumulate(i, s)
                }
            }
        }
        _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
                e = this.weight;
                const n = this._weightInterpolant;
                if (null !== n) {
                    const i = n.evaluate(t)[0];
                    e *= i,
                    t > n.parameterPositions[1] && (this.stopFading(),
                    0 === i && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e,
            e
        }
        _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
                e = this.timeScale;
                const n = this._timeScaleInterpolant;
                if (null !== n) {
                    e *= n.evaluate(t)[0],
                    t > n.parameterPositions[1] && (this.stopWarping(),
                    0 === e ? this.paused = !0 : this.timeScale = e)
                }
            }
            return this._effectiveTimeScale = e,
            e
        }
        _updateTime(t) {
            const e = this._clip.duration
              , n = this.loop;
            let i = this.time + t
              , r = this._loopCount;
            const o = 2202 === n;
            if (0 === t)
                return -1 === r ? i : o && 1 == (1 & r) ? e - i : i;
            if (2200 === n) {
                -1 === r && (this._loopCount = 0,
                this._setEndings(!0, !0, !1));
                t: {
                    if (i >= e)
                        i = e;
                    else {
                        if (!(i < 0)) {
                            this.time = i;
                            break t
                        }
                        i = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (t >= 0 ? (r = 0,
                this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)),
                i >= e || i < 0) {
                    const n = Math.floor(i / e);
                    i -= e * n,
                    r += Math.abs(n);
                    const s = this.repetitions - r;
                    if (s <= 0)
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        i = t > 0 ? e : 0,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        });
                    else {
                        if (1 === s) {
                            const e = t < 0;
                            this._setEndings(e, !e, o)
                        } else
                            this._setEndings(!1, !1, o);
                        this._loopCount = r,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: n
                        })
                    }
                } else
                    this.time = i;
                if (o && 1 == (1 & r))
                    return e - i
            }
            return i
        }
        _setEndings(t, e, n) {
            const i = this._interpolantSettings;
            n ? (i.endingStart = G,
            i.endingEnd = G) : (i.endingStart = t ? this.zeroSlopeAtStart ? G : H : V,
            i.endingEnd = e ? this.zeroSlopeAtEnd ? G : H : V)
        }
        _scheduleFading(t, e, n) {
            const i = this._mixer
              , r = i.time;
            let o = this._weightInterpolant;
            null === o && (o = i._lendControlInterpolant(),
            this._weightInterpolant = o);
            const s = o.parameterPositions
              , a = o.sampleValues;
            return s[0] = r,
            a[0] = e,
            s[1] = r + t,
            a[1] = n,
            this
        }
    }
    function Zl(t) {
        this._root = t,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    Zl.prototype = Object.assign(Object.create($.prototype), {
        constructor: Zl,
        _bindAction: function(t, e) {
            const n = t._localRoot || this._root
              , i = t._clip.tracks
              , r = i.length
              , o = t._propertyBindings
              , s = t._interpolants
              , a = n.uuid
              , l = this._bindingsByRootAndName;
            let c = l[a];
            void 0 === c && (c = {},
            l[a] = c);
            for (let t = 0; t !== r; ++t) {
                const r = i[t]
                  , l = r.name;
                let u = c[l];
                if (void 0 !== u)
                    o[t] = u;
                else {
                    if (u = o[t],
                    void 0 !== u) {
                        null === u._cacheIndex && (++u.referenceCount,
                        this._addInactiveBinding(u, a, l));
                        continue
                    }
                    const i = e && e._propertyBindings[t].binding.parsedPath;
                    u = new Nl(Xl.create(n, l, i),r.ValueTypeName,r.getValueSize()),
                    ++u.referenceCount,
                    this._addInactiveBinding(u, a, l),
                    o[t] = u
                }
                s[t].resultBuffer = u.buffer
            }
        },
        _activateAction: function(t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    const e = (t._localRoot || this._root).uuid
                      , n = t._clip.uuid
                      , i = this._actionsByClip[n];
                    this._bindAction(t, i && i.knownActions[0]),
                    this._addInactiveAction(t, n, e)
                }
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == n.useCount++ && (this._lendBinding(n),
                    n.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function(t) {
            if (this._isActiveAction(t)) {
                const e = t._propertyBindings;
                for (let t = 0, n = e.length; t !== n; ++t) {
                    const n = e[t];
                    0 == --n.useCount && (n.restoreOriginalState(),
                    this._takeBackBinding(n))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            const t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(t) {
            const e = t._cacheIndex;
            return null !== e && e < this._nActiveActions
        },
        _addInactiveAction: function(t, e, n) {
            const i = this._actions
              , r = this._actionsByClip;
            let o = r[e];
            if (void 0 === o)
                o = {
                    knownActions: [t],
                    actionByRoot: {}
                },
                t._byClipCacheIndex = 0,
                r[e] = o;
            else {
                const e = o.knownActions;
                t._byClipCacheIndex = e.length,
                e.push(t)
            }
            t._cacheIndex = i.length,
            i.push(t),
            o.actionByRoot[n] = t
        },
        _removeInactiveAction: function(t) {
            const e = this._actions
              , n = e[e.length - 1]
              , i = t._cacheIndex;
            n._cacheIndex = i,
            e[i] = n,
            e.pop(),
            t._cacheIndex = null;
            const r = t._clip.uuid
              , o = this._actionsByClip
              , s = o[r]
              , a = s.knownActions
              , l = a[a.length - 1]
              , c = t._byClipCacheIndex;
            l._byClipCacheIndex = c,
            a[c] = l,
            a.pop(),
            t._byClipCacheIndex = null;
            delete s.actionByRoot[(t._localRoot || this._root).uuid],
            0 === a.length && delete o[r],
            this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function(t) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        },
        _lendAction: function(t) {
            const e = this._actions
              , n = t._cacheIndex
              , i = this._nActiveActions++
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _takeBackAction: function(t) {
            const e = this._actions
              , n = t._cacheIndex
              , i = --this._nActiveActions
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _addInactiveBinding: function(t, e, n) {
            const i = this._bindingsByRootAndName
              , r = this._bindings;
            let o = i[e];
            void 0 === o && (o = {},
            i[e] = o),
            o[n] = t,
            t._cacheIndex = r.length,
            r.push(t)
        },
        _removeInactiveBinding: function(t) {
            const e = this._bindings
              , n = t.binding
              , i = n.rootNode.uuid
              , r = n.path
              , o = this._bindingsByRootAndName
              , s = o[i]
              , a = e[e.length - 1]
              , l = t._cacheIndex;
            a._cacheIndex = l,
            e[l] = a,
            e.pop(),
            delete s[r],
            0 === Object.keys(s).length && delete o[i]
        },
        _lendBinding: function(t) {
            const e = this._bindings
              , n = t._cacheIndex
              , i = this._nActiveBindings++
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _takeBackBinding: function(t) {
            const e = this._bindings
              , n = t._cacheIndex
              , i = --this._nActiveBindings
              , r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _lendControlInterpolant: function() {
            const t = this._controlInterpolants
              , e = this._nActiveControlInterpolants++;
            let n = t[e];
            return void 0 === n && (n = new la(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),
            n.__cacheIndex = e,
            t[e] = n),
            n
        },
        _takeBackControlInterpolant: function(t) {
            const e = this._controlInterpolants
              , n = t.__cacheIndex
              , i = --this._nActiveControlInterpolants
              , r = e[i];
            t.__cacheIndex = i,
            e[i] = t,
            r.__cacheIndex = n,
            e[n] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(t, e, n) {
            const i = e || this._root
              , r = i.uuid;
            let o = "string" == typeof t ? ya.findByName(i, t) : t;
            const s = null !== o ? o.uuid : t
              , a = this._actionsByClip[s];
            let l = null;
            if (void 0 === n && (n = null !== o ? o.blendMode : j),
            void 0 !== a) {
                const t = a.actionByRoot[r];
                if (void 0 !== t && t.blendMode === n)
                    return t;
                l = a.knownActions[0],
                null === o && (o = l._clip)
            }
            if (null === o)
                return null;
            const c = new Yl(this,o,e,n);
            return this._bindAction(c, l),
            this._addInactiveAction(c, s, r),
            c
        },
        existingAction: function(t, e) {
            const n = e || this._root
              , i = n.uuid
              , r = "string" == typeof t ? ya.findByName(n, t) : t
              , o = r ? r.uuid : t
              , s = this._actionsByClip[o];
            return void 0 !== s && s.actionByRoot[i] || null
        },
        stopAllAction: function() {
            const t = this._actions;
            for (let e = this._nActiveActions - 1; e >= 0; --e)
                t[e].stop();
            return this
        },
        update: function(t) {
            t *= this.timeScale;
            const e = this._actions
              , n = this._nActiveActions
              , i = this.time += t
              , r = Math.sign(t)
              , o = this._accuIndex ^= 1;
            for (let s = 0; s !== n; ++s) {
                e[s]._update(i, t, r, o)
            }
            const s = this._bindings
              , a = this._nActiveBindings;
            for (let t = 0; t !== a; ++t)
                s[t].apply(o);
            return this
        },
        setTime: function(t) {
            this.time = 0;
            for (let t = 0; t < this._actions.length; t++)
                this._actions[t].time = 0;
            return this.update(t)
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(t) {
            const e = this._actions
              , n = t.uuid
              , i = this._actionsByClip
              , r = i[n];
            if (void 0 !== r) {
                const t = r.knownActions;
                for (let n = 0, i = t.length; n !== i; ++n) {
                    const i = t[n];
                    this._deactivateAction(i);
                    const r = i._cacheIndex
                      , o = e[e.length - 1];
                    i._cacheIndex = null,
                    i._byClipCacheIndex = null,
                    o._cacheIndex = r,
                    e[r] = o,
                    e.pop(),
                    this._removeInactiveBindingsForAction(i)
                }
                delete i[n]
            }
        },
        uncacheRoot: function(t) {
            const e = t.uuid
              , n = this._actionsByClip;
            for (const t in n) {
                const i = n[t].actionByRoot[e];
                void 0 !== i && (this._deactivateAction(i),
                this._removeInactiveAction(i))
            }
            const i = this._bindingsByRootAndName[e];
            if (void 0 !== i)
                for (const t in i) {
                    const e = i[t];
                    e.restoreOriginalState(),
                    this._removeInactiveBinding(e)
                }
        },
        uncacheAction: function(t, e) {
            const n = this.existingAction(t, e);
            null !== n && (this._deactivateAction(n),
            this._removeInactiveAction(n))
        }
    });
    class Jl {
        constructor(t) {
            "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
            t = arguments[1]),
            this.value = t
        }
        clone() {
            return new Jl(void 0 === this.value.clone ? this.value : this.value.clone())
        }
    }
    function Ql(t, e, n) {
        no.call(this, t, e),
        this.meshPerAttribute = n || 1
    }
    function Kl(t, e, n, i, r) {
        this.buffer = t,
        this.type = e,
        this.itemSize = n,
        this.elementSize = i,
        this.count = r,
        this.version = 0
    }
    function $l(t, e, n, i) {
        this.ray = new Ht(t,e),
        this.near = n || 0,
        this.far = i || 1 / 0,
        this.camera = null,
        this.layers = new $t,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function tc(t, e) {
        return t.distance - e.distance
    }
    function ec(t, e, n, i) {
        if (t.layers.test(e.layers) && t.raycast(e, n),
        !0 === i) {
            const i = t.children;
            for (let t = 0, r = i.length; t < r; t++)
                ec(i[t], e, n, !0)
        }
    }
    Ql.prototype = Object.assign(Object.create(no.prototype), {
        constructor: Ql,
        isInstancedInterleavedBuffer: !0,
        copy: function(t) {
            return no.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        },
        clone: function(t) {
            const e = no.prototype.clone.call(this, t);
            return e.meshPerAttribute = this.meshPerAttribute,
            e
        },
        toJSON: function(t) {
            const e = no.prototype.toJSON.call(this, t);
            return e.isInstancedInterleavedBuffer = !0,
            e.meshPerAttribute = this.meshPerAttribute,
            e
        }
    }),
    Object.defineProperty(Kl.prototype, "needsUpdate", {
        set: function(t) {
            !0 === t && this.version++
        }
    }),
    Object.assign(Kl.prototype, {
        isGLBufferAttribute: !0,
        setBuffer: function(t) {
            return this.buffer = t,
            this
        },
        setType: function(t, e) {
            return this.type = t,
            this.elementSize = e,
            this
        },
        setItemSize: function(t) {
            return this.itemSize = t,
            this
        },
        setCount: function(t) {
            return this.count = t,
            this
        }
    }),
    Object.assign($l.prototype, {
        set: function(t, e) {
            this.ray.set(t, e)
        },
        setFromCamera: function(t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(),
            this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e),
            this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
            this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
        },
        intersectObject: function(t, e, n) {
            const i = n || [];
            return ec(t, this, i, e),
            i.sort(tc),
            i
        },
        intersectObjects: function(t, e, n) {
            const i = n || [];
            if (!1 === Array.isArray(t))
                return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
                i;
            for (let n = 0, r = t.length; n < r; n++)
                ec(t[n], this, i, e);
            return i.sort(tc),
            i
        }
    });
    const nc = new it;
    const ic = new ft
      , rc = new ft;
    function oc(t) {
        pe.call(this),
        this.material = t,
        this.render = function() {}
        ,
        this.hasPositions = !1,
        this.hasNormals = !1,
        this.hasColors = !1,
        this.hasUvs = !1,
        this.positionArray = null,
        this.normalArray = null,
        this.colorArray = null,
        this.uvArray = null,
        this.count = 0
    }
    oc.prototype = Object.create(pe.prototype),
    oc.prototype.constructor = oc,
    oc.prototype.isImmediateRenderObject = !0;
    const sc = new ft
      , ac = new Gt
      , lc = new Gt;
    const cc = new Float32Array(1)
      , uc = (new Int32Array(cc.buffer),
    Math.pow(2, 8),
    [.125, .215, .35, .446, .526, .582])
      , hc = 5 + uc.length
      , {_lodPlanes: dc, _sizeLods: pc, _sigmas: fc} = mc();
    Math.sqrt(5);
    function mc() {
        const t = []
          , e = []
          , n = [];
        let i = 8;
        for (let r = 0; r < hc; r++) {
            const o = Math.pow(2, i);
            e.push(o);
            let s = 1 / o;
            r > 4 ? s = uc[r - 8 + 4 - 1] : 0 == r && (s = 0),
            n.push(s);
            const a = 1 / (o - 1)
              , l = -a / 2
              , c = 1 + a / 2
              , u = [l, l, c, l, c, c, l, l, c, c, l, c]
              , h = 6
              , d = 6
              , p = 3
              , f = 2
              , m = 1
              , g = new Float32Array(p * d * h)
              , v = new Float32Array(f * d * h)
              , y = new Float32Array(m * d * h);
            for (let t = 0; t < h; t++) {
                const e = t % 3 * 2 / 3 - 1
                  , n = t > 2 ? 0 : -1
                  , i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                g.set(i, p * d * t),
                v.set(u, f * d * t);
                const r = [t, t, t, t, t, t];
                y.set(r, m * d * t)
            }
            const _ = new hn;
            _.setAttribute("position", new Ge(g,p)),
            _.setAttribute("uv", new Ge(v,f)),
            _.setAttribute("faceIndex", new Ge(y,m)),
            t.push(_),
            i > 4 && i--
        }
        return {
            _lodPlanes: t,
            _sizeLods: e,
            _sigmas: n
        }
    }
    function gc(t) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
        Ua.call(this, t),
        this.type = "catmullrom"
    }
    Ra.create = function(t, e) {
        return console.log("THREE.Curve.create() has been deprecated"),
        t.prototype = Object.create(Ra.prototype),
        t.prototype.constructor = t,
        t.prototype.getPoint = e,
        t
    }
    ,
    Object.assign(Ka.prototype, {
        createPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            const e = this.getPoints(t);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(t) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            const e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        },
        createGeometry: function(t) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            const e = new ds;
            for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n];
                e.vertices.push(new ft(i.x,i.y,i.z || 0))
            }
            return e
        }
    }),
    Object.assign($a.prototype, {
        fromPoints: function(t) {
            return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(t)
        }
    }),
    Object.create(Ua.prototype),
    Object.create(Ua.prototype),
    gc.prototype = Object.create(Ua.prototype),
    Object.assign(gc.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }),
    class extends Zo {
        constructor(t=10, e=10, n=4473924, i=8947848) {
            n = new Ne(n),
            i = new Ne(i);
            const r = e / 2
              , o = t / e
              , s = t / 2
              , a = []
              , l = [];
            for (let t = 0, c = 0, u = -s; t <= e; t++,
            u += o) {
                a.push(-s, 0, u, s, 0, u),
                a.push(u, 0, -s, u, 0, s);
                const e = t === r ? n : i;
                e.toArray(l, c),
                c += 3,
                e.toArray(l, c),
                c += 3,
                e.toArray(l, c),
                c += 3,
                e.toArray(l, c),
                c += 3
            }
            const c = new hn;
            c.setAttribute("position", new Qe(a,3)),
            c.setAttribute("color", new Qe(l,3));
            super(c, new Uo({
                vertexColors: !0,
                toneMapped: !1
            })),
            this.type = "GridHelper"
        }
    }
    .prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    class extends Zo {
        constructor(t) {
            const e = function t(e) {
                const n = [];
                e && e.isBone && n.push(e);
                for (let i = 0; i < e.children.length; i++)
                    n.push.apply(n, t(e.children[i]));
                return n
            }(t)
              , n = new hn
              , i = []
              , r = []
              , o = new Ne(0,0,1)
              , s = new Ne(0,1,0);
            for (let t = 0; t < e.length; t++) {
                const n = e[t];
                n.parent && n.parent.isBone && (i.push(0, 0, 0),
                i.push(0, 0, 0),
                r.push(o.r, o.g, o.b),
                r.push(s.r, s.g, s.b))
            }
            n.setAttribute("position", new Qe(i,3)),
            n.setAttribute("color", new Qe(r,3));
            super(n, new Uo({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0
            })),
            this.type = "SkeletonHelper",
            this.isSkeletonHelper = !0,
            this.root = t,
            this.bones = e,
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = !1
        }
        updateMatrixWorld(t) {
            const e = this.bones
              , n = this.geometry
              , i = n.getAttribute("position");
            lc.copy(this.root.matrixWorld).invert();
            for (let t = 0, n = 0; t < e.length; t++) {
                const r = e[t];
                r.parent && r.parent.isBone && (ac.multiplyMatrices(lc, r.matrixWorld),
                sc.setFromMatrixPosition(ac),
                i.setXYZ(n, sc.x, sc.y, sc.z),
                ac.multiplyMatrices(lc, r.parent.matrixWorld),
                sc.setFromMatrixPosition(ac),
                i.setXYZ(n + 1, sc.x, sc.y, sc.z),
                n += 2)
            }
            n.getAttribute("position").needsUpdate = !0,
            super.updateMatrixWorld(t)
        }
    }
    .prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    Object.assign(Ma.prototype, {
        extractUrlBase: function(t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            gl(t)
        }
    }),
    Ma.Handlers = {
        add: function() {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function() {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    },
    Object.assign(class {
        constructor(t, e) {
            Object.defineProperty(this, "isBox2", {
                value: !0
            }),
            this.min = void 0 !== t ? t : new it(1 / 0,1 / 0),
            this.max = void 0 !== e ? e : new it(-1 / 0,-1 / 0)
        }
        set(t, e) {
            return this.min.copy(t),
            this.max.copy(e),
            this
        }
        setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++)
                this.expandByPoint(t[e]);
            return this
        }
        setFromCenterAndSize(t, e) {
            const n = nc.copy(e).multiplyScalar(.5);
            return this.min.copy(t).sub(n),
            this.max.copy(t).add(n),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.min.copy(t.min),
            this.max.copy(t.max),
            this
        }
        makeEmpty() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        }
        getCenter(t) {
            return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"),
            t = new it),
            this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(t) {
            return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"),
            t = new it),
            this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        }
        expandByPoint(t) {
            return this.min.min(t),
            this.max.max(t),
            this
        }
        expandByVector(t) {
            return this.min.sub(t),
            this.max.add(t),
            this
        }
        expandByScalar(t) {
            return this.min.addScalar(-t),
            this.max.addScalar(t),
            this
        }
        containsPoint(t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        }
        containsBox(t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        }
        getParameter(t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"),
            e = new it),
            e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        }
        intersectsBox(t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        }
        clampPoint(t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"),
            e = new it),
            e.copy(t).clamp(this.min, this.max)
        }
        distanceToPoint(t) {
            return nc.copy(t).clamp(this.min, this.max).sub(t).length()
        }
        intersect(t) {
            return this.min.max(t.min),
            this.max.min(t.max),
            this
        }
        union(t) {
            return this.min.min(t.min),
            this.max.max(t.max),
            this
        }
        translate(t) {
            return this.min.add(t),
            this.max.add(t),
            this
        }
        equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }
    .prototype, {
        center: function(t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        },
        size: function(t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
    }),
    Object.assign(vt.prototype, {
        center: function(t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(t)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        },
        size: function(t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(t)
        }
    }),
    Object.assign(Ot.prototype, {
        empty: function() {
            return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
    }),
    qn.prototype.setFromMatrix = function(t) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
        this.setFromProjectionMatrix(t)
    }
    ,
    class {
        constructor(t, e) {
            this.start = void 0 !== t ? t : new ft,
            this.end = void 0 !== e ? e : new ft
        }
        set(t, e) {
            return this.start.copy(t),
            this.end.copy(e),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(t) {
            return this.start.copy(t.start),
            this.end.copy(t.end),
            this
        }
        getCenter(t) {
            return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"),
            t = new ft),
            t.addVectors(this.start, this.end).multiplyScalar(.5)
        }
        delta(t) {
            return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"),
            t = new ft),
            t.subVectors(this.end, this.start)
        }
        distanceSq() {
            return this.start.distanceToSquared(this.end)
        }
        distance() {
            return this.start.distanceTo(this.end)
        }
        at(t, e) {
            return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"),
            e = new ft),
            this.delta(e).multiplyScalar(t).add(this.start)
        }
        closestPointToPointParameter(t, e) {
            ic.subVectors(t, this.start),
            rc.subVectors(this.end, this.start);
            const n = rc.dot(rc);
            let i = rc.dot(ic) / n;
            return e && (i = nt.clamp(i, 0, 1)),
            i
        }
        closestPointToPoint(t, e, n) {
            const i = this.closestPointToPointParameter(t, e);
            return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
            n = new ft),
            this.delta(n).multiplyScalar(i).add(this.start)
        }
        applyMatrix4(t) {
            return this.start.applyMatrix4(t),
            this.end.applyMatrix4(t),
            this
        }
        equals(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }
    .prototype.center = function(t) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
        this.getCenter(t)
    }
    ,
    Object.assign(nt, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random()
        },
        nearestPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            nt.floorPowerOfTwo(t)
        },
        nextPowerOfTwo: function(t) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            nt.ceilPowerOfTwo(t)
        }
    }),
    Object.assign(rt.prototype, {
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBufferAttribute: function(t) {
            return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
            t.applyMatrix3(this)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        },
        getInverse: function(t) {
            return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
            this.copy(t).invert()
        }
    }),
    Object.assign(Gt.prototype, {
        extractPosition: function(t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(t)
        },
        flattenToArrayOffset: function(t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(t, e)
        },
        getPosition: function() {
            return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            (new ft).setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function(t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(t)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        multiplyVector4: function(t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            t.transformDirection(this)
        },
        crossVector: function(t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBufferAttribute: function(t) {
            return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
            t.applyMatrix4(this)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(t, e, n, i, r, o) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(t, e, i, n, r, o)
        },
        getInverse: function(t) {
            return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
            this.copy(t).invert()
        }
    }),
    ve.prototype.isIntersectionLine = function(t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(t)
    }
    ,
    Object.assign(pt.prototype, {
        multiplyVector3: function(t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
            t.applyQuaternion(this)
        },
        inverse: function() {
            return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
            this.invert()
        }
    }),
    Object.assign(Ht.prototype, {
        isIntersectionBox: function(t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(t)
        },
        isIntersectionPlane: function(t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(t)
        },
        isIntersectionSphere: function(t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(t)
        }
    }),
    Object.assign(Ae.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        },
        barycoordFromPoint: function(t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(t, e)
        },
        midpoint: function(t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(t)
        },
        normal: function(t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(t)
        },
        plane: function(t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(t)
        }
    }),
    Object.assign(Ae, {
        barycoordFromPoint: function(t, e, n, i, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            Ae.getBarycoord(t, e, n, i, r)
        },
        normal: function(t, e, n, i) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            Ae.getNormal(t, e, n, i)
        }
    }),
    Object.assign(tl.prototype, {
        extractAllPoints: function(t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(t)
        },
        extrude: function(t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new Vs(this,t)
        },
        makeGeometry: function(t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new Xs(this,t)
        }
    }),
    Object.assign(it.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(ft.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(t)
        },
        getScaleFromMatrix: function(t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(t)
        },
        getColumnFromMatrix: function(t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(e, t)
        },
        applyProjection: function(t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(t)
        },
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        },
        distanceToManhattan: function(t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(t)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(ut.prototype, {
        fromAttribute: function(t, e, n) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(t, e, n)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(ds.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        },
        applyMatrix: function(t) {
            return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(t)
        }
    }),
    Object.assign(pe.prototype, {
        getChildByName: function(t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(t)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(e, t)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        },
        applyMatrix: function(t) {
            return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(t)
        }
    }),
    Object.defineProperties(pe.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = t
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Object.assign(Cn.prototype, {
        setDrawMode: function() {
            console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
    }),
    Object.defineProperties(Cn.prototype, {
        drawMode: {
            get: function() {
                return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                0
            },
            set: function() {
                console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }),
    Object.defineProperties(So.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                this.levels
            }
        }
    }),
    Object.defineProperty(Fo.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }),
    Lo.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }
    ,
    Object.defineProperty(Ra.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions
        },
        set: function(t) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = t
        }
    }),
    kn.prototype.setLens = function(t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t)
    }
    ,
    Object.defineProperties(el.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = t
            }
        },
        shadowCameraLeft: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = t
            }
        },
        shadowCameraRight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = t
            }
        },
        shadowCameraTop: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = t
            }
        },
        shadowCameraBottom: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = t
            }
        },
        shadowCameraNear: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = t
            }
        },
        shadowCameraFar: {
            set: function(t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = t
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = t
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = t
            }
        },
        shadowMapHeight: {
            set: function(t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = t
            }
        }
    }),
    Object.defineProperties(Ge.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        dynamic: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.usage === Q
            },
            set: function() {
                console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.setUsage(Q)
            }
        }
    }),
    Object.assign(Ge.prototype, {
        setDynamic: function(t) {
            return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === t ? Q : J),
            this
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        },
        setArray: function() {
            console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }),
    Object.assign(hn.prototype, {
        addIndex: function(t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(t)
        },
        addAttribute: function(t, e) {
            return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
            e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(e),
            this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            this.setAttribute(t, new Ge(arguments[1],arguments[2])))
        },
        addDrawCall: function(t, e, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(t, e)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        },
        removeAttribute: function(t) {
            return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
            this.deleteAttribute(t)
        },
        applyMatrix: function(t) {
            return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
            this.applyMatrix4(t)
        }
    }),
    Object.defineProperties(hn.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Object.defineProperties(vl.prototype, {
        maxInstancedCount: {
            get: function() {
                return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                this.instanceCount
            },
            set: function(t) {
                console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                this.instanceCount = t
            }
        }
    }),
    Object.defineProperties($l.prototype, {
        linePrecision: {
            get: function() {
                return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                this.params.Line.threshold
            },
            set: function(t) {
                console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                this.params.Line.threshold = t
            }
        }
    }),
    Object.defineProperties(no.prototype, {
        dynamic: {
            get: function() {
                return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                this.usage === Q
            },
            set: function(t) {
                console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                this.setUsage(t)
            }
        }
    }),
    Object.assign(no.prototype, {
        setDynamic: function(t) {
            return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
            this.setUsage(!0 === t ? Q : J),
            this
        },
        setArray: function() {
            console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
        }
    }),
    Object.assign(Hs.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }),
    Object.assign(eo.prototype, {
        dispose: function() {
            console.error("THREE.Scene: .dispose() has been removed.")
        }
    }),
    Object.defineProperties(Jl.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this
            }
        }
    }),
    Object.defineProperties(ke.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new Ne
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = 1 === t
            }
        },
        stencilMask: {
            get: function() {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask
            },
            set: function(t) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask = t
            }
        }
    }),
    Object.defineProperties(Ks.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }),
    Object.defineProperties(Qs.prototype, {
        transparency: {
            get: function() {
                return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                this.transmission
            },
            set: function(t) {
                console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                this.transmission = t
            }
        }
    }),
    Object.defineProperties(In.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = t
            }
        }
    }),
    Object.assign($r.prototype, {
        clearTarget: function(t, e, n, i) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
            this.setRenderTarget(t),
            this.clear(e, n, i)
        },
        animate: function(t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
            this.setAnimationLoop(t)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(t)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        },
        allocTextureUnit: function() {
            console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
        },
        setTexture: function() {
            console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
        },
        setTexture2D: function() {
            console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
        },
        setTextureCube: function() {
            console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
        },
        getActiveMipMapLevel: function() {
            return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
            this.getActiveMipmapLevel()
        }
    }),
    Object.defineProperties($r.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = t
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = t
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                this.getContext()
            }
        },
        vr: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                this.xr
            }
        },
        gammaInput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                !1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                !1
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                this.outputEncoding = !0 === t ? q : W
            }
        },
        toneMappingWhitePoint: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
                1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
            }
        }
    }),
    Object.defineProperties(jr.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(ht.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = t
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = t
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = t
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = t
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = t
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = t
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = t
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = t
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = t
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = t
            }
        }
    }),
    Object.defineProperties(Fl.prototype, {
        load: {
            value: function(t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                const e = this;
                return (new Tl).load(t, (function(t) {
                    e.setBuffer(t)
                }
                )),
                this
            }
        },
        startTime: {
            set: function() {
                console.warn("THREE.Audio: .startTime is now .play( delay ).")
            }
        }
    }),
    class {
        constructor(t, e=2048) {
            this.analyser = t.context.createAnalyser(),
            this.analyser.fftSize = e,
            this.data = new Uint8Array(this.analyser.frequencyBinCount),
            t.getOutput().connect(this.analyser)
        }
        getFrequencyData() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        }
        getAverageFrequency() {
            let t = 0;
            const e = this.getFrequencyData();
            for (let n = 0; n < e.length; n++)
                t += e[n];
            return t / e.length
        }
    }
    .prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
        this.getFrequencyData()
    }
    ,
    Un.prototype.updateCubeMap = function(t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(t, e)
    }
    ,
    Un.prototype.clear = function(t, e, n, i) {
        return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
        this.renderTarget.clear(t, e, n, i)
    }
    ;
    st.crossOrigin = void 0,
    st.loadTexture = function(t, e, n, i) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const r = new Pa;
        r.setCrossOrigin(this.crossOrigin);
        const o = r.load(t, n, void 0, i);
        return e && (o.mapping = e),
        o
    }
    ,
    st.loadTextureCube = function(t, e, n, i) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const r = new Ca;
        r.setCrossOrigin(this.crossOrigin);
        const o = r.load(t, n, void 0, i);
        return e && (o.mapping = e),
        o
    }
    ,
    st.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    st.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
    ;
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
        detail: {
            revision: "124"
        }
    }));
    var vc = function(t, e) {
        var n = new Pa
          , i = [];
        return t.forEach((function(e, r) {
            var o = t[r];
            i.push(function(t, e, n) {
                return new Promise((function(i, r) {
                    e ? t.load(e, (function(t) {
                        i({
                            texture: t,
                            index: n
                        })
                    }
                    ), void 0, (function(t) {
                        console.error("An error happened.", t),
                        r(t)
                    }
                    )) : i({
                        texture: null,
                        index: n
                    })
                }
                ))
            }(n, o || null, r))
        }
        )),
        new Promise((function(t, n) {
            Promise.all(i).then((function(n) {
                n.forEach((function(t, n) {
                    e[n].texture = t.texture,
                    e[n].index = n
                }
                )),
                t()
            }
            ))
        }
        ))
    };
    function yc(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function _c(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    var xc = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            yc(this, t),
            this.delay = e.delay,
            this.cb = e.cb,
            this.onlyAtEnd = e.onlyAtEnd,
            this.last,
            this.timer
        }
        var e, n, i;
        return e = t,
        (n = [{
            key: "init",
            value: function() {
                var t = this
                  , e = !0
                  , n = Date.now();
                this.last && n < this.last + this.delay || e ? (e = !1,
                clearTimeout(this.timer),
                this.timer = setTimeout((function() {
                    t.last = n,
                    t.cb()
                }
                ), this.delay)) : (this.last = n,
                this.onlyAtEnd || (e = !1,
                this.cb()))
            }
        }]) && _c(e.prototype, n),
        i && _c(e, i),
        t
    }()
      , bc = {
        title: "Antara Studio",
        author: "mariosmaselli",
        link: "https://twitter.com/mariosmaselli",
        body: document.body,
        main: i("main"),
        header: i("header"),
        page: i(".page"),
        footer: i("footer"),
        vw: u().width,
        vh: u().height,
        sniff: d.sniff,
        sizes: h(),
        bounds: {},
        smooth: {
            current: 0
        },
        flags: {
            smooth: !0,
            locked: !0,
            resize: !1,
            preloaded: !1,
            load: !1
        }
    };
    function wc() {}
    wc.prototype = {
        on: function(t, e, n) {
            var i = this.e || (this.e = {});
            return (i[t] || (i[t] = [])).push({
                fn: e,
                ctx: n
            }),
            this
        },
        once: function(t, e, n) {
            var i = this;
            function r() {
                i.off(t, r),
                e.apply(n, arguments)
            }
            return r._ = e,
            this.on(t, r, n)
        },
        emit: function(t) {
            for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++)
                n[i].fn.apply(n[i].ctx, e);
            return this
        },
        off: function(t, e) {
            var n = this.e || (this.e = {})
              , i = n[t]
              , r = [];
            if (i && e)
                for (var o = 0, s = i.length; o < s; o++)
                    i[o].fn !== e && i[o].fn._ !== e && r.push(i[o]);
            return r.length ? n[t] = r : delete n[t],
            this
        }
    };
    var Mc = wc;
    Mc.TinyEmitter = wc;
    var Sc = function(t) {
        this.wrap = document.querySelector("[data-router-wrapper]"),
        this.properties = t,
        this.Transition = t.transition ? new t.transition.class(this.wrap,t.transition.name) : null
    };
    Sc.prototype.setup = function() {
        this.onEnter && this.onEnter(),
        this.onEnterCompleted && this.onEnterCompleted()
    }
    ,
    Sc.prototype.add = function() {
        this.wrap.insertAdjacentHTML("beforeend", this.properties.view.outerHTML)
    }
    ,
    Sc.prototype.update = function() {
        document.title = this.properties.page.title
    }
    ,
    Sc.prototype.show = function(t) {
        var e = this;
        return new Promise((function(n) {
            try {
                function i(t) {
                    e.onEnterCompleted && e.onEnterCompleted(),
                    n()
                }
                return e.update(),
                e.onEnter && e.onEnter(),
                Promise.resolve(e.Transition ? Promise.resolve(e.Transition.show(t)).then(i) : i())
            } catch (t) {
                return Promise.reject(t)
            }
        }
        ))
    }
    ,
    Sc.prototype.hide = function(t) {
        var e = this;
        return new Promise((function(n) {
            try {
                function i(t) {
                    e.onLeaveCompleted && e.onLeaveCompleted(),
                    n()
                }
                return e.onLeave && e.onLeave(),
                Promise.resolve(e.Transition ? Promise.resolve(e.Transition.hide(t)).then(i) : i())
            } catch (t) {
                return Promise.reject(t)
            }
        }
        ))
    }
    ;
    var Ec = new window.DOMParser
      , Dc = function(t, e) {
        this.renderers = t,
        this.transitions = e
    };
    Dc.prototype.getOrigin = function(t) {
        var e = t.match(/(https?:\/\/[\w\-.]+)/);
        return e ? e[1].replace(/https?:\/\//, "") : null
    }
    ,
    Dc.prototype.getPathname = function(t) {
        var e = t.match(/https?:\/\/.*?(\/[\w_\-./]+)/);
        return e ? e[1] : "/"
    }
    ,
    Dc.prototype.getAnchor = function(t) {
        var e = t.match(/(#.*)$/);
        return e ? e[1] : null
    }
    ,
    Dc.prototype.getParams = function(t) {
        var e = t.match(/\?([\w_\-.=&]+)/);
        if (!e)
            return null;
        for (var n = e[1].split("&"), i = {}, r = 0; r < n.length; r++) {
            var o = n[r].split("=");
            i[o[0]] = o[1]
        }
        return i
    }
    ,
    Dc.prototype.getDOM = function(t) {
        return "string" == typeof t ? Ec.parseFromString(t, "text/html") : t
    }
    ,
    Dc.prototype.getView = function(t) {
        return t.querySelector("[data-router-view]")
    }
    ,
    Dc.prototype.getSlug = function(t) {
        return t.getAttribute("data-router-view")
    }
    ,
    Dc.prototype.getRenderer = function(t) {
        if (!this.renderers)
            return Promise.resolve(Sc);
        if (t in this.renderers) {
            var e = this.renderers[t];
            return "function" != typeof e || Sc.isPrototypeOf(e) ? "function" == typeof e.then ? Promise.resolve(e).then((function(t) {
                return t.default
            }
            )) : Promise.resolve(e) : Promise.resolve(e()).then((function(t) {
                return t.default
            }
            ))
        }
        return Promise.resolve(Sc)
    }
    ,
    Dc.prototype.getTransition = function(t) {
        return this.transitions ? t in this.transitions ? {
            class: this.transitions[t],
            name: t
        } : "default"in this.transitions ? {
            class: this.transitions.default,
            name: "default"
        } : null : null
    }
    ,
    Dc.prototype.getProperties = function(t) {
        var e = this.getDOM(t)
          , n = this.getView(e)
          , i = this.getSlug(n);
        return {
            page: e,
            view: n,
            slug: i,
            renderer: this.getRenderer(i, this.renderers),
            transition: this.getTransition(i, this.transitions)
        }
    }
    ,
    Dc.prototype.getLocation = function(t) {
        return {
            href: t,
            anchor: this.getAnchor(t),
            origin: this.getOrigin(t),
            params: this.getParams(t),
            pathname: this.getPathname(t)
        }
    }
    ;
    var Tc = function(t) {
        function e(e) {
            var n = this;
            void 0 === e && (e = {});
            var i = e.renderers
              , r = e.transitions;
            t.call(this),
            this.Helpers = new Dc(i,r),
            this.Transitions = r,
            this.Contextual = !1,
            this.location = this.Helpers.getLocation(window.location.href),
            this.properties = this.Helpers.getProperties(document.cloneNode(!0)),
            this.popping = !1,
            this.running = !1,
            this.trigger = null,
            this.cache = new Map,
            this.cache.set(this.location.href, this.properties),
            this.properties.renderer.then((function(t) {
                n.From = new t(n.properties),
                n.From.setup()
            }
            )),
            this._navigate = this.navigate.bind(this),
            window.addEventListener("popstate", this.popState.bind(this)),
            this.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"),
            this.attach(this.links)
        }
        return t && (e.__proto__ = t),
        (e.prototype = Object.create(t && t.prototype)).constructor = e,
        e.prototype.attach = function(t) {
            for (var e = 0, n = t; e < n.length; e += 1)
                n[e].addEventListener("click", this._navigate)
        }
        ,
        e.prototype.detach = function(t) {
            for (var e = 0, n = t; e < n.length; e += 1)
                n[e].removeEventListener("click", this._navigate)
        }
        ,
        e.prototype.navigate = function(t) {
            if (!t.metaKey && !t.ctrlKey) {
                t.preventDefault();
                var e = !!t.currentTarget.hasAttribute("data-transition") && t.currentTarget.dataset.transition;
                this.redirect(t.currentTarget.href, e, t.currentTarget)
            }
        }
        ,
        e.prototype.redirect = function(t, e, n) {
            if (void 0 === e && (e = !1),
            void 0 === n && (n = "script"),
            this.trigger = n,
            !this.running && t !== this.location.href) {
                var i = this.Helpers.getLocation(t);
                this.Contextual = !1,
                e && (this.Contextual = this.Transitions.contextual[e].prototype,
                this.Contextual.name = e),
                i.origin !== this.location.origin || i.anchor && i.pathname === this.location.pathname ? window.location.href = t : (this.location = i,
                this.beforeFetch())
            }
        }
        ,
        e.prototype.popState = function() {
            this.trigger = "popstate",
            this.Contextual = !1;
            var t = this.Helpers.getLocation(window.location.href);
            this.location.pathname !== t.pathname || !this.location.anchor && !t.anchor ? (this.popping = !0,
            this.location = t,
            this.beforeFetch()) : this.location = t
        }
        ,
        e.prototype.pushState = function() {
            this.popping || window.history.pushState(this.location, "", this.location.href)
        }
        ,
        e.prototype.fetch = function() {
            try {
                var t = this;
                return Promise.resolve(fetch(t.location.href, {
                    mode: "same-origin",
                    method: "GET",
                    headers: {
                        "X-Requested-With": "Highway"
                    },
                    credentials: "same-origin"
                })).then((function(e) {
                    if (e.status >= 200 && e.status < 300)
                        return e.text();
                    window.location.href = t.location.href
                }
                ))
            } catch (t) {
                return Promise.reject(t)
            }
        }
        ,
        e.prototype.beforeFetch = function() {
            try {
                var t = this;
                function e() {
                    t.afterFetch()
                }
                t.pushState(),
                t.running = !0,
                t.emit("NAVIGATE_OUT", {
                    from: {
                        page: t.From.properties.page,
                        view: t.From.properties.view
                    },
                    trigger: t.trigger,
                    location: t.location
                });
                var n = {
                    trigger: t.trigger,
                    contextual: t.Contextual
                }
                  , i = t.cache.has(t.location.href) ? Promise.resolve(t.From.hide(n)).then((function() {
                    t.properties = t.cache.get(t.location.href)
                }
                )) : Promise.resolve(Promise.all([t.fetch(), t.From.hide(n)])).then((function(e) {
                    t.properties = t.Helpers.getProperties(e[0]),
                    t.cache.set(t.location.href, t.properties)
                }
                ));
                return Promise.resolve(i && i.then ? i.then(e) : e())
            } catch (t) {
                return Promise.reject(t)
            }
        }
        ,
        e.prototype.afterFetch = function() {
            try {
                var t = this;
                return Promise.resolve(t.properties.renderer).then((function(e) {
                    return t.To = new e(t.properties),
                    t.To.add(),
                    t.emit("NAVIGATE_IN", {
                        to: {
                            page: t.To.properties.page,
                            view: t.To.wrap.lastElementChild
                        },
                        trigger: t.trigger,
                        location: t.location
                    }),
                    Promise.resolve(t.To.show({
                        trigger: t.trigger,
                        contextual: t.Contextual
                    })).then((function() {
                        t.popping = !1,
                        t.running = !1,
                        t.detach(t.links),
                        t.links = document.querySelectorAll("a:not([target]):not([data-router-disabled])"),
                        t.attach(t.links),
                        t.emit("NAVIGATE_END", {
                            to: {
                                page: t.To.properties.page,
                                view: t.To.wrap.lastElementChild
                            },
                            from: {
                                page: t.From.properties.page,
                                view: t.From.properties.view
                            },
                            trigger: t.trigger,
                            location: t.location
                        }),
                        t.From = t.To,
                        t.trigger = null
                    }
                    ))
                }
                ))
            } catch (t) {
                return Promise.reject(t)
            }
        }
        ,
        e
    }(Mc)
      , Ac = function(t, e) {
        this.wrap = t,
        this.name = e
    };
    Ac.prototype.show = function(t) {
        var e = this
          , n = t.trigger
          , i = t.contextual
          , r = this.wrap.lastElementChild
          , o = this.wrap.firstElementChild;
        return new Promise((function(t) {
            i ? (r.setAttribute("data-transition-in", i.name),
            r.removeAttribute("data-transition-out", i.name),
            i.in && i.in({
                to: r,
                from: o,
                trigger: n,
                done: t
            })) : (r.setAttribute("data-transition-in", e.name),
            r.removeAttribute("data-transition-out", e.name),
            e.in && e.in({
                to: r,
                from: o,
                trigger: n,
                done: t
            }))
        }
        ))
    }
    ,
    Ac.prototype.hide = function(t) {
        var e = this
          , n = t.trigger
          , i = t.contextual
          , r = this.wrap.firstElementChild;
        return new Promise((function(t) {
            i ? (r.setAttribute("data-transition-out", i.name),
            r.removeAttribute("data-transition-in", i.name),
            i.out && i.out({
                from: r,
                trigger: n,
                done: t
            })) : (r.setAttribute("data-transition-out", e.name),
            r.removeAttribute("data-transition-in", e.name),
            e.out && e.out({
                from: r,
                trigger: n,
                done: t
            }))
        }
        ))
    }
    ,
    console.log("Highway v2.2.0");
    var Cc = {
        Core: Tc,
        Helpers: Dc,
        Renderer: Sc,
        Transition: Ac
    }
      , Lc = n(0)
      , Pc = new (n.n(Lc).a);
    function Rc(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    function Oc(t, e) {
        t.prototype = Object.create(e.prototype),
        t.prototype.constructor = t,
        t.__proto__ = e
    }
    var Fc, Nc, Ic, Bc, kc, zc, Uc, Hc, Gc, Vc, jc, Wc, qc, Xc, Yc, Zc, Jc, Qc, Kc, $c, tu, eu = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
            lineHeight: ""
        }
    }, nu = {
        duration: .5,
        overwrite: !1,
        delay: 0
    }, iu = 1e8, ru = 1e-8, ou = 2 * Math.PI, su = ou / 4, au = 0, lu = Math.sqrt, cu = Math.cos, uu = Math.sin, hu = function(t) {
        return "string" == typeof t
    }, du = function(t) {
        return "function" == typeof t
    }, pu = function(t) {
        return "number" == typeof t
    }, fu = function(t) {
        return void 0 === t
    }, mu = function(t) {
        return "object" == typeof t
    }, gu = function(t) {
        return !1 !== t
    }, vu = function() {
        return "undefined" != typeof window
    }, yu = function(t) {
        return du(t) || hu(t)
    }, _u = Array.isArray, xu = /(?:-?\.?\d|\.)+/gi, bu = /[-+=.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g, wu = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Mu = /[-+=.]*\d+(?:\.|e-|e)*\d*/gi, Su = /\(([^()]+)\)/i, Eu = /[+-]=-?[\.\d]+/, Du = /[#\-+.]*\b[a-z\d-=+%.]+/gi, Tu = {}, Au = {}, Cu = function(t) {
        return (Au = eh(t, Tu)) && Bd
    }, Lu = function(t, e) {
        return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
    }, Pu = function(t, e) {
        return !e && console.warn(t)
    }, Ru = function(t, e) {
        return t && (Tu[t] = e) && Au && (Au[t] = e) || Tu
    }, Ou = function() {
        return 0
    }, Fu = {}, Nu = [], Iu = {}, Bu = {}, ku = {}, zu = 30, Uu = [], Hu = "", Gu = function(t) {
        var e, n, i = t[0];
        if (mu(i) || du(i) || (t = [t]),
        !(e = (i._gsap || {}).harness)) {
            for (n = Uu.length; n-- && !Uu[n].targetTest(i); )
                ;
            e = Uu[n]
        }
        for (n = t.length; n--; )
            t[n] && (t[n]._gsap || (t[n]._gsap = new ld(t[n],e))) || t.splice(n, 1);
        return t
    }, Vu = function(t) {
        return t._gsap || Gu(Th(t))[0]._gsap
    }, ju = function(t, e) {
        var n = t[e];
        return du(n) ? t[e]() : fu(n) && t.getAttribute(e) || n
    }, Wu = function(t, e) {
        return (t = t.split(",")).forEach(e) || t
    }, qu = function(t) {
        return Math.round(1e5 * t) / 1e5 || 0
    }, Xu = function(t, e) {
        for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; )
            ;
        return i < n
    }, Yu = function(t, e, n) {
        var i, r = pu(t[1]), o = (r ? 2 : 1) + (e < 2 ? 0 : 1), s = t[o];
        if (r && (s.duration = t[1]),
        s.parent = n,
        e) {
            for (i = s; n && !("immediateRender"in i); )
                i = n.vars.defaults || {},
                n = gu(n.vars.inherit) && n.parent;
            s.immediateRender = gu(i.immediateRender),
            e < 2 ? s.runBackwards = 1 : s.startAt = t[o - 1]
        }
        return s
    }, Zu = function() {
        var t, e, n = Nu.length, i = Nu.slice(0);
        for (Iu = {},
        Nu.length = 0,
        t = 0; t < n; t++)
            (e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
    }, Ju = function(t, e, n, i) {
        Nu.length && Zu(),
        t.render(e, n, i),
        Nu.length && Zu()
    }, Qu = function(t) {
        var e = parseFloat(t);
        return (e || 0 === e) && (t + "").match(Du).length < 2 ? e : t
    }, Ku = function(t) {
        return t
    }, $u = function(t, e) {
        for (var n in e)
            n in t || (t[n] = e[n]);
        return t
    }, th = function(t, e) {
        for (var n in e)
            n in t || "duration" === n || "ease" === n || (t[n] = e[n])
    }, eh = function(t, e) {
        for (var n in e)
            t[n] = e[n];
        return t
    }, nh = function t(e, n) {
        for (var i in n)
            e[i] = mu(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i];
        return e
    }, ih = function(t, e) {
        var n, i = {};
        for (n in t)
            n in e || (i[n] = t[n]);
        return i
    }, rh = function(t) {
        var e = t.parent || Fc
          , n = t.keyframes ? th : $u;
        if (gu(t.inherit))
            for (; e; )
                n(t, e.vars.defaults),
                e = e.parent || e._dp;
        return t
    }, oh = function(t, e, n, i) {
        void 0 === n && (n = "_first"),
        void 0 === i && (i = "_last");
        var r = e._prev
          , o = e._next;
        r ? r._next = o : t[n] === e && (t[n] = o),
        o ? o._prev = r : t[i] === e && (t[i] = r),
        e._next = e._prev = e.parent = null
    }, sh = function(t, e) {
        !t.parent || e && !t.parent.autoRemoveChildren || t.parent.remove(t),
        t._act = 0
    }, ah = function(t) {
        for (var e = t; e; )
            e._dirty = 1,
            e = e.parent;
        return t
    }, lh = function(t) {
        for (var e = t.parent; e && e.parent; )
            e._dirty = 1,
            e.totalDuration(),
            e = e.parent;
        return t
    }, ch = function(t) {
        return t._repeat ? uh(t._tTime, t = t.duration() + t._rDelay) * t : 0
    }, uh = function(t, e) {
        return (t /= e) && ~~t === t ? ~~t - 1 : ~~t
    }, hh = function(t, e) {
        return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
    }, dh = function(t) {
        return t._end = qu(t._start + (t._tDur / Math.abs(t._ts || t._rts || ru) || 0))
    }, ph = function(t, e) {
        var n;
        if ((e._time || e._initted && !e._dur) && (n = hh(t.rawTime(), e),
        (!e._dur || wh(0, e.totalDuration(), n) - e._tTime > ru) && e.render(n, !0)),
        ah(t)._dp && t._initted && t._time >= t._dur && t._ts) {
            if (t._dur < t.duration())
                for (n = t; n._dp; )
                    n.rawTime() >= 0 && n.totalTime(n._tTime),
                    n = n._dp;
            t._zTime = -1e-8
        }
    }, fh = function(t, e, n, i) {
        return e.parent && sh(e),
        e._start = qu(n + e._delay),
        e._end = qu(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
        function(t, e, n, i, r) {
            void 0 === n && (n = "_first"),
            void 0 === i && (i = "_last");
            var o, s = t[i];
            if (r)
                for (o = e[r]; s && s[r] > o; )
                    s = s._prev;
            s ? (e._next = s._next,
            s._next = e) : (e._next = t[n],
            t[n] = e),
            e._next ? e._next._prev = e : t[i] = e,
            e._prev = s,
            e.parent = e._dp = t
        }(t, e, "_first", "_last", t._sort ? "_start" : 0),
        t._recent = e,
        i || ph(t, e),
        t
    }, mh = function(t, e) {
        return (Tu.ScrollTrigger || Lu("scrollTrigger", e)) && Tu.ScrollTrigger.create(e, t)
    }, gh = function(t, e, n, i) {
        return md(t, e),
        t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && zc !== Zh.frame ? (Nu.push(t),
        t._lazy = [e, i],
        1) : void 0 : 1
    }, vh = function(t, e, n) {
        var i = t._repeat
          , r = qu(e) || 0;
        return t._dur = r,
        t._tDur = i ? i < 0 ? 1e10 : qu(r * (i + 1) + t._rDelay * i) : r,
        t._time > r && (t._time = r,
        t._tTime = Math.min(t._tTime, t._tDur)),
        !n && ah(t.parent),
        t.parent && dh(t),
        t
    }, yh = function(t) {
        return t instanceof ud ? ah(t) : vh(t, t._dur)
    }, _h = {
        _start: 0,
        endTime: Ou
    }, xh = function t(e, n) {
        var i, r, o = e.labels, s = e._recent || _h, a = e.duration() >= iu ? s.endTime(!1) : e._dur;
        return hu(n) && (isNaN(n) || n in o) ? "<" === (i = n.charAt(0)) || ">" === i ? ("<" === i ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (i = n.indexOf("=")) < 0 ? (n in o || (o[n] = a),
        o[n]) : (r = +(n.charAt(i - 1) + n.substr(i + 1)),
        i > 1 ? t(e, n.substr(0, i - 1)) + r : a + r) : null == n ? a : +n
    }, bh = function(t, e) {
        return t || 0 === t ? e(t) : e
    }, wh = function(t, e, n) {
        return n < t ? t : n > e ? e : n
    }, Mh = function(t) {
        return (t + "").substr((parseFloat(t) + "").length)
    }, Sh = [].slice, Eh = function(t, e) {
        return t && mu(t) && "length"in t && (!e && !t.length || t.length - 1 in t && mu(t[0])) && !t.nodeType && t !== Nc
    }, Dh = function(t, e, n) {
        return void 0 === n && (n = []),
        t.forEach((function(t) {
            var i;
            return hu(t) && !e || Eh(t, 1) ? (i = n).push.apply(i, Th(t)) : n.push(t)
        }
        )) || n
    }, Th = function(t, e) {
        return !hu(t) || e || !Ic && Jh() ? _u(t) ? Dh(t, e) : Eh(t) ? Sh.call(t, 0) : t ? [t] : [] : Sh.call(Bc.querySelectorAll(t), 0)
    }, Ah = function(t) {
        return t.sort((function() {
            return .5 - Math.random()
        }
        ))
    }, Ch = function(t) {
        if (du(t))
            return t;
        var e = mu(t) ? t : {
            each: t
        }
          , n = id(e.ease)
          , i = e.from || 0
          , r = parseFloat(e.base) || 0
          , o = {}
          , s = i > 0 && i < 1
          , a = isNaN(i) || s
          , l = e.axis
          , c = i
          , u = i;
        return hu(i) ? c = u = {
            center: .5,
            edges: .5,
            end: 1
        }[i] || 0 : !s && a && (c = i[0],
        u = i[1]),
        function(t, s, h) {
            var d, p, f, m, g, v, y, _, x, b = (h || e).length, w = o[b];
            if (!w) {
                if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, iu])[1])) {
                    for (y = -iu; y < (y = h[x++].getBoundingClientRect().left) && x < b; )
                        ;
                    x--
                }
                for (w = o[b] = [],
                d = a ? Math.min(x, b) * c - .5 : i % x,
                p = a ? b * u / x - .5 : i / x | 0,
                y = 0,
                _ = iu,
                v = 0; v < b; v++)
                    f = v % x - d,
                    m = p - (v / x | 0),
                    w[v] = g = l ? Math.abs("y" === l ? m : f) : lu(f * f + m * m),
                    g > y && (y = g),
                    g < _ && (_ = g);
                "random" === i && Ah(w),
                w.max = y - _,
                w.min = _,
                w.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (x > b ? b - 1 : l ? "y" === l ? b / x : x : Math.max(x, b / x)) || 0) * ("edges" === i ? -1 : 1),
                w.b = b < 0 ? r - b : r,
                w.u = Mh(e.amount || e.each) || 0,
                n = n && b < 0 ? ed(n) : n
            }
            return b = (w[t] - w.min) / w.max || 0,
            qu(w.b + (n ? n(b) : b) * w.v) + w.u
        }
    }, Lh = function(t) {
        var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
        return function(n) {
            return Math.floor(Math.round(parseFloat(n) / t) * t * e) / e + (pu(n) ? 0 : Mh(n))
        }
    }, Ph = function(t, e) {
        var n, i, r = _u(t);
        return !r && mu(t) && (n = r = t.radius || iu,
        t.values ? (t = Th(t.values),
        (i = !pu(t[0])) && (n *= n)) : t = Lh(t.increment)),
        bh(e, r ? du(t) ? function(e) {
            return i = t(e),
            Math.abs(i - e) <= n ? i : e
        }
        : function(e) {
            for (var r, o, s = parseFloat(i ? e.x : e), a = parseFloat(i ? e.y : 0), l = iu, c = 0, u = t.length; u--; )
                (r = i ? (r = t[u].x - s) * r + (o = t[u].y - a) * o : Math.abs(t[u] - s)) < l && (l = r,
                c = u);
            return c = !n || l <= n ? t[c] : e,
            i || c === e || pu(e) ? c : c + Mh(e)
        }
        : Lh(t))
    }, Rh = function(t, e, n, i) {
        return bh(_u(t) ? !e : !0 === n ? !!(n = 0) : !i, (function() {
            return _u(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t + Math.random() * (e - t)) / n) * n * i) / i
        }
        ))
    }, Oh = function(t, e, n) {
        return bh(n, (function(n) {
            return t[~~e(n)]
        }
        ))
    }, Fh = function(t) {
        for (var e, n, i, r, o = 0, s = ""; ~(e = t.indexOf("random(", o)); )
            i = t.indexOf(")", e),
            r = "[" === t.charAt(e + 7),
            n = t.substr(e + 7, i - e - 7).match(r ? Du : xu),
            s += t.substr(o, e - o) + Rh(r ? n : +n[0], +n[1], +n[2] || 1e-5),
            o = i + 1;
        return s + t.substr(o, t.length - o)
    }, Nh = function(t, e, n, i, r) {
        var o = e - t
          , s = i - n;
        return bh(r, (function(e) {
            return n + ((e - t) / o * s || 0)
        }
        ))
    }, Ih = function(t, e, n) {
        var i, r, o, s = t.labels, a = iu;
        for (i in s)
            (r = s[i] - e) < 0 == !!n && r && a > (r = Math.abs(r)) && (o = i,
            a = r);
        return o
    }, Bh = function(t, e, n) {
        var i, r, o = t.vars, s = o[e];
        if (s)
            return i = o[e + "Params"],
            r = o.callbackScope || t,
            n && Nu.length && Zu(),
            i ? s.apply(r, i) : s.call(r)
    }, kh = function(t) {
        return sh(t),
        t.progress() < 1 && Bh(t, "onInterrupt"),
        t
    }, zh = function(t) {
        var e = (t = !t.name && t.default || t).name
          , n = du(t)
          , i = e && !n && t.init ? function() {
            this._props = []
        }
        : t
          , r = {
            init: Ou,
            render: Ad,
            add: pd,
            kill: Ld,
            modifier: Cd,
            rawVars: 0
        }
          , o = {
            targetTest: 0,
            get: 0,
            getSetter: Sd,
            aliases: {},
            register: 0
        };
        if (Jh(),
        t !== i) {
            if (Bu[e])
                return;
            $u(i, $u(ih(t, r), o)),
            eh(i.prototype, eh(r, ih(t, o))),
            Bu[i.prop = e] = i,
            t.targetTest && (Uu.push(i),
            Fu[e] = 1),
            e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
        }
        Ru(e, i),
        t.register && t.register(Bd, i, Od)
    }, Uh = 255, Hh = {
        aqua: [0, Uh, Uh],
        lime: [0, Uh, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, Uh],
        navy: [0, 0, 128],
        white: [Uh, Uh, Uh],
        olive: [128, 128, 0],
        yellow: [Uh, Uh, 0],
        orange: [Uh, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [Uh, 0, 0],
        pink: [Uh, 192, 203],
        cyan: [0, Uh, Uh],
        transparent: [Uh, Uh, Uh, 0]
    }, Gh = function(t, e, n) {
        return (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * Uh + .5 | 0
    }, Vh = function(t, e, n) {
        var i, r, o, s, a, l, c, u, h, d, p = t ? pu(t) ? [t >> 16, t >> 8 & Uh, t & Uh] : 0 : Hh.black;
        if (!p) {
            if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)),
            Hh[t])
                p = Hh[t];
            else if ("#" === t.charAt(0))
                4 === t.length && (i = t.charAt(1),
                r = t.charAt(2),
                o = t.charAt(3),
                t = "#" + i + i + r + r + o + o),
                p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & Uh, t & Uh];
            else if ("hsl" === t.substr(0, 3))
                if (p = d = t.match(xu),
                e) {
                    if (~t.indexOf("="))
                        return p = t.match(bu),
                        n && p.length < 4 && (p[3] = 1),
                        p
                } else
                    s = +p[0] % 360 / 360,
                    a = +p[1] / 100,
                    i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a),
                    p.length > 3 && (p[3] *= 1),
                    p[0] = Gh(s + 1 / 3, i, r),
                    p[1] = Gh(s, i, r),
                    p[2] = Gh(s - 1 / 3, i, r);
            else
                p = t.match(xu) || Hh.transparent;
            p = p.map(Number)
        }
        return e && !d && (i = p[0] / Uh,
        r = p[1] / Uh,
        o = p[2] / Uh,
        l = ((c = Math.max(i, r, o)) + (u = Math.min(i, r, o))) / 2,
        c === u ? s = a = 0 : (h = c - u,
        a = l > .5 ? h / (2 - c - u) : h / (c + u),
        s = c === i ? (r - o) / h + (r < o ? 6 : 0) : c === r ? (o - i) / h + 2 : (i - r) / h + 4,
        s *= 60),
        p[0] = ~~(s + .5),
        p[1] = ~~(100 * a + .5),
        p[2] = ~~(100 * l + .5)),
        n && p.length < 4 && (p[3] = 1),
        p
    }, jh = function(t) {
        var e = []
          , n = []
          , i = -1;
        return t.split(qh).forEach((function(t) {
            var r = t.match(wu) || [];
            e.push.apply(e, r),
            n.push(i += r.length + 1)
        }
        )),
        e.c = n,
        e
    }, Wh = function(t, e, n) {
        var i, r, o, s, a = "", l = (t + a).match(qh), c = e ? "hsla(" : "rgba(", u = 0;
        if (!l)
            return t;
        if (l = l.map((function(t) {
            return (t = Vh(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
        }
        )),
        n && (o = jh(t),
        (i = n.c).join(a) !== o.c.join(a)))
            for (s = (r = t.replace(qh, "1").split(wu)).length - 1; u < s; u++)
                a += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (o.length ? o : l.length ? l : n).shift());
        if (!r)
            for (s = (r = t.split(qh)).length - 1; u < s; u++)
                a += r[u] + l[u];
        return a + r[s]
    }, qh = function() {
        var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (t in Hh)
            e += "|" + t + "\\b";
        return new RegExp(e + ")","gi")
    }(), Xh = /hsl[a]?\(/, Yh = function(t) {
        var e, n = t.join(" ");
        if (qh.lastIndex = 0,
        qh.test(n))
            return e = Xh.test(n),
            t[1] = Wh(t[1], e),
            t[0] = Wh(t[0], e, jh(t[1])),
            !0
    }, Zh = (qc = Date.now,
    Xc = 500,
    Yc = 33,
    Zc = qc(),
    Jc = Zc,
    Kc = Qc = 1 / 240,
    tu = function t(e) {
        var n, i, r = qc() - Jc, o = !0 === e;
        r > Xc && (Zc += r - Yc),
        Jc += r,
        Wc.time = (Jc - Zc) / 1e3,
        ((n = Wc.time - Kc) > 0 || o) && (Wc.frame++,
        Kc += n + (n >= Qc ? .004 : Qc - n),
        i = 1),
        o || (Gc = Vc(t)),
        i && $c.forEach((function(t) {
            return t(Wc.time, r, Wc.frame, e)
        }
        ))
    }
    ,
    Wc = {
        time: 0,
        frame: 0,
        tick: function() {
            tu(!0)
        },
        wake: function() {
            kc && (!Ic && vu() && (Nc = Ic = window,
            Bc = Nc.document || {},
            Tu.gsap = Bd,
            (Nc.gsapVersions || (Nc.gsapVersions = [])).push(Bd.version),
            Cu(Au || Nc.GreenSockGlobals || !Nc.gsap && Nc || {}),
            jc = Nc.requestAnimationFrame),
            Gc && Wc.sleep(),
            Vc = jc || function(t) {
                return setTimeout(t, 1e3 * (Kc - Wc.time) + 1 | 0)
            }
            ,
            Hc = 1,
            tu(2))
        },
        sleep: function() {
            (jc ? Nc.cancelAnimationFrame : clearTimeout)(Gc),
            Hc = 0,
            Vc = Ou
        },
        lagSmoothing: function(t, e) {
            Xc = t || 1e8,
            Yc = Math.min(e, Xc, 0)
        },
        fps: function(t) {
            Qc = 1 / (t || 240),
            Kc = Wc.time + Qc
        },
        add: function(t) {
            $c.indexOf(t) < 0 && $c.push(t),
            Jh()
        },
        remove: function(t) {
            var e;
            ~(e = $c.indexOf(t)) && $c.splice(e, 1)
        },
        _listeners: $c = []
    }), Jh = function() {
        return !Hc && Zh.wake()
    }, Qh = {}, Kh = /^[\d.\-M][\d.\-,\s]/, $h = /["']/g, td = function(t) {
        for (var e, n, i, r = {}, o = t.substr(1, t.length - 3).split(":"), s = o[0], a = 1, l = o.length; a < l; a++)
            n = o[a],
            e = a !== l - 1 ? n.lastIndexOf(",") : n.length,
            i = n.substr(0, e),
            r[s] = isNaN(i) ? i.replace($h, "").trim() : +i,
            s = n.substr(e + 1).trim();
        return r
    }, ed = function(t) {
        return function(e) {
            return 1 - t(1 - e)
        }
    }, nd = function t(e, n) {
        for (var i, r = e._first; r; )
            r instanceof ud ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease,
            r._ease = r._yEase,
            r._yEase = i,
            r._yoyo = n)),
            r = r._next
    }, id = function(t, e) {
        return t && (du(t) ? t : Qh[t] || function(t) {
            var e = (t + "").split("(")
              , n = Qh[e[0]];
            return n && e.length > 1 && n.config ? n.config.apply(null, ~t.indexOf("{") ? [td(e[1])] : Su.exec(t)[1].split(",").map(Qu)) : Qh._CE && Kh.test(t) ? Qh._CE("", t) : n
        }(t)) || e
    }, rd = function(t, e, n, i) {
        void 0 === n && (n = function(t) {
            return 1 - e(1 - t)
        }
        ),
        void 0 === i && (i = function(t) {
            return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
        }
        );
        var r, o = {
            easeIn: e,
            easeOut: n,
            easeInOut: i
        };
        return Wu(t, (function(t) {
            for (var e in Qh[t] = Tu[t] = o,
            Qh[r = t.toLowerCase()] = n,
            o)
                Qh[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Qh[t + "." + e] = o[e]
        }
        )),
        o
    }, od = function(t) {
        return function(e) {
            return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
        }
    }, sd = function t(e, n, i) {
        var r = n >= 1 ? n : 1
          , o = (i || (e ? .3 : .45)) / (n < 1 ? n : 1)
          , s = o / ou * (Math.asin(1 / r) || 0)
          , a = function(t) {
            return 1 === t ? 1 : r * Math.pow(2, -10 * t) * uu((t - s) * o) + 1
        }
          , l = "out" === e ? a : "in" === e ? function(t) {
            return 1 - a(1 - t)
        }
        : od(a);
        return o = ou / o,
        l.config = function(n, i) {
            return t(e, n, i)
        }
        ,
        l
    }, ad = function t(e, n) {
        void 0 === n && (n = 1.70158);
        var i = function(t) {
            return t ? --t * t * ((n + 1) * t + n) + 1 : 0
        }
          , r = "out" === e ? i : "in" === e ? function(t) {
            return 1 - i(1 - t)
        }
        : od(i);
        return r.config = function(n) {
            return t(e, n)
        }
        ,
        r
    };
    Wu("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
        var n = e < 5 ? e + 1 : e;
        rd(t + ",Power" + (n - 1), e ? function(t) {
            return Math.pow(t, n)
        }
        : function(t) {
            return t
        }
        , (function(t) {
            return 1 - Math.pow(1 - t, n)
        }
        ), (function(t) {
            return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
        }
        ))
    }
    )),
    Qh.Linear.easeNone = Qh.none = Qh.Linear.easeIn,
    rd("Elastic", sd("in"), sd("out"), sd()),
    function(t, e) {
        var n = 1 / e
          , i = function(i) {
            return i < n ? t * i * i : i < .7272727272727273 ? t * Math.pow(i - 1.5 / e, 2) + .75 : i < .9090909090909092 ? t * (i -= 2.25 / e) * i + .9375 : t * Math.pow(i - 2.625 / e, 2) + .984375
        };
        rd("Bounce", (function(t) {
            return 1 - i(1 - t)
        }
        ), i)
    }(7.5625, 2.75),
    rd("Expo", (function(t) {
        return t ? Math.pow(2, 10 * (t - 1)) : 0
    }
    )),
    rd("Circ", (function(t) {
        return -(lu(1 - t * t) - 1)
    }
    )),
    rd("Sine", (function(t) {
        return 1 === t ? 1 : 1 - cu(t * su)
    }
    )),
    rd("Back", ad("in"), ad("out"), ad()),
    Qh.SteppedEase = Qh.steps = Tu.SteppedEase = {
        config: function(t, e) {
            void 0 === t && (t = 1);
            var n = 1 / t
              , i = t + (e ? 0 : 1)
              , r = e ? 1 : 0;
            return function(t) {
                return ((i * wh(0, .99999999, t) | 0) + r) * n
            }
        }
    },
    nu.ease = Qh["quad.out"],
    Wu("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
        return Hu += t + "," + t + "Params,"
    }
    ));
    var ld = function(t, e) {
        this.id = au++,
        t._gsap = this,
        this.target = t,
        this.harness = e,
        this.get = e ? e.get : ju,
        this.set = e ? e.getSetter : Sd
    }
      , cd = function() {
        function t(t, e) {
            var n = t.parent || Fc;
            this.vars = t,
            this._delay = +t.delay || 0,
            (this._repeat = t.repeat || 0) && (this._rDelay = t.repeatDelay || 0,
            this._yoyo = !!t.yoyo || !!t.yoyoEase),
            this._ts = 1,
            vh(this, +t.duration, 1),
            this.data = t.data,
            Hc || Zh.wake(),
            n && fh(n, this, e || 0 === e ? e : n._time, 1),
            t.reversed && this.reverse(),
            t.paused && this.paused(!0)
        }
        var e = t.prototype;
        return e.delay = function(t) {
            return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay),
            this._delay = t,
            this) : this._delay
        }
        ,
        e.duration = function(t) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
        }
        ,
        e.totalDuration = function(t) {
            return arguments.length ? (this._dirty = 0,
            vh(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }
        ,
        e.totalTime = function(t, e) {
            if (Jh(),
            !arguments.length)
                return this._tTime;
            var n = this.parent || this._dp;
            if (n && n.smoothChildTiming && this._ts) {
                for (this._start = qu(n._time - (this._ts > 0 ? t / this._ts : ((this._dirty ? this.totalDuration() : this._tDur) - t) / -this._ts)),
                dh(this),
                n._dirty || ah(n); n.parent; )
                    n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0),
                    n = n.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && fh(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === ru || !t && !this._initted) && (this._ts || (this._pTime = t),
            Ju(this, t, e)),
            this
        }
        ,
        e.time = function(t, e) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + ch(this)) % this._dur || (t ? this._dur : 0), e) : this._time
        }
        ,
        e.totalProgress = function(t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
        }
        ,
        e.progress = function(t, e) {
            return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + ch(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
        }
        ,
        e.iteration = function(t, e) {
            var n = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? uh(this._tTime, n) + 1 : 1
        }
        ,
        e.timeScale = function(t) {
            if (!arguments.length)
                return -1e-8 === this._rts ? 0 : this._rts;
            if (this._rts === t)
                return this;
            var e = this.parent && this._ts ? hh(this.parent._time, this) : this._tTime;
            return this._rts = +t || 0,
            this._ts = this._ps || -1e-8 === t ? 0 : this._rts,
            lh(this.totalTime(wh(0, this._tDur, e), !0))
        }
        ,
        e.paused = function(t) {
            return arguments.length ? (this._ps !== t && (this._ps = t,
            t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
            this._ts = this._act = 0) : (Jh(),
            this._ts = this._rts,
            this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= ru) && Math.abs(this._zTime) !== ru))),
            this) : this._ps
        }
        ,
        e.startTime = function(t) {
            if (arguments.length) {
                this._start = t;
                var e = this.parent || this._dp;
                return e && (e._sort || !this.parent) && fh(e, this, t - this._delay),
                this
            }
            return this._start
        }
        ,
        e.endTime = function(t) {
            return this._start + (gu(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
        }
        ,
        e.rawTime = function(t) {
            var e = this.parent || this._dp;
            return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? hh(e.rawTime(t), this) : this._tTime : this._tTime
        }
        ,
        e.repeat = function(t) {
            return arguments.length ? (this._repeat = t,
            yh(this)) : this._repeat
        }
        ,
        e.repeatDelay = function(t) {
            return arguments.length ? (this._rDelay = t,
            yh(this)) : this._rDelay
        }
        ,
        e.yoyo = function(t) {
            return arguments.length ? (this._yoyo = t,
            this) : this._yoyo
        }
        ,
        e.seek = function(t, e) {
            return this.totalTime(xh(this, t), gu(e))
        }
        ,
        e.restart = function(t, e) {
            return this.play().totalTime(t ? -this._delay : 0, gu(e))
        }
        ,
        e.play = function(t, e) {
            return null != t && this.seek(t, e),
            this.reversed(!1).paused(!1)
        }
        ,
        e.reverse = function(t, e) {
            return null != t && this.seek(t || this.totalDuration(), e),
            this.reversed(!0).paused(!1)
        }
        ,
        e.pause = function(t, e) {
            return null != t && this.seek(t, e),
            this.paused(!0)
        }
        ,
        e.resume = function() {
            return this.paused(!1)
        }
        ,
        e.reversed = function(t) {
            return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)),
            this) : this._rts < 0
        }
        ,
        e.invalidate = function() {
            return this._initted = 0,
            this._zTime = -1e-8,
            this
        }
        ,
        e.isActive = function(t) {
            var e, n = this.parent || this._dp, i = this._start;
            return !(n && !(this._ts && (this._initted || !t) && n.isActive(t) && (e = n.rawTime(!0)) >= i && e < this.endTime(!0) - ru))
        }
        ,
        e.eventCallback = function(t, e, n) {
            var i = this.vars;
            return arguments.length > 1 ? (e ? (i[t] = e,
            n && (i[t + "Params"] = n),
            "onUpdate" === t && (this._onUpdate = e)) : delete i[t],
            this) : i[t]
        }
        ,
        e.then = function(t) {
            var e = this;
            return new Promise((function(n) {
                var i = du(t) ? t : Ku
                  , r = function() {
                    var t = e.then;
                    e.then = null,
                    du(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                    n(i),
                    e.then = t
                };
                e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
            }
            ))
        }
        ,
        e.kill = function() {
            kh(this)
        }
        ,
        t
    }();
    $u(cd.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1
    });
    var ud = function(t) {
        function e(e, n) {
            var i;
            return void 0 === e && (e = {}),
            (i = t.call(this, e, n) || this).labels = {},
            i.smoothChildTiming = !!e.smoothChildTiming,
            i.autoRemoveChildren = !!e.autoRemoveChildren,
            i._sort = gu(e.sortChildren),
            i.parent && ph(i.parent, Rc(i)),
            e.scrollTrigger && mh(Rc(i), e.scrollTrigger),
            i
        }
        Oc(e, t);
        var n = e.prototype;
        return n.to = function(t, e, n) {
            return new _d(t,Yu(arguments, 0, this),xh(this, pu(e) ? arguments[3] : n)),
            this
        }
        ,
        n.from = function(t, e, n) {
            return new _d(t,Yu(arguments, 1, this),xh(this, pu(e) ? arguments[3] : n)),
            this
        }
        ,
        n.fromTo = function(t, e, n, i) {
            return new _d(t,Yu(arguments, 2, this),xh(this, pu(e) ? arguments[4] : i)),
            this
        }
        ,
        n.set = function(t, e, n) {
            return e.duration = 0,
            e.parent = this,
            rh(e).repeatDelay || (e.repeat = 0),
            e.immediateRender = !!e.immediateRender,
            new _d(t,e,xh(this, n),1),
            this
        }
        ,
        n.call = function(t, e, n) {
            return fh(this, _d.delayedCall(0, t, e), xh(this, n))
        }
        ,
        n.staggerTo = function(t, e, n, i, r, o, s) {
            return n.duration = e,
            n.stagger = n.stagger || i,
            n.onComplete = o,
            n.onCompleteParams = s,
            n.parent = this,
            new _d(t,n,xh(this, r)),
            this
        }
        ,
        n.staggerFrom = function(t, e, n, i, r, o, s) {
            return n.runBackwards = 1,
            rh(n).immediateRender = gu(n.immediateRender),
            this.staggerTo(t, e, n, i, r, o, s)
        }
        ,
        n.staggerFromTo = function(t, e, n, i, r, o, s, a) {
            return i.startAt = n,
            rh(i).immediateRender = gu(i.immediateRender),
            this.staggerTo(t, e, i, r, o, s, a)
        }
        ,
        n.render = function(t, e, n) {
            var i, r, o, s, a, l, c, u, h, d, p, f, m = this._time, g = this._dirty ? this.totalDuration() : this._tDur, v = this._dur, y = this !== Fc && t > g - ru && t >= 0 ? g : t < ru ? 0 : t, _ = this._zTime < 0 != t < 0 && (this._initted || !v);
            if (y !== this._tTime || n || _) {
                if (m !== this._time && v && (y += this._time - m,
                t += this._time - m),
                i = y,
                h = this._start,
                l = !(u = this._ts),
                _ && (v || (m = this._zTime),
                (t || !e) && (this._zTime = t)),
                this._repeat && (p = this._yoyo,
                a = v + this._rDelay,
                ((i = qu(y % a)) > v || g === y) && (i = v),
                (s = ~~(y / a)) && s === y / a && (i = v,
                s--),
                d = uh(this._tTime, a),
                !m && this._tTime && d !== s && (d = s),
                p && 1 & s && (i = v - i,
                f = 1),
                s !== d && !this._lock)) {
                    var x = p && 1 & d
                      , b = x === (p && 1 & s);
                    if (s < d && (x = !x),
                    m = x ? 0 : v,
                    this._lock = 1,
                    this.render(m || (f ? 0 : qu(s * a)), e, !v)._lock = 0,
                    !e && this.parent && Bh(this, "onRepeat"),
                    this.vars.repeatRefresh && !f && (this.invalidate()._lock = 1),
                    m !== this._time || l !== !this._ts)
                        return this;
                    if (b && (this._lock = 2,
                    m = x ? v + 1e-4 : -1e-4,
                    this.render(m, !0),
                    this.vars.repeatRefresh && !f && this.invalidate()),
                    this._lock = 0,
                    !this._ts && !l)
                        return this;
                    nd(this, f)
                }
                if (this._hasPause && !this._forcing && this._lock < 2 && (c = function(t, e, n) {
                    var i;
                    if (n > e)
                        for (i = t._first; i && i._start <= n; ) {
                            if (!i._dur && "isPause" === i.data && i._start > e)
                                return i;
                            i = i._next
                        }
                    else
                        for (i = t._last; i && i._start >= n; ) {
                            if (!i._dur && "isPause" === i.data && i._start < e)
                                return i;
                            i = i._prev
                        }
                }(this, qu(m), qu(i))) && (y -= i - (i = c._start)),
                this._tTime = y,
                this._time = i,
                this._act = !u,
                this._initted || (this._onUpdate = this.vars.onUpdate,
                this._initted = 1,
                this._zTime = t),
                m || !i || e || Bh(this, "onStart"),
                i >= m && t >= 0)
                    for (r = this._first; r; ) {
                        if (o = r._next,
                        (r._act || i >= r._start) && r._ts && c !== r) {
                            if (r.parent !== this)
                                return this.render(t, e, n);
                            if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, e, n),
                            i !== this._time || !this._ts && !l) {
                                c = 0,
                                o && (y += this._zTime = -1e-8);
                                break
                            }
                        }
                        r = o
                    }
                else {
                    r = this._last;
                    for (var w = t < 0 ? t : i; r; ) {
                        if (o = r._prev,
                        (r._act || w <= r._end) && r._ts && c !== r) {
                            if (r.parent !== this)
                                return this.render(t, e, n);
                            if (r.render(r._ts > 0 ? (w - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (w - r._start) * r._ts, e, n),
                            i !== this._time || !this._ts && !l) {
                                c = 0,
                                o && (y += this._zTime = w ? -1e-8 : ru);
                                break
                            }
                        }
                        r = o
                    }
                }
                if (c && !e && (this.pause(),
                c.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1,
                this._ts))
                    return this._start = h,
                    dh(this),
                    this.render(t, e, n);
                this._onUpdate && !e && Bh(this, "onUpdate", !0),
                (y === g && g >= this.totalDuration() || !y && m) && (h !== this._start && Math.abs(u) === Math.abs(this._ts) || this._lock || ((t || !v) && (y === g && this._ts > 0 || !y && this._ts < 0) && sh(this, 1),
                e || t < 0 && !m || !y && !m || (Bh(this, y === g ? "onComplete" : "onReverseComplete", !0),
                this._prom && !(y < g && this.timeScale() > 0) && this._prom())))
            }
            return this
        }
        ,
        n.add = function(t, e) {
            var n = this;
            if (pu(e) || (e = xh(this, e)),
            !(t instanceof cd)) {
                if (_u(t))
                    return t.forEach((function(t) {
                        return n.add(t, e)
                    }
                    )),
                    ah(this);
                if (hu(t))
                    return this.addLabel(t, e);
                if (!du(t))
                    return this;
                t = _d.delayedCall(0, t)
            }
            return this !== t ? fh(this, t, e) : this
        }
        ,
        n.getChildren = function(t, e, n, i) {
            void 0 === t && (t = !0),
            void 0 === e && (e = !0),
            void 0 === n && (n = !0),
            void 0 === i && (i = -iu);
            for (var r = [], o = this._first; o; )
                o._start >= i && (o instanceof _d ? e && r.push(o) : (n && r.push(o),
                t && r.push.apply(r, o.getChildren(!0, e, n)))),
                o = o._next;
            return r
        }
        ,
        n.getById = function(t) {
            for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
                if (e[n].vars.id === t)
                    return e[n]
        }
        ,
        n.remove = function(t) {
            return hu(t) ? this.removeLabel(t) : du(t) ? this.killTweensOf(t) : (oh(this, t),
            t === this._recent && (this._recent = this._last),
            ah(this))
        }
        ,
        n.totalTime = function(e, n) {
            return arguments.length ? (this._forcing = 1,
            this.parent || this._dp || !this._ts || (this._start = qu(Zh.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))),
            t.prototype.totalTime.call(this, e, n),
            this._forcing = 0,
            this) : this._tTime
        }
        ,
        n.addLabel = function(t, e) {
            return this.labels[t] = xh(this, e),
            this
        }
        ,
        n.removeLabel = function(t) {
            return delete this.labels[t],
            this
        }
        ,
        n.addPause = function(t, e, n) {
            var i = _d.delayedCall(0, e || Ou, n);
            return i.data = "isPause",
            this._hasPause = 1,
            fh(this, i, xh(this, t))
        }
        ,
        n.removePause = function(t) {
            var e = this._first;
            for (t = xh(this, t); e; )
                e._start === t && "isPause" === e.data && sh(e),
                e = e._next
        }
        ,
        n.killTweensOf = function(t, e, n) {
            for (var i = this.getTweensOf(t, n), r = i.length; r--; )
                hd !== i[r] && i[r].kill(t, e);
            return this
        }
        ,
        n.getTweensOf = function(t, e) {
            for (var n, i = [], r = Th(t), o = this._first; o; )
                o instanceof _d ? !Xu(o._targets, r) || e && !o.isActive("started" === e) || i.push(o) : (n = o.getTweensOf(r, e)).length && i.push.apply(i, n),
                o = o._next;
            return i
        }
        ,
        n.tweenTo = function(t, e) {
            e = e || {};
            var n = this
              , i = xh(n, t)
              , r = e
              , o = r.startAt
              , s = r.onStart
              , a = r.onStartParams
              , l = _d.to(n, $u(e, {
                ease: "none",
                lazy: !1,
                time: i,
                duration: e.duration || Math.abs((i - (o && "time"in o ? o.time : n._time)) / n.timeScale()) || ru,
                onStart: function() {
                    n.pause();
                    var t = e.duration || Math.abs((i - n._time) / n.timeScale());
                    l._dur !== t && vh(l, t).render(l._time, !0, !0),
                    s && s.apply(l, a || [])
                }
            }));
            return l
        }
        ,
        n.tweenFromTo = function(t, e, n) {
            return this.tweenTo(e, $u({
                startAt: {
                    time: xh(this, t)
                }
            }, n))
        }
        ,
        n.recent = function() {
            return this._recent
        }
        ,
        n.nextLabel = function(t) {
            return void 0 === t && (t = this._time),
            Ih(this, xh(this, t))
        }
        ,
        n.previousLabel = function(t) {
            return void 0 === t && (t = this._time),
            Ih(this, xh(this, t), 1)
        }
        ,
        n.currentLabel = function(t) {
            return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + ru)
        }
        ,
        n.shiftChildren = function(t, e, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, o = this.labels; r; )
                r._start >= n && (r._start += t),
                r = r._next;
            if (e)
                for (i in o)
                    o[i] >= n && (o[i] += t);
            return ah(this)
        }
        ,
        n.invalidate = function() {
            var e = this._first;
            for (this._lock = 0; e; )
                e.invalidate(),
                e = e._next;
            return t.prototype.invalidate.call(this)
        }
        ,
        n.clear = function(t) {
            void 0 === t && (t = !0);
            for (var e, n = this._first; n; )
                e = n._next,
                this.remove(n),
                n = e;
            return this._time = this._tTime = this._pTime = 0,
            t && (this.labels = {}),
            ah(this)
        }
        ,
        n.totalDuration = function(t) {
            var e, n, i, r, o = 0, s = this, a = s._last, l = iu;
            if (arguments.length)
                return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -t : t));
            if (s._dirty) {
                for (r = s.parent; a; )
                    e = a._prev,
                    a._dirty && a.totalDuration(),
                    (i = a._start) > l && s._sort && a._ts && !s._lock ? (s._lock = 1,
                    fh(s, a, i - a._delay, 1)._lock = 0) : l = i,
                    i < 0 && a._ts && (o -= i,
                    (!r && !s._dp || r && r.smoothChildTiming) && (s._start += i / s._ts,
                    s._time -= i,
                    s._tTime -= i),
                    s.shiftChildren(-i, !1, -Infinity),
                    l = 0),
                    (n = dh(a)) > o && a._ts && (o = n),
                    a = e;
                vh(s, s === Fc && s._time > o ? s._time : o, 1),
                s._dirty = 0
            }
            return s._tDur
        }
        ,
        e.updateRoot = function(t) {
            if (Fc._ts && (Ju(Fc, hh(t, Fc)),
            zc = Zh.frame),
            Zh.frame >= zu) {
                zu += eu.autoSleep || 120;
                var e = Fc._first;
                if ((!e || !e._ts) && eu.autoSleep && Zh._listeners.length < 2) {
                    for (; e && !e._ts; )
                        e = e._next;
                    e || Zh.sleep()
                }
            }
        }
        ,
        e
    }(cd);
    $u(ud.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
    });
    var hd, dd = function(t, e, n, i, r, o, s) {
        var a, l, c, u, h, d, p, f, m = new Od(this._pt,t,e,0,1,Td,null,r), g = 0, v = 0;
        for (m.b = n,
        m.e = i,
        n += "",
        (p = ~(i += "").indexOf("random(")) && (i = Fh(i)),
        o && (o(f = [n, i], t, e),
        n = f[0],
        i = f[1]),
        l = n.match(Mu) || []; a = Mu.exec(i); )
            u = a[0],
            h = i.substring(g, a.index),
            c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1),
            u !== l[v++] && (d = parseFloat(l[v - 1]) || 0,
            m._pt = {
                _next: m._pt,
                p: h || 1 === v ? h : ",",
                s: d,
                c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - d,
                m: c && c < 4 ? Math.round : 0
            },
            g = Mu.lastIndex);
        return m.c = g < i.length ? i.substring(g, i.length) : "",
        m.fp = s,
        (Eu.test(i) || p) && (m.e = 0),
        this._pt = m,
        m
    }, pd = function(t, e, n, i, r, o, s, a, l) {
        du(i) && (i = i(r || 0, t, o));
        var c, u = t[e], h = "get" !== n ? n : du(u) ? l ? t[e.indexOf("set") || !du(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u, d = du(u) ? l ? wd : bd : xd;
        if (hu(i) && (~i.indexOf("random(") && (i = Fh(i)),
        "=" === i.charAt(1) && (i = parseFloat(h) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (Mh(h) || 0))),
        h !== i)
            return isNaN(h + i) ? (!u && !(e in t) && Lu(e, i),
            dd.call(this, t, e, h, i, d, a || eu.stringFilter, l)) : (c = new Od(this._pt,t,e,+h || 0,i - (h || 0),"boolean" == typeof u ? Dd : Ed,0,d),
            l && (c.fp = l),
            s && c.modifier(s, this, t),
            this._pt = c)
    }, fd = function(t, e, n, i, r, o) {
        var s, a, l, c;
        if (Bu[t] && !1 !== (s = new Bu[t]).init(r, s.rawVars ? e[t] : function(t, e, n, i, r) {
            if (du(t) && (t = gd(t, r, e, n, i)),
            !mu(t) || t.style && t.nodeType || _u(t))
                return hu(t) ? gd(t, r, e, n, i) : t;
            var o, s = {};
            for (o in t)
                s[o] = gd(t[o], r, e, n, i);
            return s
        }(e[t], i, r, o, n), n, i, o) && (n._pt = a = new Od(n._pt,r,t,0,1,s.render,s,0,s.priority),
        n !== Uc))
            for (l = n._ptLookup[n._targets.indexOf(r)],
            c = s._props.length; c--; )
                l[s._props[c]] = a;
        return s
    }, md = function t(e, n) {
        var i, r, o, s, a, l, c, u, h, d, p, f, m = e.vars, g = m.ease, v = m.startAt, y = m.immediateRender, _ = m.lazy, x = m.onUpdate, b = m.onUpdateParams, w = m.callbackScope, M = m.runBackwards, S = m.yoyoEase, E = m.keyframes, D = m.autoRevert, T = e._dur, A = e._startAt, C = e._targets, L = e.parent, P = L && "nested" === L.data ? L.parent._targets : C, R = "auto" === e._overwrite, O = e.timeline;
        if (O && (!E || !g) && (g = "none"),
        e._ease = id(g, nu.ease),
        e._yEase = S ? ed(id(!0 === S ? g : S, nu.ease)) : 0,
        S && e._yoyo && !e._repeat && (S = e._yEase,
        e._yEase = e._ease,
        e._ease = S),
        !O) {
            if (f = (u = C[0] ? Vu(C[0]).harness : 0) && m[u.prop],
            i = ih(m, Fu),
            A && A.render(-1, !0).kill(),
            v) {
                if (sh(e._startAt = _d.set(C, $u({
                    data: "isStart",
                    overwrite: !1,
                    parent: L,
                    immediateRender: !0,
                    lazy: gu(_),
                    startAt: null,
                    delay: 0,
                    onUpdate: x,
                    onUpdateParams: b,
                    callbackScope: w,
                    stagger: 0
                }, v))),
                y)
                    if (n > 0)
                        !D && (e._startAt = 0);
                    else if (T)
                        return
            } else if (M && T)
                if (A)
                    !D && (e._startAt = 0);
                else if (n && (y = !1),
                o = $u({
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: y && gu(_),
                    immediateRender: y,
                    stagger: 0,
                    parent: L
                }, i),
                f && (o[u.prop] = f),
                sh(e._startAt = _d.set(C, o)),
                y) {
                    if (!n)
                        return
                } else
                    t(e._startAt, ru);
            for (e._pt = 0,
            _ = T && gu(_) || _ && !T,
            r = 0; r < C.length; r++) {
                if (c = (a = C[r])._gsap || Gu(C)[r]._gsap,
                e._ptLookup[r] = d = {},
                Iu[c.id] && Zu(),
                p = P === C ? r : P.indexOf(a),
                u && !1 !== (h = new u).init(a, f || i, e, p, P) && (e._pt = s = new Od(e._pt,a,h.name,0,1,h.render,h,0,h.priority),
                h._props.forEach((function(t) {
                    d[t] = s
                }
                )),
                h.priority && (l = 1)),
                !u || f)
                    for (o in i)
                        Bu[o] && (h = fd(o, i, e, p, a, P)) ? h.priority && (l = 1) : d[o] = s = pd.call(e, a, o, "get", i[o], p, P, 0, m.stringFilter);
                e._op && e._op[r] && e.kill(a, e._op[r]),
                R && e._pt && (hd = e,
                Fc.killTweensOf(a, d, "started"),
                hd = 0),
                e._pt && _ && (Iu[c.id] = 1)
            }
            l && Rd(e),
            e._onInit && e._onInit(e)
        }
        e._from = !O && !!m.runBackwards,
        e._onUpdate = x,
        e._initted = !!e.parent
    }, gd = function(t, e, n, i, r) {
        return du(t) ? t.call(e, n, i, r) : hu(t) && ~t.indexOf("random(") ? Fh(t) : t
    }, vd = Hu + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase", yd = (vd + ",id,stagger,delay,duration,paused,scrollTrigger").split(","), _d = function(t) {
        function e(e, n, i, r) {
            var o;
            "number" == typeof n && (i.duration = n,
            n = i,
            i = null);
            var s, a, l, c, u, h, d, p, f = (o = t.call(this, r ? n : rh(n), i) || this).vars, m = f.duration, g = f.delay, v = f.immediateRender, y = f.stagger, _ = f.overwrite, x = f.keyframes, b = f.defaults, w = f.scrollTrigger, M = f.yoyoEase, S = o.parent, E = (_u(e) ? pu(e[0]) : "length"in n) ? [e] : Th(e);
            if (o._targets = E.length ? Gu(E) : Pu("GSAP target " + e + " not found. https://greensock.com", !eu.nullTargetWarn) || [],
            o._ptLookup = [],
            o._overwrite = _,
            x || y || yu(m) || yu(g)) {
                if (n = o.vars,
                (s = o.timeline = new ud({
                    data: "nested",
                    defaults: b || {}
                })).kill(),
                s.parent = Rc(o),
                x)
                    $u(s.vars.defaults, {
                        ease: "none"
                    }),
                    x.forEach((function(t) {
                        return s.to(E, t, ">")
                    }
                    ));
                else {
                    if (c = E.length,
                    d = y ? Ch(y) : Ou,
                    mu(y))
                        for (u in y)
                            ~vd.indexOf(u) && (p || (p = {}),
                            p[u] = y[u]);
                    for (a = 0; a < c; a++) {
                        for (u in l = {},
                        n)
                            yd.indexOf(u) < 0 && (l[u] = n[u]);
                        l.stagger = 0,
                        M && (l.yoyoEase = M),
                        p && eh(l, p),
                        h = E[a],
                        l.duration = +gd(m, Rc(o), a, h, E),
                        l.delay = (+gd(g, Rc(o), a, h, E) || 0) - o._delay,
                        !y && 1 === c && l.delay && (o._delay = g = l.delay,
                        o._start += g,
                        l.delay = 0),
                        s.to(h, l, d(a, h, E))
                    }
                    s.duration() ? m = g = 0 : o.timeline = 0
                }
                m || o.duration(m = s.duration())
            } else
                o.timeline = 0;
            return !0 === _ && (hd = Rc(o),
            Fc.killTweensOf(E),
            hd = 0),
            S && ph(S, Rc(o)),
            (v || !m && !x && o._start === qu(S._time) && gu(v) && function t(e) {
                return !e || e._ts && t(e.parent)
            }(Rc(o)) && "nested" !== S.data) && (o._tTime = -1e-8,
            o.render(Math.max(0, -g))),
            w && mh(Rc(o), w),
            o
        }
        Oc(e, t);
        var n = e.prototype;
        return n.render = function(t, e, n) {
            var i, r, o, s, a, l, c, u, h, d = this._time, p = this._tDur, f = this._dur, m = t > p - ru && t >= 0 ? p : t < ru ? 0 : t;
            if (f) {
                if (m !== this._tTime || !t || n || this._startAt && this._zTime < 0 != t < 0) {
                    if (i = m,
                    u = this.timeline,
                    this._repeat) {
                        if (s = f + this._rDelay,
                        ((i = qu(m % s)) > f || p === m) && (i = f),
                        (o = ~~(m / s)) && o === m / s && (i = f,
                        o--),
                        (l = this._yoyo && 1 & o) && (h = this._yEase,
                        i = f - i),
                        a = uh(this._tTime, s),
                        i === d && !n && this._initted)
                            return this;
                        o !== a && (u && this._yEase && nd(u, l),
                        !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1,
                        this.render(qu(s * o), !0).invalidate()._lock = 0))
                    }
                    if (!this._initted) {
                        if (gh(this, i, n, e))
                            return this._tTime = 0,
                            this;
                        if (f !== this._dur)
                            return this.render(t, e, n)
                    }
                    for (this._tTime = m,
                    this._time = i,
                    !this._act && this._ts && (this._act = 1,
                    this._lazy = 0),
                    this.ratio = c = (h || this._ease)(i / f),
                    this._from && (this.ratio = c = 1 - c),
                    i && !d && !e && Bh(this, "onStart"),
                    r = this._pt; r; )
                        r.r(c, r.d),
                        r = r._next;
                    u && u.render(t < 0 ? t : !i && l ? -1e-8 : u._dur * c, e, n) || this._startAt && (this._zTime = t),
                    this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n),
                    Bh(this, "onUpdate")),
                    this._repeat && o !== a && this.vars.onRepeat && !e && this.parent && Bh(this, "onRepeat"),
                    m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0),
                    (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && sh(this, 1),
                    e || t < 0 && !d || !m && !d || (Bh(this, m === p ? "onComplete" : "onReverseComplete", !0),
                    this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
                }
            } else
                !function(t, e, n, i) {
                    var r, o, s = t.ratio, a = e < 0 || !e && s && !t._start && t._zTime > ru && !t._dp._lock || t._ts < 0 || t._dp._ts < 0 ? 0 : 1, l = t._rDelay, c = 0;
                    if (l && t._repeat && (c = wh(0, t._tDur, e),
                    uh(c, l) !== (o = uh(t._tTime, l)) && (s = 1 - a,
                    t.vars.repeatRefresh && t._initted && t.invalidate())),
                    t._initted || !gh(t, e, i, n))
                        if (a !== s || i || t._zTime === ru || !e && t._zTime) {
                            for (o = t._zTime,
                            t._zTime = e || (n ? ru : 0),
                            n || (n = e && !o),
                            t.ratio = a,
                            t._from && (a = 1 - a),
                            t._time = 0,
                            t._tTime = c,
                            n || Bh(t, "onStart"),
                            r = t._pt; r; )
                                r.r(a, r.d),
                                r = r._next;
                            t._startAt && e < 0 && t._startAt.render(e, !0, !0),
                            t._onUpdate && !n && Bh(t, "onUpdate"),
                            c && t._repeat && !n && t.parent && Bh(t, "onRepeat"),
                            (e >= t._tDur || e < 0) && t.ratio === a && (a && sh(t, 1),
                            n || (Bh(t, a ? "onComplete" : "onReverseComplete", !0),
                            t._prom && t._prom()))
                        } else
                            t._zTime || (t._zTime = e)
                }(this, t, e, n);
            return this
        }
        ,
        n.targets = function() {
            return this._targets
        }
        ,
        n.invalidate = function() {
            return this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0,
            this._ptLookup = [],
            this.timeline && this.timeline.invalidate(),
            t.prototype.invalidate.call(this)
        }
        ,
        n.kill = function(t, e) {
            if (void 0 === e && (e = "all"),
            !(t || e && "all" !== e) && (this._lazy = 0,
            this.parent))
                return kh(this);
            if (this.timeline) {
                var n = this.timeline.totalDuration();
                return this.timeline.killTweensOf(t, e, hd && !0 !== hd.vars.overwrite)._first || kh(this),
                this.parent && n !== this.timeline.totalDuration() && vh(this, this._dur * this.timeline._tDur / n),
                this
            }
            var i, r, o, s, a, l, c, u = this._targets, h = t ? Th(t) : u, d = this._ptLookup, p = this._pt;
            if ((!e || "all" === e) && function(t, e) {
                for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n]; )
                    ;
                return n < 0
            }(u, h))
                return kh(this);
            for (i = this._op = this._op || [],
            "all" !== e && (hu(e) && (a = {},
            Wu(e, (function(t) {
                return a[t] = 1
            }
            )),
            e = a),
            e = function(t, e) {
                var n, i, r, o, s = t[0] ? Vu(t[0]).harness : 0, a = s && s.aliases;
                if (!a)
                    return e;
                for (i in n = eh({}, e),
                a)
                    if (i in n)
                        for (r = (o = a[i].split(",")).length; r--; )
                            n[o[r]] = n[i];
                return n
            }(u, e)),
            c = u.length; c--; )
                if (~h.indexOf(u[c]))
                    for (a in r = d[c],
                    "all" === e ? (i[c] = e,
                    s = r,
                    o = {}) : (o = i[c] = i[c] || {},
                    s = e),
                    s)
                        (l = r && r[a]) && ("kill"in l.d && !0 !== l.d.kill(a) || oh(this, l, "_pt"),
                        delete r[a]),
                        "all" !== o && (o[a] = 1);
            return this._initted && !this._pt && p && kh(this),
            this
        }
        ,
        e.to = function(t, n) {
            return new e(t,n,arguments[2])
        }
        ,
        e.from = function(t, n) {
            return new e(t,Yu(arguments, 1))
        }
        ,
        e.delayedCall = function(t, n, i, r) {
            return new e(n,0,{
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: t,
                onComplete: n,
                onReverseComplete: n,
                onCompleteParams: i,
                onReverseCompleteParams: i,
                callbackScope: r
            })
        }
        ,
        e.fromTo = function(t, n, i) {
            return new e(t,Yu(arguments, 2))
        }
        ,
        e.set = function(t, n) {
            return n.duration = 0,
            n.repeatDelay || (n.repeat = 0),
            new e(t,n)
        }
        ,
        e.killTweensOf = function(t, e, n) {
            return Fc.killTweensOf(t, e, n)
        }
        ,
        e
    }(cd);
    $u(_d.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
    }),
    Wu("staggerTo,staggerFrom,staggerFromTo", (function(t) {
        _d[t] = function() {
            var e = new ud
              , n = Sh.call(arguments, 0);
            return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0),
            e[t].apply(e, n)
        }
    }
    ));
    var xd = function(t, e, n) {
        return t[e] = n
    }
      , bd = function(t, e, n) {
        return t[e](n)
    }
      , wd = function(t, e, n, i) {
        return t[e](i.fp, n)
    }
      , Md = function(t, e, n) {
        return t.setAttribute(e, n)
    }
      , Sd = function(t, e) {
        return du(t[e]) ? bd : fu(t[e]) && t.setAttribute ? Md : xd
    }
      , Ed = function(t, e) {
        return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
    }
      , Dd = function(t, e) {
        return e.set(e.t, e.p, !!(e.s + e.c * t), e)
    }
      , Td = function(t, e) {
        var n = e._pt
          , i = "";
        if (!t && e.b)
            i = e.b;
        else if (1 === t && e.e)
            i = e.e;
        else {
            for (; n; )
                i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i,
                n = n._next;
            i += e.c
        }
        e.set(e.t, e.p, i, e)
    }
      , Ad = function(t, e) {
        for (var n = e._pt; n; )
            n.r(t, n.d),
            n = n._next
    }
      , Cd = function(t, e, n, i) {
        for (var r, o = this._pt; o; )
            r = o._next,
            o.p === i && o.modifier(t, e, n),
            o = r
    }
      , Ld = function(t) {
        for (var e, n, i = this._pt; i; )
            n = i._next,
            i.p === t && !i.op || i.op === t ? oh(this, i, "_pt") : i.dep || (e = 1),
            i = n;
        return !e
    }
      , Pd = function(t, e, n, i) {
        i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
    }
      , Rd = function(t) {
        for (var e, n, i, r, o = t._pt; o; ) {
            for (e = o._next,
            n = i; n && n.pr > o.pr; )
                n = n._next;
            (o._prev = n ? n._prev : r) ? o._prev._next = o : i = o,
            (o._next = n) ? n._prev = o : r = o,
            o = e
        }
        t._pt = i
    }
      , Od = function() {
        function t(t, e, n, i, r, o, s, a, l) {
            this.t = e,
            this.s = i,
            this.c = r,
            this.p = n,
            this.r = o || Ed,
            this.d = s || this,
            this.set = a || xd,
            this.pr = l || 0,
            this._next = t,
            t && (t._prev = this)
        }
        return t.prototype.modifier = function(t, e, n) {
            this.mSet = this.mSet || this.set,
            this.set = Pd,
            this.m = t,
            this.mt = n,
            this.tween = e
        }
        ,
        t
    }();
    Wu(Hu + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
        return Fu[t] = 1
    }
    )),
    Tu.TweenMax = Tu.TweenLite = _d,
    Tu.TimelineLite = Tu.TimelineMax = ud,
    Fc = new ud({
        sortChildren: !1,
        defaults: nu,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0
    }),
    eu.stringFilter = Yh;
    var Fd = {
        registerPlugin: function() {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                e[n] = arguments[n];
            e.forEach((function(t) {
                return zh(t)
            }
            ))
        },
        timeline: function(t) {
            return new ud(t)
        },
        getTweensOf: function(t, e) {
            return Fc.getTweensOf(t, e)
        },
        getProperty: function(t, e, n, i) {
            hu(t) && (t = Th(t)[0]);
            var r = Vu(t || {}).get
              , o = n ? Ku : Qu;
            return "native" === n && (n = ""),
            t ? e ? o((Bu[e] && Bu[e].get || r)(t, e, n, i)) : function(e, n, i) {
                return o((Bu[e] && Bu[e].get || r)(t, e, n, i))
            }
            : t
        },
        quickSetter: function(t, e, n) {
            if ((t = Th(t)).length > 1) {
                var i = t.map((function(t) {
                    return Bd.quickSetter(t, e, n)
                }
                ))
                  , r = i.length;
                return function(t) {
                    for (var e = r; e--; )
                        i[e](t)
                }
            }
            t = t[0] || {};
            var o = Bu[e]
              , s = Vu(t)
              , a = s.harness && (s.harness.aliases || {})[e] || e
              , l = o ? function(e) {
                var i = new o;
                Uc._pt = 0,
                i.init(t, n ? e + n : e, Uc, 0, [t]),
                i.render(1, i),
                Uc._pt && Ad(1, Uc)
            }
            : s.set(t, a);
            return o ? l : function(e) {
                return l(t, a, n ? e + n : e, s, 1)
            }
        },
        isTweening: function(t) {
            return Fc.getTweensOf(t, !0).length > 0
        },
        defaults: function(t) {
            return t && t.ease && (t.ease = id(t.ease, nu.ease)),
            nh(nu, t || {})
        },
        config: function(t) {
            return nh(eu, t || {})
        },
        registerEffect: function(t) {
            var e = t.name
              , n = t.effect
              , i = t.plugins
              , r = t.defaults
              , o = t.extendTimeline;
            (i || "").split(",").forEach((function(t) {
                return t && !Bu[t] && !Tu[t] && Pu(e + " effect requires " + t + " plugin.")
            }
            )),
            ku[e] = function(t, e, i) {
                return n(Th(t), $u(e || {}, r), i)
            }
            ,
            o && (ud.prototype[e] = function(t, n, i) {
                return this.add(ku[e](t, mu(n) ? n : (i = n) && {}, this), i)
            }
            )
        },
        registerEase: function(t, e) {
            Qh[t] = id(e)
        },
        parseEase: function(t, e) {
            return arguments.length ? id(t, e) : Qh
        },
        getById: function(t) {
            return Fc.getById(t)
        },
        exportRoot: function(t, e) {
            void 0 === t && (t = {});
            var n, i, r = new ud(t);
            for (r.smoothChildTiming = gu(t.smoothChildTiming),
            Fc.remove(r),
            r._dp = 0,
            r._time = r._tTime = Fc._time,
            n = Fc._first; n; )
                i = n._next,
                !e && !n._dur && n instanceof _d && n.vars.onComplete === n._targets[0] || fh(r, n, n._start - n._delay),
                n = i;
            return fh(Fc, r, 0),
            r
        },
        utils: {
            wrap: function t(e, n, i) {
                var r = n - e;
                return _u(e) ? Oh(e, t(0, e.length), n) : bh(i, (function(t) {
                    return (r + (t - e) % r) % r + e
                }
                ))
            },
            wrapYoyo: function t(e, n, i) {
                var r = n - e
                  , o = 2 * r;
                return _u(e) ? Oh(e, t(0, e.length - 1), n) : bh(i, (function(t) {
                    return e + ((t = (o + (t - e) % o) % o || 0) > r ? o - t : t)
                }
                ))
            },
            distribute: Ch,
            random: Rh,
            snap: Ph,
            normalize: function(t, e, n) {
                return Nh(t, e, 0, 1, n)
            },
            getUnit: Mh,
            clamp: function(t, e, n) {
                return bh(n, (function(n) {
                    return wh(t, e, n)
                }
                ))
            },
            splitColor: Vh,
            toArray: Th,
            mapRange: Nh,
            pipe: function() {
                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
                    e[n] = arguments[n];
                return function(t) {
                    return e.reduce((function(t, e) {
                        return e(t)
                    }
                    ), t)
                }
            },
            unitize: function(t, e) {
                return function(n) {
                    return t(parseFloat(n)) + (e || Mh(n))
                }
            },
            interpolate: function t(e, n, i, r) {
                var o = isNaN(e + n) ? 0 : function(t) {
                    return (1 - t) * e + t * n
                }
                ;
                if (!o) {
                    var s, a, l, c, u, h = hu(e), d = {};
                    if (!0 === i && (r = 1) && (i = null),
                    h)
                        e = {
                            p: e
                        },
                        n = {
                            p: n
                        };
                    else if (_u(e) && !_u(n)) {
                        for (l = [],
                        c = e.length,
                        u = c - 2,
                        a = 1; a < c; a++)
                            l.push(t(e[a - 1], e[a]));
                        c--,
                        o = function(t) {
                            t *= c;
                            var e = Math.min(u, ~~t);
                            return l[e](t - e)
                        }
                        ,
                        i = n
                    } else
                        r || (e = eh(_u(e) ? [] : {}, e));
                    if (!l) {
                        for (s in n)
                            pd.call(d, e, s, "get", n[s]);
                        o = function(t) {
                            return Ad(t, d) || (h ? e.p : e)
                        }
                    }
                }
                return bh(i, o)
            },
            shuffle: Ah
        },
        install: Cu,
        effects: ku,
        ticker: Zh,
        updateRoot: ud.updateRoot,
        plugins: Bu,
        globalTimeline: Fc,
        core: {
            PropTween: Od,
            globals: Ru,
            Tween: _d,
            Timeline: ud,
            Animation: cd,
            getCache: Vu,
            _removeLinkedListItem: oh
        }
    };
    Wu("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
        return Fd[t] = _d[t]
    }
    )),
    Zh.add(ud.updateRoot),
    Uc = Fd.to({}, {
        duration: 0
    });
    var Nd = function(t, e) {
        for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
            n = n._next;
        return n
    }
      , Id = function(t, e) {
        return {
            name: t,
            rawVars: 1,
            init: function(t, n, i) {
                i._onInit = function(t) {
                    var i, r;
                    if (hu(n) && (i = {},
                    Wu(n, (function(t) {
                        return i[t] = 1
                    }
                    )),
                    n = i),
                    e) {
                        for (r in i = {},
                        n)
                            i[r] = e(n[r]);
                        n = i
                    }
                    !function(t, e) {
                        var n, i, r, o = t._targets;
                        for (n in e)
                            for (i = o.length; i--; )
                                (r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = Nd(r, n)),
                                r && r.modifier && r.modifier(e[n], t, o[i], n))
                    }(t, n)
                }
            }
        }
    }
      , Bd = Fd.registerPlugin({
        name: "attr",
        init: function(t, e, n, i, r) {
            var o, s;
            for (o in e)
                (s = this.add(t, "setAttribute", (t.getAttribute(o) || 0) + "", e[o], i, r, 0, 0, o)) && (s.op = o),
                this._props.push(o)
        }
    }, {
        name: "endArray",
        init: function(t, e) {
            for (var n = e.length; n--; )
                this.add(t, n, t[n] || 0, e[n])
        }
    }, Id("roundProps", Lh), Id("modifiers"), Id("snap", Ph)) || Fd;
    _d.version = ud.version = Bd.version = "3.3.4",
    kc = 1,
    vu() && Jh();
    Qh.Power0,
    Qh.Power1,
    Qh.Power2,
    Qh.Power3,
    Qh.Power4,
    Qh.Linear,
    Qh.Quad,
    Qh.Cubic,
    Qh.Quart,
    Qh.Quint,
    Qh.Strong,
    Qh.Elastic,
    Qh.Back,
    Qh.SteppedEase,
    Qh.Bounce,
    Qh.Sine,
    Qh.Expo,
    Qh.Circ;
    var kd, zd, Ud, Hd, Gd, Vd, jd, Wd, qd = {}, Xd = 180 / Math.PI, Yd = Math.PI / 180, Zd = Math.atan2, Jd = /([A-Z])/g, Qd = /(?:left|right|width|margin|padding|x)/i, Kd = /[\s,\(]\S/, $d = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
    }, tp = function(t, e) {
        return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }, ep = function(t, e) {
        return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
    }, np = function(t, e) {
        return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
    }, ip = function(t, e) {
        var n = e.s + e.c * t;
        e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
    }, rp = function(t, e) {
        return e.set(e.t, e.p, t ? e.e : e.b, e)
    }, op = function(t, e) {
        return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
    }, sp = function(t, e, n) {
        return t.style[e] = n
    }, ap = function(t, e, n) {
        return t.style.setProperty(e, n)
    }, lp = function(t, e, n) {
        return t._gsap[e] = n
    }, cp = function(t, e, n) {
        return t._gsap.scaleX = t._gsap.scaleY = n
    }, up = function(t, e, n, i, r) {
        var o = t._gsap;
        o.scaleX = o.scaleY = n,
        o.renderTransform(r, o)
    }, hp = function(t, e, n, i, r) {
        var o = t._gsap;
        o[e] = n,
        o.renderTransform(r, o)
    }, dp = "transform", pp = dp + "Origin", fp = function(t, e) {
        var n = zd.createElementNS ? zd.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : zd.createElement(t);
        return n.style ? n : zd.createElement(t)
    }, mp = function t(e, n, i) {
        var r = getComputedStyle(e);
        return r[n] || r.getPropertyValue(n.replace(Jd, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, vp(n) || n, 1) || ""
    }, gp = "O,Moz,ms,Ms,Webkit".split(","), vp = function(t, e, n) {
        var i = (e || Gd).style
          , r = 5;
        if (t in i && !n)
            return t;
        for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(gp[r] + t in i); )
            ;
        return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? gp[r] : "") + t
    }, yp = function() {
        "undefined" != typeof window && window.document && (kd = window,
        zd = kd.document,
        Ud = zd.documentElement,
        Gd = fp("div") || {
            style: {}
        },
        Vd = fp("div"),
        dp = vp(dp),
        pp = vp(pp),
        Gd.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
        Wd = !!vp("perspective"),
        Hd = 1)
    }, _p = function t(e) {
        var n, i = fp("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, o = this.nextSibling, s = this.style.cssText;
        if (Ud.appendChild(i),
        i.appendChild(this),
        this.style.display = "block",
        e)
            try {
                n = this.getBBox(),
                this._gsapBBox = this.getBBox,
                this.getBBox = t
            } catch (t) {}
        else
            this._gsapBBox && (n = this._gsapBBox());
        return r && (o ? r.insertBefore(this, o) : r.appendChild(this)),
        Ud.removeChild(i),
        this.style.cssText = s,
        n
    }, xp = function(t, e) {
        for (var n = e.length; n--; )
            if (t.hasAttribute(e[n]))
                return t.getAttribute(e[n])
    }, bp = function(t) {
        var e;
        try {
            e = t.getBBox()
        } catch (n) {
            e = _p.call(t, !0)
        }
        return e && (e.width || e.height) || t.getBBox === _p || (e = _p.call(t, !0)),
        !e || e.width || e.x || e.y ? e : {
            x: +xp(t, ["x", "cx", "x1"]) || 0,
            y: +xp(t, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        }
    }, wp = function(t) {
        return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !bp(t))
    }, Mp = function(t, e) {
        if (e) {
            var n = t.style;
            e in qd && (e = dp),
            n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e),
            n.removeProperty(e.replace(Jd, "-$1").toLowerCase())) : n.removeAttribute(e)
        }
    }, Sp = function(t, e, n, i, r, o) {
        var s = new Od(t._pt,e,n,0,1,o ? op : rp);
        return t._pt = s,
        s.b = i,
        s.e = r,
        t._props.push(n),
        s
    }, Ep = {
        deg: 1,
        rad: 1,
        turn: 1
    }, Dp = function t(e, n, i, r) {
        var o, s, a, l, c = parseFloat(i) || 0, u = (i + "").trim().substr((c + "").length) || "px", h = Gd.style, d = Qd.test(n), p = "svg" === e.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), m = 100, g = "px" === r, v = "%" === r;
        return r === u || !c || Ep[r] || Ep[u] ? c : ("px" !== u && !g && (c = t(e, n, i, "px")),
        l = e.getCTM && wp(e),
        v && (qd[n] || ~n.indexOf("adius")) ? qu(c / (l ? e.getBBox()[d ? "width" : "height"] : e[f]) * m) : (h[d ? "width" : "height"] = m + (g ? u : r),
        s = ~n.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode,
        l && (s = (e.ownerSVGElement || {}).parentNode),
        s && s !== zd && s.appendChild || (s = zd.body),
        (a = s._gsap) && v && a.width && d && a.time === Zh.time ? qu(c / a.width * m) : ((v || "%" === u) && (h.position = mp(e, "position")),
        s === e && (h.position = "static"),
        s.appendChild(Gd),
        o = Gd[f],
        s.removeChild(Gd),
        h.position = "absolute",
        d && v && ((a = Vu(s)).time = Zh.time,
        a.width = s[f]),
        qu(g ? o * c / m : o && c ? m / o * c : 0))))
    }, Tp = function(t, e, n, i) {
        var r;
        return Hd || yp(),
        e in $d && "transform" !== e && ~(e = $d[e]).indexOf(",") && (e = e.split(",")[0]),
        qd[e] && "transform" !== e ? (r = kp(t, i),
        r = "transformOrigin" !== e ? r[e] : zp(mp(t, pp)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Pp[e] && Pp[e](t, e, n) || mp(t, e) || ju(t, e) || ("opacity" === e ? 1 : 0)),
        n && !~(r + "").indexOf(" ") ? Dp(t, e, r, n) + n : r
    }, Ap = function(t, e, n, i) {
        if (!n || "none" === n) {
            var r = vp(e, t, 1)
              , o = r && mp(t, r, 1);
            o && o !== n && (e = r,
            n = o)
        }
        var s, a, l, c, u, h, d, p, f, m, g, v, y = new Od(this._pt,t.style,e,0,1,Td), _ = 0, x = 0;
        if (y.b = n,
        y.e = i,
        n += "",
        "auto" === (i += "") && (t.style[e] = i,
        i = mp(t, e) || i,
        t.style[e] = n),
        Yh(s = [n, i]),
        i = s[1],
        l = (n = s[0]).match(wu) || [],
        (i.match(wu) || []).length) {
            for (; a = wu.exec(i); )
                d = a[0],
                f = i.substring(_, a.index),
                u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1),
                d !== (h = l[x++] || "") && (c = parseFloat(h) || 0,
                g = h.substr((c + "").length),
                (v = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)),
                p = parseFloat(d),
                m = d.substr((p + "").length),
                _ = wu.lastIndex - m.length,
                m || (m = m || eu.units[e] || g,
                _ === i.length && (i += m,
                y.e += m)),
                g !== m && (c = Dp(t, e, h, m) || 0),
                y._pt = {
                    _next: y._pt,
                    p: f || 1 === x ? f : ",",
                    s: c,
                    c: v ? v * p : p - c,
                    m: u && u < 4 ? Math.round : 0
                });
            y.c = _ < i.length ? i.substring(_, i.length) : ""
        } else
            y.r = "display" === e && "none" === i ? op : rp;
        return Eu.test(i) && (y.e = 0),
        this._pt = y,
        y
    }, Cp = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
    }, Lp = function(t, e) {
        if (e.tween && e.tween._time === e.tween._dur) {
            var n, i, r, o = e.t, s = o.style, a = e.u, l = o._gsap;
            if ("all" === a || !0 === a)
                s.cssText = "",
                i = 1;
            else
                for (r = (a = a.split(",")).length; --r > -1; )
                    n = a[r],
                    qd[n] && (i = 1,
                    n = "transformOrigin" === n ? pp : dp),
                    Mp(o, n);
            i && (Mp(o, dp),
            l && (l.svg && o.removeAttribute("transform"),
            kp(o, 1),
            l.uncache = 1))
        }
    }, Pp = {
        clearProps: function(t, e, n, i, r) {
            if ("isFromStart" !== r.data) {
                var o = t._pt = new Od(t._pt,e,n,0,0,Lp);
                return o.u = i,
                o.pr = -10,
                o.tween = r,
                t._props.push(n),
                1
            }
        }
    }, Rp = [1, 0, 0, 1, 0, 0], Op = {}, Fp = function(t) {
        return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
    }, Np = function(t) {
        var e = mp(t, dp);
        return Fp(e) ? Rp : e.substr(7).match(bu).map(qu)
    }, Ip = function(t, e) {
        var n, i, r, o, s = t._gsap || Vu(t), a = t.style, l = Np(t);
        return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Rp : l : (l !== Rp || t.offsetParent || t === Ud || s.svg || (r = a.display,
        a.display = "block",
        (n = t.parentNode) && t.offsetParent || (o = 1,
        i = t.nextSibling,
        Ud.appendChild(t)),
        l = Np(t),
        r ? a.display = r : Mp(t, "display"),
        o && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : Ud.removeChild(t))),
        e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
    }, Bp = function(t, e, n, i, r, o) {
        var s, a, l, c = t._gsap, u = r || Ip(t, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, m = u[0], g = u[1], v = u[2], y = u[3], _ = u[4], x = u[5], b = e.split(" "), w = parseFloat(b[0]) || 0, M = parseFloat(b[1]) || 0;
        n ? u !== Rp && (a = m * y - g * v) && (l = w * (-g / a) + M * (m / a) - (m * x - g * _) / a,
        w = w * (y / a) + M * (-v / a) + (v * x - y * _) / a,
        M = l) : (w = (s = bp(t)).x + (~b[0].indexOf("%") ? w / 100 * s.width : w),
        M = s.y + (~(b[1] || b[0]).indexOf("%") ? M / 100 * s.height : M)),
        i || !1 !== i && c.smooth ? (_ = w - h,
        x = M - d,
        c.xOffset = p + (_ * m + x * v) - _,
        c.yOffset = f + (_ * g + x * y) - x) : c.xOffset = c.yOffset = 0,
        c.xOrigin = w,
        c.yOrigin = M,
        c.smooth = !!i,
        c.origin = e,
        c.originIsAbsolute = !!n,
        t.style[pp] = "0px 0px",
        o && (Sp(o, c, "xOrigin", h, w),
        Sp(o, c, "yOrigin", d, M),
        Sp(o, c, "xOffset", p, c.xOffset),
        Sp(o, c, "yOffset", f, c.yOffset)),
        t.setAttribute("data-svg-origin", w + " " + M)
    }, kp = function(t, e) {
        var n = t._gsap || new ld(t);
        if ("x"in n && !e && !n.uncache)
            return n;
        var i, r, o, s, a, l, c, u, h, d, p, f, m, g, v, y, _, x, b, w, M, S, E, D, T, A, C, L, P, R, O, F, N = t.style, I = n.scaleX < 0, B = "px", k = "deg", z = mp(t, pp) || "0";
        return i = r = o = l = c = u = h = d = p = 0,
        s = a = 1,
        n.svg = !(!t.getCTM || !wp(t)),
        g = Ip(t, n.svg),
        n.svg && (D = !n.uncache && t.getAttribute("data-svg-origin"),
        Bp(t, D || z, !!D || n.originIsAbsolute, !1 !== n.smooth, g)),
        f = n.xOrigin || 0,
        m = n.yOrigin || 0,
        g !== Rp && (x = g[0],
        b = g[1],
        w = g[2],
        M = g[3],
        i = S = g[4],
        r = E = g[5],
        6 === g.length ? (s = Math.sqrt(x * x + b * b),
        a = Math.sqrt(M * M + w * w),
        l = x || b ? Zd(b, x) * Xd : 0,
        (h = w || M ? Zd(w, M) * Xd + l : 0) && (a *= Math.cos(h * Yd)),
        n.svg && (i -= f - (f * x + m * w),
        r -= m - (f * b + m * M))) : (F = g[6],
        R = g[7],
        C = g[8],
        L = g[9],
        P = g[10],
        O = g[11],
        i = g[12],
        r = g[13],
        o = g[14],
        c = (v = Zd(F, P)) * Xd,
        v && (D = S * (y = Math.cos(-v)) + C * (_ = Math.sin(-v)),
        T = E * y + L * _,
        A = F * y + P * _,
        C = S * -_ + C * y,
        L = E * -_ + L * y,
        P = F * -_ + P * y,
        O = R * -_ + O * y,
        S = D,
        E = T,
        F = A),
        u = (v = Zd(-w, P)) * Xd,
        v && (y = Math.cos(-v),
        O = M * (_ = Math.sin(-v)) + O * y,
        x = D = x * y - C * _,
        b = T = b * y - L * _,
        w = A = w * y - P * _),
        l = (v = Zd(b, x)) * Xd,
        v && (D = x * (y = Math.cos(v)) + b * (_ = Math.sin(v)),
        T = S * y + E * _,
        b = b * y - x * _,
        E = E * y - S * _,
        x = D,
        S = T),
        c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0,
        u = 180 - u),
        s = qu(Math.sqrt(x * x + b * b + w * w)),
        a = qu(Math.sqrt(E * E + F * F)),
        v = Zd(S, E),
        h = Math.abs(v) > 2e-4 ? v * Xd : 0,
        p = O ? 1 / (O < 0 ? -O : O) : 0),
        n.svg && (D = t.getAttribute("transform"),
        n.forceCSS = t.setAttribute("transform", "") || !Fp(mp(t, dp)),
        D && t.setAttribute("transform", D))),
        Math.abs(h) > 90 && Math.abs(h) < 270 && (I ? (s *= -1,
        h += l <= 0 ? 180 : -180,
        l += l <= 0 ? 180 : -180) : (a *= -1,
        h += h <= 0 ? 180 : -180)),
        n.x = ((n.xPercent = i && Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0) ? 0 : i) + B,
        n.y = ((n.yPercent = r && Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0) ? 0 : r) + B,
        n.z = o + B,
        n.scaleX = qu(s),
        n.scaleY = qu(a),
        n.rotation = qu(l) + k,
        n.rotationX = qu(c) + k,
        n.rotationY = qu(u) + k,
        n.skewX = h + k,
        n.skewY = d + k,
        n.transformPerspective = p + B,
        (n.zOrigin = parseFloat(z.split(" ")[2]) || 0) && (N[pp] = zp(z)),
        n.xOffset = n.yOffset = 0,
        n.force3D = eu.force3D,
        n.renderTransform = n.svg ? qp : Wd ? Wp : Hp,
        n.uncache = 0,
        n
    }, zp = function(t) {
        return (t = t.split(" "))[0] + " " + t[1]
    }, Up = function(t, e, n) {
        var i = Mh(e);
        return qu(parseFloat(e) + parseFloat(Dp(t, "x", n + "px", i))) + i
    }, Hp = function(t, e) {
        e.z = "0px",
        e.rotationY = e.rotationX = "0deg",
        e.force3D = 0,
        Wp(t, e)
    }, Gp = "0deg", Vp = "0px", jp = ") ", Wp = function(t, e) {
        var n = e || this
          , i = n.xPercent
          , r = n.yPercent
          , o = n.x
          , s = n.y
          , a = n.z
          , l = n.rotation
          , c = n.rotationY
          , u = n.rotationX
          , h = n.skewX
          , d = n.skewY
          , p = n.scaleX
          , f = n.scaleY
          , m = n.transformPerspective
          , g = n.force3D
          , v = n.target
          , y = n.zOrigin
          , _ = ""
          , x = "auto" === g && t && 1 !== t || !0 === g;
        if (y && (u !== Gp || c !== Gp)) {
            var b, w = parseFloat(c) * Yd, M = Math.sin(w), S = Math.cos(w);
            w = parseFloat(u) * Yd,
            b = Math.cos(w),
            o = Up(v, o, M * b * -y),
            s = Up(v, s, -Math.sin(w) * -y),
            a = Up(v, a, S * b * -y + y)
        }
        m !== Vp && (_ += "perspective(" + m + jp),
        (i || r) && (_ += "translate(" + i + "%, " + r + "%) "),
        (x || o !== Vp || s !== Vp || a !== Vp) && (_ += a !== Vp || x ? "translate3d(" + o + ", " + s + ", " + a + ") " : "translate(" + o + ", " + s + jp),
        l !== Gp && (_ += "rotate(" + l + jp),
        c !== Gp && (_ += "rotateY(" + c + jp),
        u !== Gp && (_ += "rotateX(" + u + jp),
        h === Gp && d === Gp || (_ += "skew(" + h + ", " + d + jp),
        1 === p && 1 === f || (_ += "scale(" + p + ", " + f + jp),
        v.style[dp] = _ || "translate(0, 0)"
    }, qp = function(t, e) {
        var n, i, r, o, s, a = e || this, l = a.xPercent, c = a.yPercent, u = a.x, h = a.y, d = a.rotation, p = a.skewX, f = a.skewY, m = a.scaleX, g = a.scaleY, v = a.target, y = a.xOrigin, _ = a.yOrigin, x = a.xOffset, b = a.yOffset, w = a.forceCSS, M = parseFloat(u), S = parseFloat(h);
        d = parseFloat(d),
        p = parseFloat(p),
        (f = parseFloat(f)) && (p += f = parseFloat(f),
        d += f),
        d || p ? (d *= Yd,
        p *= Yd,
        n = Math.cos(d) * m,
        i = Math.sin(d) * m,
        r = Math.sin(d - p) * -g,
        o = Math.cos(d - p) * g,
        p && (f *= Yd,
        s = Math.tan(p - f),
        r *= s = Math.sqrt(1 + s * s),
        o *= s,
        f && (s = Math.tan(f),
        n *= s = Math.sqrt(1 + s * s),
        i *= s)),
        n = qu(n),
        i = qu(i),
        r = qu(r),
        o = qu(o)) : (n = m,
        o = g,
        i = r = 0),
        (M && !~(u + "").indexOf("px") || S && !~(h + "").indexOf("px")) && (M = Dp(v, "x", u, "px"),
        S = Dp(v, "y", h, "px")),
        (y || _ || x || b) && (M = qu(M + y - (y * n + _ * r) + x),
        S = qu(S + _ - (y * i + _ * o) + b)),
        (l || c) && (s = v.getBBox(),
        M = qu(M + l / 100 * s.width),
        S = qu(S + c / 100 * s.height)),
        s = "matrix(" + n + "," + i + "," + r + "," + o + "," + M + "," + S + ")",
        v.setAttribute("transform", s),
        w && (v.style[dp] = s)
    }, Xp = function(t, e, n, i, r, o) {
        var s, a, l = 360, c = hu(r), u = parseFloat(r) * (c && ~r.indexOf("rad") ? Xd : 1), h = o ? u * o : u - i, d = i + h + "deg";
        return c && ("short" === (s = r.split("_")[1]) && (h %= l) !== h % 180 && (h += h < 0 ? l : -360),
        "cw" === s && h < 0 ? h = (h + 36e9) % l - ~~(h / l) * l : "ccw" === s && h > 0 && (h = (h - 36e9) % l - ~~(h / l) * l)),
        t._pt = a = new Od(t._pt,e,n,i,h,ep),
        a.e = d,
        a.u = "deg",
        t._props.push(n),
        a
    }, Yp = function(t, e, n) {
        var i, r, o, s, a, l, c, u = Vd.style, h = n._gsap;
        for (r in u.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;",
        u[dp] = e,
        zd.body.appendChild(Vd),
        i = kp(Vd, 1),
        qd)
            (o = h[r]) !== (s = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Mh(o) !== (c = Mh(s)) ? Dp(n, r, o, c) : parseFloat(o),
            l = parseFloat(s),
            t._pt = new Od(t._pt,h,r,a,l - a,tp),
            t._pt.u = c || 0,
            t._props.push(r));
        zd.body.removeChild(Vd)
    };
    Wu("padding,margin,Width,Radius", (function(t, e) {
        var n = "Top"
          , i = "Right"
          , r = "Bottom"
          , o = "Left"
          , s = (e < 3 ? [n, i, r, o] : [n + o, n + i, r + i, r + o]).map((function(n) {
            return e < 2 ? t + n : "border" + n + t
        }
        ));
        Pp[e > 1 ? "border" + t : t] = function(t, e, n, i, r) {
            var o, a;
            if (arguments.length < 4)
                return o = s.map((function(e) {
                    return Tp(t, e, n)
                }
                )),
                5 === (a = o.join(" ")).split(o[0]).length ? o[0] : a;
            o = (i + "").split(" "),
            a = {},
            s.forEach((function(t, e) {
                return a[t] = o[e] = o[e] || o[(e - 1) / 2 | 0]
            }
            )),
            t.init(e, a, r)
        }
    }
    ));
    var Zp, Jp, Qp, Kp = {
        name: "css",
        register: yp,
        targetTest: function(t) {
            return t.style && t.nodeType
        },
        init: function(t, e, n, i, r) {
            var o, s, a, l, c, u, h, d, p, f, m, g, v, y, _, x, b, w, M, S = this._props, E = t.style;
            for (h in Hd || yp(),
            e)
                if ("autoRound" !== h && (s = e[h],
                !Bu[h] || !fd(h, e, n, i, t, r)))
                    if (c = typeof s,
                    u = Pp[h],
                    "function" === c && (c = typeof (s = s.call(n, i, t, r))),
                    "string" === c && ~s.indexOf("random(") && (s = Fh(s)),
                    u)
                        u(this, t, h, s, n) && (_ = 1);
                    else if ("--" === h.substr(0, 2))
                        this.add(E, "setProperty", getComputedStyle(t).getPropertyValue(h) + "", s + "", i, r, 0, 0, h);
                    else {
                        if (o = Tp(t, h),
                        l = parseFloat(o),
                        (f = "string" === c && "=" === s.charAt(1) ? +(s.charAt(0) + "1") : 0) && (s = s.substr(2)),
                        a = parseFloat(s),
                        h in $d && ("autoAlpha" === h && (1 === l && "hidden" === Tp(t, "visibility") && a && (l = 0),
                        Sp(this, E, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)),
                        "scale" !== h && "transform" !== h && ~(h = $d[h]).indexOf(",") && (h = h.split(",")[0])),
                        m = h in qd)
                            if (g || ((v = t._gsap).renderTransform || kp(t),
                            y = !1 !== e.smoothOrigin && v.smooth,
                            (g = this._pt = new Od(this._pt,E,dp,0,1,v.renderTransform,v,0,-1)).dep = 1),
                            "scale" === h)
                                this._pt = new Od(this._pt,v,"scaleY",v.scaleY,f ? f * a : a - v.scaleY),
                                S.push("scaleY", h),
                                h += "X";
                            else {
                                if ("transformOrigin" === h) {
                                    b = void 0,
                                    w = void 0,
                                    M = void 0,
                                    b = (x = s).split(" "),
                                    w = b[0],
                                    M = b[1] || "50%",
                                    "top" !== w && "bottom" !== w && "left" !== M && "right" !== M || (x = w,
                                    w = M,
                                    M = x),
                                    b[0] = Cp[w] || w,
                                    b[1] = Cp[M] || M,
                                    s = b.join(" "),
                                    v.svg ? Bp(t, s, 0, y, 0, this) : ((p = parseFloat(s.split(" ")[2]) || 0) !== v.zOrigin && Sp(this, v, "zOrigin", v.zOrigin, p),
                                    Sp(this, E, h, zp(o), zp(s)));
                                    continue
                                }
                                if ("svgOrigin" === h) {
                                    Bp(t, s, 1, y, 0, this);
                                    continue
                                }
                                if (h in Op) {
                                    Xp(this, v, h, l, s, f);
                                    continue
                                }
                                if ("smoothOrigin" === h) {
                                    Sp(this, v, "smooth", v.smooth, s);
                                    continue
                                }
                                if ("force3D" === h) {
                                    v[h] = s;
                                    continue
                                }
                                if ("transform" === h) {
                                    Yp(this, s, t);
                                    continue
                                }
                            }
                        else
                            h in E || (h = vp(h) || h);
                        if (m || (a || 0 === a) && (l || 0 === l) && !Kd.test(s) && h in E)
                            a || (a = 0),
                            (d = (o + "").substr((l + "").length)) !== (p = (s + "").substr((a + "").length) || (h in eu.units ? eu.units[h] : d)) && (l = Dp(t, h, o, p)),
                            this._pt = new Od(this._pt,m ? v : E,h,l,f ? f * a : a - l,"px" !== p || !1 === e.autoRound || m ? tp : ip),
                            this._pt.u = p || 0,
                            d !== p && (this._pt.b = o,
                            this._pt.r = np);
                        else if (h in E)
                            Ap.call(this, t, h, o, s);
                        else {
                            if (!(h in t)) {
                                Lu(h, s);
                                continue
                            }
                            this.add(t, h, t[h], s, i, r)
                        }
                        S.push(h)
                    }
            _ && Rd(this)
        },
        get: Tp,
        aliases: $d,
        getSetter: function(t, e, n) {
            var i = $d[e];
            return i && i.indexOf(",") < 0 && (e = i),
            e in qd && e !== pp && (t._gsap.x || Tp(t, "x")) ? n && jd === n ? "scale" === e ? cp : lp : (jd = n || {}) && ("scale" === e ? up : hp) : t.style && !fu(t.style[e]) ? sp : ~e.indexOf("-") ? ap : Sd(t, e)
        },
        core: {
            _removeProperty: Mp,
            _getMatrix: Ip
        }
    };
    Bd.utils.checkPrefix = vp,
    Qp = Wu((Zp = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Jp = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
        qd[t] = 1
    }
    )),
    Wu(Jp, (function(t) {
        eu.units[t] = "deg",
        Op[t] = 1
    }
    )),
    $d[Qp[13]] = Zp + "," + Jp,
    Wu("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
        var e = t.split(":");
        $d[e[1]] = Qp[e[0]]
    }
    )),
    Wu("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
        eu.units[t] = "px"
    }
    )),
    Bd.registerPlugin(Kp);
    var $p = Bd.registerPlugin(Kp) || Bd;
    $p.core.Tween;
    function tf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    function ef(t) {
        return (ef = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        )(t)
    }
    function nf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    function rf(t, e) {
        return (rf = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e,
            t
        }
        )(t, e)
    }
    function of(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = lf(t);
            if (e) {
                var r = lf(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else
                n = i.apply(this, arguments);
            return sf(this, n)
        }
    }
    function sf(t, e) {
        return !e || "object" !== ef(e) && "function" != typeof e ? af(t) : e
    }
    function af(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    function lf(t) {
        return (lf = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        }
        )(t)
    }
    var cf = function(t) {
        !function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }),
            e && rf(t, e)
        }(o, t);
        var e, n, i, r = of(o);
        function o() {
            var t;
            return function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, o),
            s(af(t = r.call(this)), "onScroll", "onMove"),
            t.target = 0,
            t.current = 0,
            t.currentRounded = 0,
            t.mouse = {
                x: 0,
                y: 0,
                target: null
            },
            t.ease = .115,
            t
        }
        return e = o,
        (n = [{
            key: "onRaf",
            value: function() {
                this.current = p(this.current, this.target, this.ease),
                this.currentRounded = Math.round(100 * this.current) / 100,
                this.diff = .005 * (this.target - this.current),
                Pc.emit("tick", {
                    target: this.target,
                    current: this.getSmooth(),
                    mouse: this.mouse,
                    diff: this.diff
                })
            }
        }, {
            key: "clampTarget",
            value: function() {
                this.target = Math.min(Math.max(this.target, 0), bc.bounds.scroll)
            }
        }, {
            key: "onScroll",
            value: function(t) {
                var e = t.y;
                bc.flags.locked || (this.target += e,
                this.clampTarget())
            }
        }, {
            key: "getSmooth",
            value: function() {
                return bc.sniff.isDevice ? window.pageYOffset : this.currentRounded
            }
        }, {
            key: "scrollTo",
            value: function(t) {
                bc.sniff.isDevice ? window.scrollTo({
                    top: t,
                    left: 0,
                    behavior: "smooth"
                }) : $p.to(this, {
                    target: t,
                    duration: 1,
                    ease: "expo.inOut"
                })
            }
        }, {
            key: "setScroll",
            value: function(t) {
                bc.sniff.isDevice ? window.scrollTo({
                    top: t,
                    left: 0
                }) : (this.currentRounded = 0,
                $p.set(this, {
                    target: t
                }))
            }
        }, {
            key: "onMove",
            value: function(t) {
                var e = t.x
                  , n = t.y
                  , i = t.target;
                this.mouse.x = e,
                this.mouse.y = n,
                this.mouse.target = i
            }
        }, {
            key: "getSmooth",
            value: function() {
                return d.sniff.isDevice ? window.pageYOffset : this.currentRounded
            }
        }, {
            key: "on",
            value: function() {
                Pc.on("scroll", this.onScroll),
                Pc.on("mousemove", this.onMove)
            }
        }]) && nf(e.prototype, n),
        i && nf(e, i),
        o
    }(function() {
        function t() {
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            s(this, "onRaf"),
            this.raf()
        }
        var e, n, i;
        return e = t,
        (n = [{
            key: "raf",
            value: function() {
                this.onRaf && $p.ticker.add(this.onRaf)
            }
        }]) && tf(e.prototype, n),
        i && tf(e, i),
        t
    }());
    function uf(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function hf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    var df = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            uf(this, t);
            var n = e.throttle;
            this.cb = e.cb,
            this.isDevice = d.isDevice,
            this.tick = !1,
            s(this, "gT", "gRaf", "run"),
            this.t = new xc({
                cb: this.gRaf,
                delay: n ? e.throttle.delay : 100,
                onlyAtEnd: !n || e.throttle.onlyAtEnd
            })
        }
        var e, n, i;
        return e = t,
        (n = [{
            key: "on",
            value: function() {
                this.l("add")
            }
        }, {
            key: "off",
            value: function() {
                this.l("remove")
            }
        }, {
            key: "l",
            value: function(t) {
                var e = window;
                this.isDevice ? l(e, t, "orientationchange", this.gT, !1) : l(e, t, "resize", this.gT, !1)
            }
        }, {
            key: "gT",
            value: function(t) {
                this.e = t,
                this.t.init()
            }
        }, {
            key: "gRaf",
            value: function() {
                this.tick || (this.tick = !0,
                requestAnimationFrame(this.run))
            }
        }, {
            key: "run",
            value: function() {
                this.cb(this.e),
                this.tick = !1
            }
        }]) && hf(e.prototype, n),
        i && hf(e, i),
        t
    }();
    function pf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    var ff = function() {
        function t() {
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            this.state = {
                on: 0,
                off: 0,
                coords: {
                    x: 0,
                    y: 0
                }
            },
            this.events = {
                move: d.sniff.isDevice ? "touchmove" : "mousemove",
                down: d.sniff.isDevice ? "touchstart" : "mousedown",
                up: d.sniff.isDevice ? "touchend" : "mouseup"
            },
            s(this, "onMove", "onDown", "onUp")
        }
        var e, n, i;
        return e = t,
        (n = [{
            key: "on",
            value: function() {
                this.l("add")
            }
        }, {
            key: "off",
            value: function() {
                this.l("remove")
            }
        }, {
            key: "l",
            value: function(t) {
                var e = this.events
                  , n = e.move
                  , i = e.down
                  , r = e.up;
                l(window, t, n, this.onMove),
                l(window, t, i, this.onDown),
                l(window, t, r, this.onUp)
            }
        }, {
            key: "getPos",
            value: function(t) {
                return {
                    x: t.changedTouches ? t.changedTouches[0].clientX : t.clientX,
                    y: t.changedTouches ? t.changedTouches[0].clientY : t.clientY,
                    target: t.target
                }
            }
        }, {
            key: "onMove",
            value: function(t) {
                var e = this.getPos(t)
                  , n = e.x
                  , i = e.y
                  , r = e.target;
                Pc.emit("mousemove", {
                    x: n,
                    y: i,
                    target: r,
                    e: t
                })
            }
        }, {
            key: "onDown",
            value: function(t) {
                var e = this.getPos(t)
                  , n = e.x
                  , i = e.y
                  , r = e.target;
                this.state.on = n,
                Pc.emit("mousedown", {
                    x: n,
                    y: i,
                    target: r
                })
            }
        }, {
            key: "onUp",
            value: function(t) {
                var e = this.getPos(t)
                  , n = e.x
                  , i = e.target
                  , r = this.state;
                r.off = n;
                var o = Math.abs(r.on - r.off) > 10;
                Pc.emit("mouseup", {
                    x: n,
                    target: i,
                    isClick: o
                })
            }
        }]) && pf(e.prototype, n),
        i && pf(e, i),
        t
    }()
      , mf = n(1)
      , gf = n.n(mf);
    function vf(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function yf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    var _f = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            vf(this, t),
            this.smooth = e.smooth || !1,
            bc.flags.smooth = d.sniff.isDesktop,
            s(this, "onEvent", "onScroll")
        }
        var e, n, r;
        return e = t,
        (n = [{
            key: "setScrollBounds",
            value: function() {
                bc.bounds = {};
                var t = i("[data-smooth]").getBoundingClientRect().height;
                bc.bounds.scroll = t > bc.vh ? t - bc.vh : 0
            }
        }, {
            key: "onEvent",
            value: function(t) {
                Pc.emit("scroll", {
                    y: -1 * t.deltaY
                })
            }
        }, {
            key: "onScroll",
            value: function(t) {
                Pc.emit("scroll", {
                    y: window.scrollY
                })
            }
        }, {
            key: "on",
            value: function() {
                this.l("add")
            }
        }, {
            key: "off",
            value: function() {
                this.l("remove")
            }
        }, {
            key: "l",
            value: function(t) {
                if (this.smooth) {
                    bc.body.classList.add("is-smooth");
                    var e = "add" === t ? "on" : "off";
                    new gf.a({
                        mouseMultiplier: d.sniff.isWindows ? 1.1 : .45,
                        touchMultiplier: 3.5,
                        firefoxMultiplier: d.sniff.isWindows ? 40 : 90,
                        passive: !0
                    })[e](this.onEvent)
                } else
                    listener(window, t, "scroll", this.onScroll, !0)
            }
        }]) && yf(e.prototype, n),
        r && yf(e, r),
        t
    }()
      , xf = n(2)
      , bf = n.n(xf)
      , wf = n(3)
      , Mf = n.n(wf);
    function Sf(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function Ef(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    var Df = function() {
        function t() {
            Sf(this, t),
            s(this, "animateIn", "animateOut"),
            bc.body.classList.add("is-loading"),
            bc.preloaded = Mf()(),
            this.el = null,
            this.state = {
                preloaded: !1
            },
            this.init()
        }
        var e, n, r;
        return e = t,
        (n = [{
            key: "addLoader",
            value: function() {
                var t = bc.main.firstChild;
                this.el = bf()({
                    selector: "div",
                    styles: "preloader",
                    html: '\n  \t\t\t<div class="preloader">\n  \t\t\t\t<div class="preload-content">\n          <svg class="preload-logo" viewBox="0 0 123 132" fill="white">\n          <defs>\n              <clipPath id="clipPath1">\n                  <rect x="0" y="0" width="70" height="40" />\n              </clipPath>\n              <clipPath id="clipPath2">\n                <rect x="55" y="45" width="70" height="40" />\n              </clipPath>\n              <clipPath id="clipPath3">\n                <rect x="25" y="95" width="70" height="40" />\n              </clipPath>\n          </defs>\n          <g class="p-mask">\n            <path class="AN" d="M7.1 35.8l2.9-8.2h14.4l2.9 8.2h7.5L21.3-.2h-8l-13.6 36h7.4zm15.7-14h-10l5-14 5 14zm23.9 14V10.2l16 25.5h7.2v-36H63v23.8L48.3-.2h-8.5v36h6.9z" class="st0"/> \n          </g>\n          <g class="p-mask">\n            <path class="TA" d="M78.4 83.8V54.4h11.4v-6.7h-30v6.7h11.4v29.3h7.2zm16.7 0l2.9-8.2h14.4l2.9 8.2h7.5l-13.5-36h-8l-13.6 36h7.4zm14.7-14h-10l5-14 5 14z"/>\n          </g>\n          <g class="p-mask">\n            <path class="RA" d="M38.7 131.8v-13.9h3.6l6.9 13.9h7.6L49.3 117c4.6-1.4 7.5-5.2 7.5-10.2 0-6.2-4.4-11.1-11.2-11.1H31.8v36h6.9zm5.6-20h-5.5v-10h5.5c3.5 0 5.5 2 5.5 5 0 2.9-2 5-5.5 5zm21.8 20l2.9-8.2h14.4l2.9 8.2h7.5l-13.5-36h-8l-13.6 36h7.4zm15.7-14h-10l5-14 5 14z"/>\n          </g>\n          \n        </svg>\n          </div>\n  \t\t\t</div>\n  \t\t'
                }),
                bc.main.insertBefore(this.el, t)
            }
        }, {
            key: "load",
            value: function() {
                this.animateIn()
            }
        }, {
            key: "animateIn",
            value: function() {
                var t = this
                  , e = $p.timeline({
                    paused: !0,
                    onComplete: function() {
                        return t.animateOut()
                    }
                })
                  , n = i(".preload-logo")
                  , r = i(".AN", this.el)
                  , o = i(".TA", this.el)
                  , s = i(".RA", this.el);
                e.from(n, {
                    duration: 1.4,
                    autoAlpha: 0,
                    scale: 0,
                    ease: "power3.inOut"
                }),
                e.from(r, {
                    duration: .5,
                    y: 45,
                    rotate: 20
                }, "-=0.8"),
                e.from(o, {
                    duration: .5,
                    y: 45,
                    rotate: 20
                }, "-=0.7"),
                e.from(s, {
                    duration: .5,
                    y: 45,
                    rotate: 20
                }, "-=0.6"),
                bc.sniff.isDevice ? (e.timeScale(1.4),
                e.play()) : e.play()
            }
        }, {
            key: "animateOut",
            value: function() {
                var t = this
                  , e = $p.timeline({
                    paused: !0,
                    onComplete: function() {
                        t.destroy()
                    }
                })
                  , n = bc.sniff.isDevice ? .5 : 1.2
                  , r = i(".preload-logo");
                e.to(this.el, {
                    duration: .6,
                    autoAlpha: 0,
                    delay: n
                }),
                e.to(r, {
                    duration: .4,
                    autoAlpha: 0,
                    scale: .9,
                    ease: "power3.inOut"
                }, "-=0.5"),
                bc.sniff.isDevice ? (e.timeScale(1.4),
                e.play()) : e.play()
            }
        }, {
            key: "destroy",
            value: function() {
                bc.body.classList.add("is-loaded"),
                bc.body.classList.remove("is-loading"),
                bc.main.removeChild(this.el),
                Pc.emit("Preloaded")
            }
        }, {
            key: "init",
            value: function() {
                this.addLoader(),
                this.load()
            }
        }]) && Ef(e.prototype, n),
        r && Ef(e, r),
        t
    }();
    function Tf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    var Af = new (function() {
        function t() {
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            s(this, "run", "resize"),
            this.el = i("[data-smooth]"),
            this.elems = null,
            this.current = 0,
            this.threshold = 100,
            this.sections = null,
            this.scrollbar = null
        }
        var e, n, o;
        return e = t,
        (n = [{
            key: "init",
            value: function(t) {
                this.elems = t || r("[data-smooth-item]"),
                this.getSections(),
                this.on()
            }
        }, {
            key: "update",
            value: function(t) {
                bc.flags.resize = !0,
                bc.scroll.setScrollBounds(),
                this.elems = t || r("[data-smooth-item]"),
                this.getSections(),
                this.transformSections()
            }
        }, {
            key: "clean",
            value: function() {
                this.elems = this.sections = null
            }
        }, {
            key: "run",
            value: function(t) {
                var e = t.current;
                this.current = e,
                this.transformSections()
            }
        }, {
            key: "transformSections",
            value: function() {
                if (this.sections && bc.flags.smooth)
                    for (var t = bc.flags.resize, e = 0; e < this.sections.length; e++) {
                        var n = this.sections[e]
                          , i = this.isVisible(n)
                          , r = i.isVisible
                          , o = i.transform;
                        r || t ? (n.out = !1,
                        n.transform = o,
                        n.el.style.transform = this.getTransform(o)) : n.out || (n.out = !0,
                        n.transform = o,
                        n.el.style.transform = this.getTransform(o))
                    }
            }
        }, {
            key: "isVisible",
            value: function(t) {
                var e = bc.vh
                  , n = t.top
                  , i = t.bottom
                  , r = t.offset
                  , o = t.speed
                  , s = t.parent
                  , a = s && s.transform || 0
                  , l = this.current * o
                  , c = l - r - a
                  , u = i - l
                  , h = n - l < this.threshold + e && u > -this.threshold;
                return {
                    isVisible: h,
                    transform: c
                }
            }
        }, {
            key: "getTransform",
            value: function(t) {
                return "translate3d(0, ".concat(-t, "px, 0)")
            }
        }, {
            key: "getVars",
            value: function(t, e) {
                var n = bc.vh
                  , i = c(t)
                  , r = n / 2 - i.height / 2
                  , o = i.top < n ? 0 : (i.top - r) * e - (i.top - r);
                return {
                    top: i.top + o,
                    bottom: i.bottom + o,
                    offset: o
                }
            }
        }, {
            key: "getSections",
            value: function() {
                var t = this;
                this.elems && (this.sections = null,
                this.sections = [],
                this.elems.forEach((function(e) {
                    e.style.transform = "translate3d(0, 0, 0)";
                    var n = e.dataset.speed || 1
                      , i = t.getVars(e, n)
                      , r = i.top
                      , o = i.bottom
                      , s = i.offset
                      , a = e.parentNode.closest("[data-smooth-item]");
                    a && t.sections.some((function(t) {
                        t.el === a && (a = t)
                    }
                    )),
                    t.sections.push({
                        el: e,
                        parent: a,
                        top: r,
                        bottom: o,
                        offset: s,
                        speed: n,
                        out: !0,
                        transform: 0
                    })
                }
                )))
            }
        }, {
            key: "resize",
            value: function() {
                var t = this;
                this.sections && (this.sections.forEach((function(e) {
                    e.el.style.transform = "translate3d(0, 0, 0)";
                    var n = t.getVars(e.el, e.speed)
                      , i = n.top
                      , r = n.bottom
                      , o = n.offset;
                    Object.assign(e, {
                        top: i,
                        bottom: r,
                        offset: o
                    })
                }
                )),
                this.transformSections())
            }
        }, {
            key: "anchor",
            value: function() {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                  , e = r("[data-scroll-to]");
                e.forEach((function(e) {
                    e.addEventListener("click", (function() {
                        var n = i("#".concat(e.dataset.scrollTo));
                        t ? cf.scrollTo(n.offsetTop) : window.scrollTo(0, n.offsetTop)
                    }
                    ))
                }
                ))
            }
        }, {
            key: "on",
            value: function() {
                Pc.on("tick", this.run),
                Pc.on("GlobalResize", this.resize)
            }
        }, {
            key: "off",
            value: function() {
                Pc.off("tick", this.run)
            }
        }]) && Tf(e.prototype, n),
        o && Tf(e, o),
        t
    }());
    function Cf(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n,
        t
    }
    function Lf(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function Pf(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    var Rf = function() {
        function t() {
            var e = this
              , n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            Lf(this, t),
            s(this, "run", "resize"),
            this.el = n.el,
            this.length = this.el.length,
            this.sections = [],
            this.current = 0,
            0 !== this.length && this.el.forEach((function(t) {
                e.getSections(t)
            }
            ))
        }
        var e, n, o;
        return e = t,
        (n = [{
            key: "updateScroll",
            value: function() {}
        }, {
            key: "visible",
            value: function(t) {
                var e = t.start
                  , n = t.end;
                return this.current > e && this.current < n
            }
        }, {
            key: "run",
            value: function(t) {
                this.current = t.current,
                this.playTimelines()
            }
        }, {
            key: "playTimelines",
            value: function() {
                var t = this;
                this.sections.forEach((function(e) {
                    t.visible(e) && !e.ended ? (e.tl.play(),
                    e.el.classList.add("in-view")) : e.reverse && e.tl.reverse()
                }
                ))
            }
        }, {
            key: "getSections",
            value: function(t) {
                switch (t.dataset.section || t.dataset.element) {
                case "fixed":
                    var e = this.fixed(t);
                    this.sections.push(e);
                    break;
                case "featured":
                    var n = this.featured(t);
                    this.sections.push(n);
                    break;
                case "works":
                    var i = this.works(t);
                    this.sections.push(i);
                    break;
                case "workblock":
                    var r = this.workblock(t);
                    this.sections.push(r);
                    break;
                case "split":
                    var o = this.split(t);
                    this.sections.push(o);
                    break;
                case "services":
                    var s = this.services(t);
                    this.sections.push(s);
                    break;
                case "process":
                    var a = this.process(t);
                    this.sections.push(a);
                    break;
                case "press":
                    var l = this.press(t);
                    this.sections.push(l);
                    break;
                case "pagination":
                    var c = this.pagination(t);
                    this.sections.push(c);
                    break;
                case "gallery":
                    var u = this.gallery(t);
                    this.sections.push(u);
                    break;
                case "footer":
                    var h = this.footer(t);
                    this.sections.push(h)
                }
            }
        }, {
            key: "fixed",
            value: function(t) {
                var e = $p.timeline({
                    paused: !0
                })
                  , n = r(".menu-link", t);
                return e.to(n, {
                    duration: .5,
                    y: "0%",
                    stagger: .05
                }),
                {
                    el: t,
                    start: bc.vh + 200,
                    end: bc.bounds.scroll,
                    tl: e,
                    ended: !1,
                    reverse: !0
                }
            }
        }, {
            key: "featured",
            value: function(t) {
                var e, n, o, s, a = $p.timeline({
                    paused: !0,
                    onComplete: function() {
                        p()
                    }
                }), l = i(".featured-title", t), c = r(".p", t), u = i(".button", t), h = i(".more-subtitle", t), d = i(".more-title", t);
                0 !== c.length && (e = r(".line-1", c[0]),
                n = r(".line-1", c[1])),
                u && (s = i(".circle", u),
                o = i(".arrow", u)),
                a.from(l, {
                    duration: .8,
                    y: "50%",
                    autoAlpha: 0
                }),
                e && a.from(e, {
                    duration: .6,
                    y: "101%",
                    autoAlpha: 0,
                    stagger: .1
                }, "-=0.6"),
                n && a.from(n, {
                    duration: .6,
                    y: "101%",
                    autoAlpha: 0,
                    stagger: .1
                }, "-=0.6"),
                h && a.from(h, {
                    duration: .6,
                    y: "101%",
                    autoAlpha: 0
                }, "-=0.5"),
                d && a.from(d, {
                    duration: .6,
                    y: "101%",
                    autoAlpha: 0
                }, "-=0.5"),
                s && a.from(s, {
                    duration: .8,
                    rotate: 60,
                    autoAlpha: 0,
                    ease: "power3.inOut"
                }, "-=0.8"),
                o && a.from(o, {
                    duration: .8,
                    x: 20,
                    autoAlpha: 0,
                    ease: "power3.inOut"
                }, "-=0.6");
                var p = function() {
                    s && $p.set(s, {
                        clearProps: "all"
                    }),
                    c[0] && bc.splits.reverseContent(c[0]),
                    c[1] && bc.splits.reverseContent(c[1])
                };
                return {
                    el: t,
                    bottom: 0,
                    top: 0,
                    start: 0,
                    end: 0,
                    ended: !1,
                    tl: a,
                    get updateS() {
                        return this.top - bc.vh / 1.6
                    },
                    get updateE() {
                        return this.bottom
                    }
                }
            }
        }, {
            key: "works",
            value: function(t) {
                var e, n = $p.timeline({
                    paused: !0
                }), o = t.dataset.element, s = i(".work-name", t);
                return o && (e = r(".word-0", s)),
                e && n.from(e, {
                    duration: .8,
                    autoAlpha: 0,
                    skewX: 45,
                    x: 0,
                    y: "102%",
                    stagger: .15,
                    ease: "power3.out",
                    onComplete: function() {}
                }),
                {
                    el: t,
                    bottom: 0,
                    top: 0,
                    start: 0,
                    end: 0,
                    ended: !1,
                    tl: n,
                    get updateS() {
                        return this.top - bc.vh / 1.2
                    },
                    get updateE() {
                        return this.bottom
                    }
                }
            }
        }, {
            key: "workblock",
            value: function(t) {
                var e, n, r, o, s = $p.timeline({
                    paused: !0
                }), a = i(".work-l-img", t), l = i(".work-s-img", t), c = t.classList.value.includes("-reversed");
                return e = c ? -100 : 100,
                n = c ? 100 : -100,
                r = c ? -4 : 4,
                o = c ? 4 : -4,
                s.from(a, {
                    duration: .8,
                    x: e,
                    y: "50%",
                    autoAlpha: 0,
                    rotate: r
                }),
                s.from(l, {
                    duration: .8,
                    x: n,
                    y: "50%",
                    autoAlpha: 0,
                    rotate: o
                }, "-=0.8"),
                {
                    el: t,
                    top: 0,
                    bottom: 0,
                    start: 0,
                    end: 0,
                    ended: !1,
                    tl: s,
                    get updateS() {
                        return this.top - bc.vh / 1.8
                    },
                    get updateE() {
                        return this.bottom + bc.vh / 4
                    }
                }
            }
        }, {
            key: "split",
            value: function(t) {
                var e = $p.timeline({
                    paused: !0,
                    onComplete: function() {
                        u()
                    }
                })
                  , n = i(".split-title", t)
                  , o = i(".split-subtitle", t)
                  , s = i(".p", t)
                  , a = r(".p .line-0", t)
                  , l = i(".read-more", t)
                  , c = {};
                l && (c.subtitle = i(".more-subtitle", l),
                c.title = i(".more-title", l),
                c.content = r(".p3 .line-0", l),
                c.circle = i(".circle", l),
                c.arrow = i(".arrow", l)),
                n && e.from(n, {
                    duration: .8,
                    y: 40,
                    autoAlpha: 0
                }),
                o && e.from(o, {
                    duration: .8,
                    y: 40,
                    autoAlpha: 0
                }, "-=0.7"),
                0 !== a.length && e.from(a, {
                    duration: .6,
                    y: "101%",
                    autoAlpha: 0,
                    stagger: .1
                }, "-=0.6"),
                l && (c.subtitle && e.from(c.subtitle, {
                    duration: .6,
                    y: "101%",
                    autoAlpha: 0
                }, "-=0.5"),
                c.title && e.from(c.title, {
                    duration: .6,
                    y: "101%",
                    autoAlpha: 0
                }, "-=0.5"),
                0 !== c.content.length && e.from(c.content, {
                    duration: .6,
                    y: "101%",
                    autoAlpha: 0,
                    stagger: .1
                }, "-=0.3"),
                e.from(c.circle, {
                    duration: .8,
                    rotate: 60,
                    autoAlpha: 0,
                    ease: "power3.inOut"
                }, "-=0.8"),
                e.from(c.arrow, {
                    duration: .8,
                    x: 20,
                    autoAlpha: 0,
                    ease: "power3.inOut"
                }, "-=0.6"));
                var u = function() {
                    c.circle && $p.set(c.circle, {
                        clearProps: "all"
                    }),
                    s && bc.splits.reverseContent(s)
                };
                return {
                    el: t,
                    top: 0,
                    bottom: 0,
                    start: 0,
                    end: 0,
                    ended: !1,
                    tl: e,
                    get updateS() {
                        return this.top - bc.vh / 1.4
                    },
                    get updateE() {
                        return this.bottom
                    }
                }
            }
        }, {
            key: "services",
            value: function(t) {
                var e, n, o = $p.timeline({
                    paused: !0
                }), s = r(".services-item", t);
                return s.forEach((function(t, e) {
                    var n = i(".p1", t)
                      , s = r(".p", t)
                      , a = e > 0 ? .5 * e : .5
                      , l = e > 0 ? .6 * e : "-=0.8";
                    o.from(n, {
                        duration: .8,
                        y: 20,
                        autoAlpha: 0
                    }, a),
                    o.from(s, {
                        duration: .8,
                        y: "101%",
                        autoAlpha: 0,
                        stagger: .1
                    }, l)
                }
                )),
                Cf(e = {
                    el: t,
                    top: 0,
                    bottom: 0,
                    start: 0,
                    end: 0
                }, "start", 0),
                Cf(e, "end", 0),
                Cf(e, "ended", !1),
                Cf(e, "tl", o),
                (n = {}).updateS = n.updateS || {},
                n.updateS.get = function() {
                    return this.top - bc.vh / 1.2
                }
                ,
                n.updateE = n.updateE || {},
                n.updateE.get = function() {
                    return this.bottom
                }
                ,
                function(t, e) {
                    for (var n in e)
                        (o = e[n]).configurable = o.enumerable = !0,
                        "value"in o && (o.writable = !0),
                        Object.defineProperty(t, n, o);
                    if (Object.getOwnPropertySymbols)
                        for (var i = Object.getOwnPropertySymbols(e), r = 0; r < i.length; r++) {
                            var o, s = i[r];
                            (o = e[s]).configurable = o.enumerable = !0,
                            "value"in o && (o.writable = !0),
                            Object.defineProperty(t, s, o)
                        }
                }(e, n),
                e
            }
        }, {
            key: "process",
            value: function(t) {
                var e = $p.timeline({
                    paused: !0
                })
                  , n = i(".process-nr", t)
                  , o = i(".process-title", t)
                  , s = r(".p", t);
                return e.from(n, {
                    duration: .5,
                    autoAlpha: 0,
                    y: 40
                }),
                e.from(o, {
                    duration: .5,
                    autoAlpha: 0,
                    y: 20
                }, "-=0.4"),
                e.from(s, {
                    duration: .8,
                    autoAlpha: 0,
                    y: 20,
                    stagger: .1
                }, "-=0.4"),
                {
                    el: t,
                    top: 0,
                    bottom: 0,
                    start: 0,
                    end: 0,
                    tl: e,
                    get updateS() {
                        return this.top - bc.vh / 1.6
                    },
                    get updateE() {
                        return this.bottom
                    }
                }
            }
        }, {
            key: "press",
            value: function(t) {
                var e = $p.timeline({
                    paused: !0
                })
                  , n = i(".press-nr", t)
                  , r = i(".press-media", t)
                  , o = i(".press-year", t);
                return e.from(n, {
                    duration: .8,
                    x: 40,
                    autoAlpha: 0
                }),
                e.from(r, {
                    duration: .8,
                    x: 40,
                    autoAlpha: 0
                }, "-=0.7"),
                e.from(o, {
                    duration: .8,
                    x: 40,
                    autoAlpha: 0
                }, "-=0.7"),
                {
                    el: t,
                    top: 0,
                    bottom: 0,
                    start: 0,
                    end: 0,
                    ended: !1,
                    tl: e,
                    get updateS() {
                        return this.top - bc.vh / 1.6
                    },
                    get updateE() {
                        return this.bottom
                    }
                }
            }
        }, {
            key: "pagination",
            value: function(t) {
                var e = $p.timeline({
                    paused: !0
                })
                  , n = i(".t1", t)
                  , o = r(".word-0", t);
                return e.from(o, {
                    duration: 1.2,
                    autoAlpha: 0,
                    skewX: 45,
                    x: -0,
                    y: "102%",
                    ease: "power3.out",
                    stagger: {
                        amount: .5,
                        from: "center"
                    },
                    onComplete: function() {
                        n && $p.set(n, {
                            overflow: "visible"
                        })
                    }
                }),
                {
                    el: t,
                    top: 0,
                    bottom: 0,
                    start: 0,
                    end: 0,
                    tl: e,
                    get updateS() {
                        return this.top - bc.vh / 1.6
                    },
                    get updateE() {
                        return this.bottom
                    }
                }
            }
        }, {
            key: "gallery",
            value: function(t) {
                var e = $p.timeline({
                    paused: !0
                });
                return e.from(t, {
                    duration: .5,
                    autoAlpha: 0,
                    scale: 1.1
                }),
                {
                    el: t,
                    top: 0,
                    bottom: 0,
                    start: 0,
                    end: 0,
                    tl: e,
                    get updateS() {
                        return this.top - bc.vh / 1.6
                    },
                    get updateE() {
                        return this.bottom
                    }
                }
            }
        }, {
            key: "footer",
            value: function(t) {
                var e = $p.timeline({
                    paused: !0
                })
                  , n = r(".footer-location .p", t)
                  , o = r(".p1", t)
                  , s = i(".t1", t)
                  , a = i(".line", t)
                  , l = r(".word-1", s)
                  , c = i(".copyright p");
                return e.from(n, {
                    duration: .5,
                    y: 40,
                    autoAlpha: 0,
                    stagger: .1
                }),
                e.from(o, {
                    duration: .8,
                    y: 40,
                    autoAlpha: 0,
                    stagger: .05
                }, "-=0.3"),
                e.from(l, {
                    duration: .8,
                    autoAlpha: 0,
                    skewX: 45,
                    x: 0,
                    y: "102%",
                    stagger: .15,
                    ease: "power3.out"
                }, "-=1"),
                e.from(a, {
                    duration: .8,
                    x: "-101%",
                    ease: "power3.inOut"
                }, "-=0.6"),
                e.from(c, {
                    duration: .8,
                    y: 40,
                    autoAlpha: 0,
                    stagger: .05
                }, "-=0.8"),
                {
                    el: t,
                    top: 0,
                    bottom: 0,
                    start: 0,
                    end: 0,
                    ended: !1,
                    tl: e,
                    get updateS() {
                        return this.top - bc.vh / 2
                    },
                    get updateE() {
                        return this.bottom
                    }
                }
            }
        }, {
            key: "addEvents",
            value: function() {
                Pc.on("tick", this.run)
            }
        }, {
            key: "removeEvents",
            value: function() {
                Pc.off("tick", this.run)
            }
        }, {
            key: "update",
            value: function() {
                this.sections.forEach((function(t) {
                    var e = t.el
                      , n = c(e);
                    t.top = n.top,
                    t.bottom = n.bottom,
                    t.start = t.updateS,
                    t.end = t.updateE
                }
                ))
            }
        }, {
            key: "destroy",
            value: function() {
                this.el = null,
                this.sections = [],
                this.removeEvents()
            }
        }, {
            key: "init",
            value: function() {
                this.addEvents()
            }
        }]) && Pf(e.prototype, n),
        o && Pf(e, o),
        t
    }();
    var Of = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
    function Ff(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    function Nf(t) {
        return (Nf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        )(t)
    }
    var If, Bf, kf, zf = /(?:\r|\n|\t\t)/g, Uf = /(?:\s\s+)/g, Hf = function(t) {
        return Bf.getComputedStyle(t)
    }, Gf = Array.isArray, Vf = [].slice, jf = function(t, e) {
        var n;
        return Gf(t) ? t : "string" === (n = Nf(t)) && !e && t ? Vf.call(If.querySelectorAll(t), 0) : t && "object" === n && "length"in t ? Vf.call(t, 0) : t ? [t] : []
    }, Wf = function(t) {
        return "absolute" === t.position || !0 === t.absolute
    }, qf = function(t, e) {
        for (var n, i = e.length; --i > -1; )
            if (n = e[i],
            t.substr(0, n.length) === n)
                return n.length
    }, Xf = " style='position:relative;display:inline-block;'", Yf = function() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""
          , e = arguments.length > 1 ? arguments[1] : void 0
          , n = ~t.indexOf("++")
          , i = 1;
        return n && (t = t.split("++").join("")),
        function() {
            return "<" + e + Xf + (t ? " class='" + t + (n ? i++ : "") + "'>" : ">")
        }
    }, Zf = function t(e, n, i) {
        var r = e.nodeType;
        if (1 === r || 9 === r || 11 === r)
            for (e = e.firstChild; e; e = e.nextSibling)
                t(e, n, i);
        else
            3 !== r && 4 !== r || (e.nodeValue = e.nodeValue.split(n).join(i))
    }, Jf = function(t, e) {
        for (var n = e.length; --n > -1; )
            t.push(e[n])
    }, Qf = function(t, e, n) {
        for (var i; t && t !== e; ) {
            if (i = t._next || t.nextSibling)
                return i.textContent.charAt(0) === n;
            t = t.parentNode || t._parent
        }
    }, Kf = function t(e) {
        var n, i, r = jf(e.childNodes), o = r.length;
        for (n = 0; n < o; n++)
            (i = r[n])._isSplit ? t(i) : (n && 3 === i.previousSibling.nodeType ? i.previousSibling.nodeValue += 3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue : 3 !== i.nodeType && e.insertBefore(i.firstChild, i),
            e.removeChild(i))
    }, $f = function(t, e) {
        return parseFloat(e[t]) || 0
    }, tm = function(t, e, n, i, r, o, s) {
        var a, l, c, u, h, d, p, f, m, g, v, y, _ = Hf(t), x = $f("paddingLeft", _), b = -999, w = $f("borderBottomWidth", _) + $f("borderTopWidth", _), M = $f("borderLeftWidth", _) + $f("borderRightWidth", _), S = $f("paddingTop", _) + $f("paddingBottom", _), E = $f("paddingLeft", _) + $f("paddingRight", _), D = .2 * $f("fontSize", _), T = _.textAlign, A = [], C = [], L = [], P = e.wordDelimiter || " ", R = e.tag ? e.tag : e.span ? "span" : "div", O = e.type || e.split || "chars,words,lines", F = r && ~O.indexOf("lines") ? [] : null, N = ~O.indexOf("words"), I = ~O.indexOf("chars"), B = Wf(e), k = e.linesClass, z = ~(k || "").indexOf("++"), U = [];
        for (z && (k = k.split("++").join("")),
        c = (l = t.getElementsByTagName("*")).length,
        h = [],
        a = 0; a < c; a++)
            h[a] = l[a];
        if (F || B)
            for (a = 0; a < c; a++)
                ((d = (u = h[a]).parentNode === t) || B || I && !N) && (y = u.offsetTop,
                F && d && Math.abs(y - b) > D && ("BR" !== u.nodeName || 0 === a) && (p = [],
                F.push(p),
                b = y),
                B && (u._x = u.offsetLeft,
                u._y = y,
                u._w = u.offsetWidth,
                u._h = u.offsetHeight),
                F && ((u._isSplit && d || !I && d || N && d || !N && u.parentNode.parentNode === t && !u.parentNode._isSplit) && (p.push(u),
                u._x -= x,
                Qf(u, t, P) && (u._wordEnd = !0)),
                "BR" === u.nodeName && (u.nextSibling && "BR" === u.nextSibling.nodeName || 0 === a) && F.push([])));
        for (a = 0; a < c; a++)
            d = (u = h[a]).parentNode === t,
            "BR" !== u.nodeName ? (B && (m = u.style,
            N || d || (u._x += u.parentNode._x,
            u._y += u.parentNode._y),
            m.left = u._x + "px",
            m.top = u._y + "px",
            m.position = "absolute",
            m.display = "block",
            m.width = u._w + 1 + "px",
            m.height = u._h + "px"),
            !N && I ? u._isSplit ? (u._next = u.nextSibling,
            u.parentNode.appendChild(u)) : u.parentNode._isSplit ? (u._parent = u.parentNode,
            !u.previousSibling && u.firstChild && (u.firstChild._isFirst = !0),
            u.nextSibling && " " === u.nextSibling.textContent && !u.nextSibling.nextSibling && U.push(u.nextSibling),
            u._next = u.nextSibling && u.nextSibling._isFirst ? null : u.nextSibling,
            u.parentNode.removeChild(u),
            h.splice(a--, 1),
            c--) : d || (y = !u.nextSibling && Qf(u.parentNode, t, P),
            u.parentNode._parent && u.parentNode._parent.appendChild(u),
            y && u.parentNode.appendChild(If.createTextNode(" ")),
            "span" === R && (u.style.display = "inline"),
            A.push(u)) : u.parentNode._isSplit && !u._isSplit && "" !== u.innerHTML ? C.push(u) : I && !u._isSplit && ("span" === R && (u.style.display = "inline"),
            A.push(u))) : F || B ? (u.parentNode && u.parentNode.removeChild(u),
            h.splice(a--, 1),
            c--) : N || t.appendChild(u);
        for (a = U.length; --a > -1; )
            U[a].parentNode.removeChild(U[a]);
        if (F) {
            for (B && (g = If.createElement(R),
            t.appendChild(g),
            v = g.offsetWidth + "px",
            y = g.offsetParent === t ? 0 : t.offsetLeft,
            t.removeChild(g)),
            m = t.style.cssText,
            t.style.cssText = "display:none;"; t.firstChild; )
                t.removeChild(t.firstChild);
            for (f = " " === P && (!B || !N && !I),
            a = 0; a < F.length; a++) {
                for (p = F[a],
                (g = If.createElement(R)).style.cssText = "display:block;text-align:" + T + ";position:" + (B ? "absolute;" : "relative;"),
                k && (g.className = k + (z ? a + 1 : "")),
                L.push(g),
                c = p.length,
                l = 0; l < c; l++)
                    "BR" !== p[l].nodeName && (u = p[l],
                    g.appendChild(u),
                    f && u._wordEnd && g.appendChild(If.createTextNode(" ")),
                    B && (0 === l && (g.style.top = u._y + "px",
                    g.style.left = x + y + "px"),
                    u.style.top = "0px",
                    y && (u.style.left = u._x - y + "px")));
                0 === c ? g.innerHTML = "&nbsp;" : N || I || (Kf(g),
                Zf(g, String.fromCharCode(160), " ")),
                B && (g.style.width = v,
                g.style.height = u._h + "px"),
                t.appendChild(g)
            }
            t.style.cssText = m
        }
        B && (s > t.clientHeight && (t.style.height = s - S + "px",
        t.clientHeight < s && (t.style.height = s + w + "px")),
        o > t.clientWidth && (t.style.width = o - E + "px",
        t.clientWidth < o && (t.style.width = o + M + "px"))),
        Jf(n, A),
        N && Jf(i, C),
        Jf(r, L)
    }, em = function(t, e, n, i) {
        var r, o, s, a, l, c, u, h, d = e.tag ? e.tag : e.span ? "span" : "div", p = ~(e.type || e.split || "chars,words,lines").indexOf("chars"), f = Wf(e), m = e.wordDelimiter || " ", g = " " !== m ? "" : f ? "&#173; " : " ", v = "</" + d + ">", y = 1, _ = e.specialChars ? "function" == typeof e.specialChars ? e.specialChars : qf : null, x = If.createElement("div"), b = t.parentNode;
        for (b.insertBefore(x, t),
        x.textContent = t.nodeValue,
        b.removeChild(t),
        u = -1 !== (r = function t(e) {
            var n = e.nodeType
              , i = "";
            if (1 === n || 9 === n || 11 === n) {
                if ("string" == typeof e.textContent)
                    return e.textContent;
                for (e = e.firstChild; e; e = e.nextSibling)
                    i += t(e)
            } else if (3 === n || 4 === n)
                return e.nodeValue;
            return i
        }(t = x)).indexOf("<"),
        !1 !== e.reduceWhiteSpace && (r = r.replace(Uf, " ").replace(zf, "")),
        u && (r = r.split("<").join("{{LT}}")),
        l = r.length,
        o = (" " === r.charAt(0) ? g : "") + n(),
        s = 0; s < l; s++)
            if (c = r.charAt(s),
            _ && (h = _(r.substr(s), e.specialChars)))
                c = r.substr(s, h || 1),
                o += p && " " !== c ? i() + c + "</" + d + ">" : c,
                s += h - 1;
            else if (c === m && r.charAt(s - 1) !== m && s) {
                for (o += y ? v : "",
                y = 0; r.charAt(s + 1) === m; )
                    o += g,
                    s++;
                s === l - 1 ? o += g : ")" !== r.charAt(s + 1) && (o += g + n(),
                y = 1)
            } else
                "{" === c && "{{LT}}" === r.substr(s, 6) ? (o += p ? i() + "{{LT}}</" + d + ">" : "{{LT}}",
                s += 5) : c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319 || r.charCodeAt(s + 1) >= 65024 && r.charCodeAt(s + 1) <= 65039 ? (a = ((r.substr(s, 12).split(Of) || [])[1] || "").length || 2,
                o += p && " " !== c ? i() + r.substr(s, a) + "</" + d + ">" : r.substr(s, a),
                s += a - 1) : o += p && " " !== c ? i() + c + "</" + d + ">" : c;
        t.outerHTML = o + (y ? v : ""),
        u && Zf(b, "{{LT}}", "<")
    }, nm = function t(e, n, i, r) {
        var o, s, a = jf(e.childNodes), l = a.length, c = Wf(n);
        if (3 !== e.nodeType || l > 1) {
            for (n.absolute = !1,
            o = 0; o < l; o++)
                (3 !== (s = a[o]).nodeType || /\S+/.test(s.nodeValue)) && (c && 3 !== s.nodeType && "inline" === Hf(s).display && (s.style.display = "inline-block",
                s.style.position = "relative"),
                s._isSplit = !0,
                t(s, n, i, r));
            return n.absolute = c,
            void (e._isSplit = !0)
        }
        em(e, n, i, r)
    }, im = function() {
        function t(e, n) {
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            kf || (If = document,
            Bf = window,
            kf = 1),
            this.elements = jf(e),
            this.chars = [],
            this.words = [],
            this.lines = [],
            this._originals = [],
            this.vars = n || {},
            this.split(n)
        }
        var e, n, i;
        return e = t,
        i = [{
            key: "create",
            value: function(e, n) {
                return new t(e,n)
            }
        }],
        (n = [{
            key: "split",
            value: function(t) {
                this.isSplit && this.revert(),
                this.vars = t = t || this.vars,
                this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                for (var e, n, i, r = this.elements.length, o = t.tag ? t.tag : t.span ? "span" : "div", s = Yf(t.wordsClass, o), a = Yf(t.charsClass, o); --r > -1; )
                    i = this.elements[r],
                    this._originals[r] = i.innerHTML,
                    e = i.clientHeight,
                    n = i.clientWidth,
                    nm(i, t, s, a),
                    tm(i, t, this.chars, this.words, this.lines, n, e);
                return this.chars.reverse(),
                this.words.reverse(),
                this.lines.reverse(),
                this.isSplit = !0,
                this
            }
        }, {
            key: "revert",
            value: function() {
                var t = this._originals;
                if (!t)
                    throw "revert() call wasn't scoped properly.";
                return this.elements.forEach((function(e, n) {
                    return e.innerHTML = t[n]
                }
                )),
                this.chars = [],
                this.words = [],
                this.lines = [],
                this.isSplit = !1,
                this
            }
        }]) && Ff(e.prototype, n),
        i && Ff(e, i),
        t
    }();
    function rm(t, e) {
        return function(t) {
            if (Array.isArray(t))
                return t
        }(t) || function(t, e) {
            if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t)))
                return;
            var n = []
              , i = !0
              , r = !1
              , o = void 0;
            try {
                for (var s, a = t[Symbol.iterator](); !(i = (s = a.next()).done) && (n.push(s.value),
                !e || n.length !== e); i = !0)
                    ;
            } catch (t) {
                r = !0,
                o = t
            } finally {
                try {
                    i || null == a.return || a.return()
                } finally {
                    if (r)
                        throw o
                }
            }
            return n
        }(t, e) || function(t, e) {
            if (!t)
                return;
            if ("string" == typeof t)
                return om(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            "Object" === n && t.constructor && (n = t.constructor.name);
            if ("Map" === n || "Set" === n)
                return Array.from(t);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return om(t, e)
        }(t, e) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function om(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, i = new Array(e); n < e; n++)
            i[n] = t[n];
        return i
    }
    function sm(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function am(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    im.version = "3.4.2";
    var lm = function() {
        function t() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            sm(this, t),
            this.els = e.els || r("[data-split]"),
            this.splits = [],
            this.splitContent()
        }
        var e, n, i;
        return e = t,
        (n = [{
            key: "splitContent",
            value: function() {
                var t = this;
                0 !== this.els.length && this.els.forEach((function(e) {
                    var n = e.dataset.split.split(",")
                      , i = {};
                    i.el = e,
                    n.forEach((function(t, n) {
                        switch (t.trim()) {
                        case "lines":
                            i[n] = new im(e,{
                                type: "lines",
                                linesClass: "line-".concat(n)
                            });
                            break;
                        case "words":
                            i[n] = new im(e,{
                                type: "words",
                                wordsClass: "word-".concat(n)
                            });
                            break;
                        case "chars":
                            i[n] = new im(e,{
                                type: "chars",
                                charsClass: "char-".concat(n)
                            })
                        }
                    }
                    )),
                    t.splits.push(i)
                }
                ))
            }
        }, {
            key: "reverseContent",
            value: function(t) {
                var e = [];
                this.splits.forEach((function(n) {
                    if (n.el === t)
                        for (var i = 0, r = Object.entries(n); i < r.length; i++) {
                            var o = rm(r[i], 2)
                              , s = o[0]
                              , a = o[1];
                            "el" !== s && e.push(a)
                        }
                }
                )),
                e.reverse().forEach((function(t) {
                    t.revert()
                }
                ))
            }
        }, {
            key: "init",
            value: function() {}
        }]) && am(e.prototype, n),
        i && am(e, i),
        t
    }();
    function cm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    var um = function() {
        function t() {
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            s(this, "run", "resize", "onHover", "onLeave", "onMove"),
            this.isHome = i(".is-home"),
            this.isPage = i(".page"),
            this.isSingle = i(".single"),
            this.mouse = {},
            this.options = {
                strength: .15
            };
            var e = this.isSingle ? this.isSingle.dataset.color : null
              , n = this.isPage ? this.isPage.dataset.color : null;
            this.isSingle && (this.color = new Ne(e || 13480053)),
            this.isPage && (this.color = new Ne(n || 13480053)),
            this.white = new Ne(16119285),
            this.init()
        }
        var e, n, o;
        return e = t,
        (n = [{
            key: "createScene",
            value: function() {
                var t = i(".canvas");
                this.scene = new eo,
                this.renderer = new $r({
                    canvas: t,
                    antialias: !0
                }),
                this.renderer.setSize(bc.vw, bc.vh),
                this.renderer.setPixelRatio = window.devicePixelRatio,
                this.renderer.setClearColor(16119285, 1),
                this.clock = new Rl,
                $p.to(t, {
                    duration: 1,
                    autoAlpha: 1
                })
            }
        }, {
            key: "createCamera",
            value: function() {
                this.camera = new ll(bc.vw / -2,bc.vw / 2,bc.vh / 2,bc.vh / -2,1,100),
                this.camera.lookAt(this.scene.position),
                this.camera.position.z = 1,
                this.fov = this.camera.fov,
                this.scene.add(this.camera),
                this.viewSize = {
                    width: bc.vw,
                    height: bc.vh
                }
            }
        }, {
            key: "movePlanes",
            value: function() {
                this.background.position.y = this.current
            }
        }, {
            key: "getBackgroundMesh",
            value: function() {
                var t = new Zn(bc.vw,bc.vw,32,32);
                this.viewSize.width,
                this.viewSize.height,
                this.uBackground = {
                    uOffset: {
                        value: new it
                    },
                    uRes: {
                        value: new it(bc.vw,bc.vh)
                    },
                    uR1: {
                        value: 0
                    },
                    uR2: {
                        value: 0
                    },
                    uTime: {
                        value: 0
                    },
                    uColor: {
                        value: new ft(this.color.r,this.color.g,this.color.b)
                    }
                };
                var e = new In({
                    uniforms: this.uBackground,
                    vertexShader: "\n  varying vec2 vUv;\n  void main() {\n  vUv =  uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  }\n\n",
                    fragmentShader: this.isPage ? "\n\n  uniform float uR1;\n  uniform float uR2;  \n  uniform float uTime;\n  uniform vec3 uColor;\n  varying vec2 vUv;\n  \n\n  float Circle (vec2 uv, vec2 pos, float r, float blur) {\n\n    float d = length(uv + pos);\n    float c = smoothstep(r, r - blur, d);\n\n    return c;\n  } \n\n  void main() {\n\n    vec2 p = vUv;\n\n    vec3 lightGrey = vec3(0.9607843137254902, 0.9607843137254902, 0.9607843137254902);\n    vec3 darkGrey = vec3(0.55, 0.55, 0.55);\n    vec3 gold = vec3(0.803921568627451, 0.6901960784313725, 0.4588235294117647);\n    vec3 color = vec3(uColor.r, uColor.g, uColor.b);\n\n    if(gold == color) {\n      \n    } else {\n      darkGrey = vec3(uColor.r, uColor.g, uColor.b) / 0.75;\n      gold = color;\n    }\n\n    p -= 0.5;\n\n    float circle1 = Circle(p, vec2( - .15, .18), uR1, 0.34);\n    float circle2 = Circle(p, vec2(  0.3, -.12), uR2, 0.30);\n\n    // Mixtures\n    vec3 color1 = mix(lightGrey, gold, circle1);\n    vec3 color2 = mix(lightGrey, darkGrey, circle2);\n    vec3 c = min(color1, color2);\n\n\n\n\n    gl_FragColor = vec4(c, 1.);\n  }\n\n" : "\n\n  uniform float uR1;\n  uniform float uR2;  \n  uniform float uTime;\n  uniform vec3 uColor;\n  varying vec2 vUv;\n\n  float Circle (vec2 uv, vec2 pos, float r, float blur) {\n\n    float d = length(uv + pos);\n    float c = smoothstep(r, r - blur, d);\n\n    return c;\n  } \n\n  void main() {\n\n    vec2 p = vUv;\n    vec3 lightGrey = vec3(0.9607843137254902, 0.9607843137254902, 0.9607843137254902);\n    vec3 darkGrey = vec3(0.55, 0.55, 0.55);\n    vec3 gold = vec3(uColor.r, uColor.g, uColor.b);\n\n    p -= 0.5;\n\n    float color = 0.;\n\n    float circle1 = Circle(p, vec2( 0.32, -.12), uR2, 0.30);\n   \n    // Mixtures\n    vec3 c = mix(lightGrey, gold, circle1);\n   \n\n\n    gl_FragColor = vec4(c, 1.);\n  }\n\n",
                    transparent: !0
                });
                this.background = new Cn(t,e),
                this.scene.add(this.background),
                this.background.position.z = -.2,
                $p.to(this.uBackground.uR1, {
                    duration: 3,
                    value: .32,
                    delay: .15,
                    ease: "power2.inOut"
                }),
                $p.to(this.uBackground.uR2, {
                    duration: 3,
                    value: .21,
                    ease: "power2.inOut"
                })
            }
        }, {
            key: "getProjectMesh",
            value: function() {
                this.position = new ft(0,0,0);
                var t = new Zn(450,600,32,32);
                this.viewSize.width,
                this.viewSize.height,
                this.uProjects = {
                    uTexture: {
                        value: null
                    },
                    uOffset: {
                        value: new it
                    },
                    uAlpha: {
                        value: 0
                    },
                    uRes: {
                        value: new it(bc.vw,bc.vh)
                    },
                    uRatio: {
                        value: new it
                    }
                };
                var e = new In({
                    uniforms: this.uProjects,
                    vertexShader: "\n  uniform vec2 uOffset;\n  varying vec2 vUv;\n  uniform vec2 uRes;\n\n  #define M_PI 3.1415926535897932384626433832795\n\n  vec3 deformationCurve(vec3 position, vec2 uv, vec2 offset) {\n  position.x = position.x + (sin(uv.y * M_PI) * offset.x);\n  position.y = position.y + (sin(uv.x * M_PI) * offset.y);\n  return position;\n  }\n\n  void main() {\n  vUv =  uv - (uOffset * .002);\n  \n  vec3 newPosition = deformationCurve(position, uv, uOffset);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );\n  }\n\n",
                    fragmentShader: "\n\n  uniform sampler2D uTexture;\n  uniform float uAlpha;\n  uniform vec2 uRes;\n  uniform vec2 uRatio;\n  varying vec2 vUv;\n\n  vec2 backgroundCoverUv(vec2 screenSize, vec2 imageSize, vec2 uv) {\n    float screenRatio = screenSize.x / screenSize.y;\n    float imageRatio = imageSize.x / imageSize.y;\n    vec2 newSize = screenRatio < imageRatio\n      ? vec2(imageSize.x * screenSize.y / imageSize.y, screenSize.y)\n      : vec2(screenSize.x, imageSize.y * screenSize.x / imageSize.x);\n    vec2 newOffset = (screenRatio < imageRatio\n      ? vec2((newSize.x - screenSize.x) / 2.0, 0.0)\n      : vec2(0.0, (newSize.y - screenSize.y) / 2.0)) / newSize;\n    return uv * screenSize / newSize + newOffset;\n  }\n\n  void main() {\n\n    vec4 color = vec4(0.0);\n    vec2 uv = backgroundCoverUv(vec2(1.,1.25), uRatio, vUv);\n\n    color = texture2D(uTexture,uv);\n\n    gl_FragColor = vec4(vec3(color), uAlpha);\n  }\n\n",
                    transparent: !0
                });
                this.plane = new Cn(t,e),
                this.scene.add(this.plane)
            }
        }, {
            key: "loadTexture",
            value: function() {
                var t = window.app
                  , e = t.preload.projects
                  , n = t.preload.projects.map((function(t) {
                    return t.image_l.image.asset.url
                }
                ));
                vc(n, e).then((function() {}
                ))
            }
        }, {
            key: "els",
            value: function() {
                this.projects = r(".work-link"),
                this.wrapper = i(".works")
            }
        }, {
            key: "run",
            value: function(t) {
                this.isHome && !bc.sniff.isDevice && this.onMove(t.mouse),
                this.current = t.current,
                this.renderer && this.renderer.render(this.scene, this.camera),
                this.uBackground.uTime.value = this.clock.getElapsedTime(),
                this.movePlanes()
            }
        }, {
            key: "addEvents",
            value: function() {
                var t = this;
                Pc.on("tick", this.run),
                Pc.on("GlobalResize", this.resize),
                this.isHome && !bc.sniff.isDevice && (this.projects.forEach((function(e, n) {
                    e.addEventListener("mouseover", t.onHover.bind(t, n), !1)
                }
                )),
                this.wrapper.addEventListener("mouseleave", this.onLeave.bind(this), !1))
            }
        }, {
            key: "removeEvents",
            value: function() {
                var t = this;
                Pc.off("tick", this.run),
                Pc.off("GlobalResize", this.resize),
                this.isHome && !bc.sniff.isDevice && (this.projects.forEach((function(e, n) {
                    e.removeEventListener("mouseover", t.onHover.bind(t, n), !1)
                }
                )),
                this.wrapper.removeEventListener("mouseleave", this.onLeave.bind(this), !1))
            }
        }, {
            key: "onMove",
            value: function(t) {
                this.mouse.x = t.x / bc.vw * 2 - 1,
                this.mouse.y = -t.y / bc.vh * 2 + 1,
                this.onMouseMove()
            }
        }, {
            key: "onMouseMove",
            value: function() {
                var t = this.mouse.x.map(-1, 1, -this.viewSize.width / 2, this.viewSize.width / 2)
                  , e = this.mouse.y.map(-1, 1, -this.viewSize.height / 2, this.viewSize.height / 2);
                this.position = new ft(t,e,-.1),
                $p.to(this.plane.position, {
                    duration: 1,
                    x: t,
                    y: e,
                    z: -.1,
                    ease: "power4.out",
                    onUpdate: this.onPositionUpdate.bind(this)
                })
            }
        }, {
            key: "onMouseEnter",
            value: function() {
                if (!this.currentItem || !this.isMouseOver) {
                    if (-1 === this.mouse.x && 1 === this.mouse.y)
                        return;
                    this.isMouseOver = !0,
                    $p.to(this.uProjects.uAlpha, {
                        duration: .5,
                        value: 1,
                        ease: "power4.out"
                    })
                }
            }
        }, {
            key: "onHover",
            value: function(t, e) {
                this.onMouseEnter(),
                this.currentItem && this.currentItem.index === t || this.onTargetChange(t)
            }
        }, {
            key: "onMouseLeave",
            value: function(t) {
                $p.to(this.uProjects.uAlpha, {
                    duration: .5,
                    value: 0,
                    ease: "power4.out"
                })
            }
        }, {
            key: "onLeave",
            value: function(t) {
                this.isMouseOver = !1,
                this.onMouseLeave(t)
            }
        }, {
            key: "onPositionUpdate",
            value: function() {
                var t = this.plane.position.clone().sub(this.position).multiplyScalar(-this.options.strength);
                this.uProjects.uOffset.value = t
            }
        }, {
            key: "onTargetChange",
            value: function(t) {
                var e = window.app;
                this.currentItem = e.preload.projects[t],
                this.currentItem.texture && (this.uProjects.uTexture.value = this.currentItem.texture,
                this.uProjects.uRatio.value.x = this.currentItem.texture.image.naturalWidth,
                this.uProjects.uRatio.value.y = this.currentItem.texture.image.naturalHeight)
            }
        }, {
            key: "resize",
            value: function() {
                this.camera.aspect = bc.vw / bc.vh,
                this.camera.left = bc.vw / -2,
                this.camera.right = bc.vw / 2,
                this.camera.top = bc.vh / 2,
                this.camera.bottom = bc.vh / -2,
                this.camera.updateProjectionMatrix(),
                this.renderer.setSize(bc.vw, bc.vh)
            }
        }, {
            key: "destroy",
            value: function() {
                this.removeEvents()
            }
        }, {
            key: "init",
            value: function() {
                this.els(),
                this.createScene(),
                this.createCamera(),
                this.loadTexture(),
                this.getBackgroundMesh(),
                this.isHome && !bc.sniff.isDevice && this.getProjectMesh(),
                this.addEvents(),
                this.resize()
            }
        }]) && cm(e.prototype, n),
        o && cm(e, o),
        t
    }();
    function hm(t) {
        return (hm = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        )(t)
    }
    function dm(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function pm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    function fm(t, e) {
        return (fm = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e,
            t
        }
        )(t, e)
    }
    function mm(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = ym(t);
            if (e) {
                var r = ym(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else
                n = i.apply(this, arguments);
            return gm(this, n)
        }
    }
    function gm(t, e) {
        return !e || "object" !== hm(e) && "function" != typeof e ? vm(t) : e
    }
    function vm(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    function ym(t) {
        return (ym = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        }
        )(t)
    }
    var _m = function(t) {
        !function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }),
            e && fm(t, e)
        }(c, t);
        var e, n, a, l = mm(c);
        function c() {
            var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            dm(this, c),
            t = l.call(this, e),
            bc.sniff.isDevice && bc.body.classList.add("is-device"),
            s(vm(t), "run", "openMenu", "closeMenu", "preload", "onload");
            var n = {
                hour: "numeric",
                minute: "numeric",
                timeZone: "America/Guatemala",
                weekday: "short"
            };
            return t.GT = (new Date).toLocaleDateString("en-US", n),
            t.preloadData = window.app.preload,
            t
        }
        return e = c,
        (n = [{
            key: "onEnter",
            value: function() {
                this.el = this.wrap.lastElementChild,
                this.data = {
                    r: 0
                }
            }
        }, {
            key: "onEnterCompleted",
            value: function() {
                bc.splits = new lm,
                this.els(),
                this.on(),
                this.smooth(),
                this.addThree(),
                this.addDate()
            }
        }, {
            key: "els",
            value: function() {
                var t;
                this.scroll = i(".scroll-circle"),
                this.scrollIcon = i(".scroll.icon"),
                this.date = i(".footer-location span", this.el),
                this.menu = i(".open-menu"),
                this.mobile = i(".mobile-menu"),
                this.back = i(".back"),
                this.imgs = o(document.images),
                this.mobileMenu = i(".mobile-menu"),
                t = .01 * window.innerHeight,
                document.documentElement.style.setProperty("--vh", "".concat(t, "px"))
            }
        }, {
            key: "on",
            value: function() {
                Pc.on("tick", this.run),
                Pc.on("Preloaded", this.preload),
                this.menu.addEventListener("click", this.openMenu),
                this.back.addEventListener("click", this.closeMenu)
            }
        }, {
            key: "off",
            value: function() {
                this.menu.removeEventListener("click", this.openMenu),
                this.back.removeEventListener("click", this.closeMenu)
            }
        }, {
            key: "loadImages",
            value: function() {
                if (!(this.current < bc.vh)) {
                    if (!bc.flags.load) {
                        var t = this.preloadData.projects.map((function(t) {
                            return t.image_l.image.asset.url
                        }
                        ));
                        bc.preloaded.fetch(t).then((function(t) {}
                        )),
                        bc.preloaded.onprogress = function(t) {}
                        ,
                        bc.preloaded.oncomplete = function() {}
                    }
                    bc.flags.load = !0
                }
            }
        }, {
            key: "preload",
            value: function() {
                bc.flags.preloaded = !0,
                this.addThree()
            }
        }, {
            key: "run",
            value: function(t) {
                var e = t.mouse
                  , n = t.current
                  , i = f(.25 * e.x, 0, bc.vw)
                  , r = f(.25 * n, 0, bc.vh);
                this.data.r = p(this.data.r, i, .025),
                this.scrollIcon.style.transform = "rotate(".concat(-r, "deg)"),
                this.current = n,
                this.loadImages()
            }
        }, {
            key: "openMenu",
            value: function() {
                bc.body.classList.add("is-fixed"),
                this.tl = Bd.timeline({
                    paused: !0
                });
                var t = i(".logo", this.mobile)
                  , e = i(".back", this.mobile)
                  , n = r(".menu-link span", this.mobile)
                  , o = i(".circle", this.mobile);
                this.tl.to(this.mobile, {
                    duration: .8,
                    autoAlpha: 1
                }),
                this.tl.from(n, {
                    duration: 1.4,
                    y: "101%",
                    stagger: .1,
                    ease: "power3.inOut"
                }, "-=0.8"),
                this.tl.from(o, {
                    duration: .5,
                    y: 20,
                    autoAlpha: 0
                }, "-=0.4"),
                this.tl.from(e, {
                    duration: .5,
                    y: -20,
                    autoAlpha: 0
                }, "-=1"),
                this.tl.from(t, {
                    duration: .5,
                    y: -20,
                    autoAlpha: 0
                }, "-=0.85"),
                this.tl.play()
            }
        }, {
            key: "closeMenu",
            value: function() {
                bc.body.classList.remove("is-fixed"),
                this.tl = Bd.timeline({
                    paused: !0
                }),
                this.tl.to(this.mobile, {
                    duration: .8,
                    autoAlpha: 0
                }),
                this.tl.play()
            }
        }, {
            key: "addDate",
            value: function() {
                this.date.innerHTML = this.GT
            }
        }, {
            key: "smooth",
            value: function() {
                var t = this
                  , e = r("[data-smooth-item]", this.el)
                  , n = r("[data-section]", this.el)
                  , i = r("[data-element]", this.el);
                Af.init(e),
                bc.scroll.setScrollBounds(),
                this.sectionAnimation = new Rf({
                    el: n
                }),
                this.elementAnimation = new Rf({
                    el: i
                }),
                Promise.all(this.imgs.filter((function(t) {
                    return !t.complete
                }
                )).map((function(t) {
                    return new Promise((function(e) {
                        t.onload = t.onerror = e
                    }
                    ))
                }
                ))).then((function() {
                    Af && Af.update()
                }
                )),
                setTimeout((function() {
                    t.sectionAnimation.update(),
                    t.elementAnimation.update(),
                    t.sectionAnimation.init(),
                    t.elementAnimation.init()
                }
                ), 1200)
            }
        }, {
            key: "addThree",
            value: function() {
                bc.flags.preloaded && (bc.sniff.isDevice || (this.three = new um))
            }
        }, {
            key: "onLeave",
            value: function() {
                Af.off(),
                this.off(),
                bc.flags.locked = !0,
                bc.sniff.isDevice && bc.body.classList.add("is-fixed"),
                this.sectionAnimation.destroy(),
                this.elementAnimation.destroy(),
                this.three && this.three.destroy()
            }
        }, {
            key: "onLeaveCompleted",
            value: function() {}
        }]) && pm(e.prototype, n),
        a && pm(e, a),
        c
    }(Cc.Renderer)
      , xm = function() {
        var t = $p.timeline({
            onComplete: function() {
                bc.flags.locked = !1
            }
        })
          , e = i("header")
          , n = i(".logo", e)
          , o = r(".menu-item", e);
        return t.from(o, {
            duration: .5,
            autoAlpha: 0,
            y: -20,
            stagger: .1
        }),
        t.from(n, {
            duration: .5,
            autoAlpha: 0,
            y: -20
        }),
        t
    };
    function bm(t) {
        return (bm = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        )(t)
    }
    function wm(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function Mm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    function Sm(t, e, n) {
        return (Sm = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
            var i = function(t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Cm(t)); )
                    ;
                return t
            }(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        }
        )(t, e, n || t)
    }
    function Em(t, e) {
        return (Em = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e,
            t
        }
        )(t, e)
    }
    function Dm(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = Cm(t);
            if (e) {
                var r = Cm(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else
                n = i.apply(this, arguments);
            return Tm(this, n)
        }
    }
    function Tm(t, e) {
        return !e || "object" !== bm(e) && "function" != typeof e ? Am(t) : e
    }
    function Am(t) {
        if (void 0 === t)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    function Cm(t) {
        return (Cm = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        }
        )(t)
    }
    var Lm = function(t) {
        !function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }),
            e && Em(t, e)
        }(l, t);
        var e, n, o, a = Dm(l);
        function l() {
            var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return wm(this, l),
            s(Am(t = a.call(this, e)), "animateIn", "preload"),
            t.slug = "page",
            t
        }
        return e = l,
        (n = [{
            key: "onEnter",
            value: function() {
                Sm(Cm(l.prototype), "onEnter", this).call(this)
            }
        }, {
            key: "onEnterCompleted",
            value: function() {
                Sm(Cm(l.prototype), "onEnterCompleted", this).call(this),
                this.addElements(),
                this.addEvents(),
                this.animateIn()
            }
        }, {
            key: "addElements",
            value: function() {
                var t, e, n, o, s, a, l, c, u, h, d, p, f, m;
                this.heroAnimation = (t = i(".page"),
                e = i(".hero"),
                r(".char-0", e),
                n = r(".word-0", e),
                o = r(".t-mask", e),
                s = r(".line-0", e),
                a = i(".scroll-circle", e),
                l = i(".arrow-line", e),
                c = i(".arrow-left", e),
                u = i(".arrow-right", e),
                h = $p.timeline({
                    paused: !0,
                    onComplete: function() {
                        $p.set(o, {
                            clearProps: "perspective"
                        }),
                        Pc.emit("animation-in")
                    }
                }),
                d = parseInt(l.getTotalLength()),
                p = parseInt(c.getTotalLength()),
                f = parseInt(u.getTotalLength()),
                m = xm(),
                $p.set(l, {
                    strokeDasharray: d,
                    strokeDashoffset: d
                }),
                $p.set(c, {
                    strokeDasharray: p,
                    strokeDashoffset: p
                }),
                $p.set(u, {
                    strokeDasharray: f,
                    strokeDashoffset: f
                }),
                $p.set(t, {
                    autoAlpha: 1
                }),
                $p.set(o, {
                    perspective: 1400
                }),
                h.add(m, "+=0.1"),
                h.from(n, {
                    duration: 1.2,
                    autoAlpha: 1,
                    skewX: 45,
                    x: -0,
                    y: "102%",
                    ease: "power3.out",
                    stagger: {
                        amount: .5,
                        from: "center"
                    },
                    onComplete: function() {
                        o && $p.set(o, {
                            overflow: "visible"
                        }),
                        bc.sniff.isDevice && bc.body.classList.remove("is-fixed")
                    }
                }, "0.5"),
                h.from(a, {
                    duration: 1.8,
                    autoAlpha: 0,
                    rotate: 60,
                    ease: "power3.inOut"
                }, "-=1.2"),
                h.to(l, {
                    duration: 1,
                    strokeDashoffset: 0,
                    ease: "power3.inOut"
                }, "-=1.2"),
                h.to(c, {
                    duration: 1,
                    strokeDashoffset: 0,
                    ease: "power3.inOut"
                }, "-=1"),
                h.to(u, {
                    duration: 1,
                    strokeDashoffset: 0,
                    ease: "power3.inOut"
                }, "-=1"),
                0 !== s.length && h.from(s, {
                    duration: .8,
                    autoAlpha: 0,
                    y: "101%",
                    stagger: .1
                }, "-=1.8"),
                h),
                this.isHome = i(".is-home")
            }
        }, {
            key: "addEvents",
            value: function() {}
        }, {
            key: "preload",
            value: function() {
                Sm(Cm(l.prototype), "preload", this).call(this),
                this.animateIn()
            }
        }, {
            key: "animateIn",
            value: function() {
                bc.flags.preloaded && this.heroAnimation.play()
            }
        }, {
            key: "removeEvents",
            value: function() {}
        }, {
            key: "onLeave",
            value: function() {
                Sm(Cm(l.prototype), "onLeave", this).call(this),
                this.removeEvents()
            }
        }, {
            key: "onLeaveCompleted",
            value: function() {}
        }]) && Mm(e.prototype, n),
        o && Mm(e, o),
        l
    }(_m);
    function Pm(t) {
        return (Pm = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        )(t)
    }
    function Rm(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function Om(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    function Fm(t, e, n) {
        return (Fm = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
            var i = function(t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = km(t)); )
                    ;
                return t
            }(t, e);
            if (i) {
                var r = Object.getOwnPropertyDescriptor(i, e);
                return r.get ? r.get.call(n) : r.value
            }
        }
        )(t, e, n || t)
    }
    function Nm(t, e) {
        return (Nm = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e,
            t
        }
        )(t, e)
    }
    function Im(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = km(t);
            if (e) {
                var r = km(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else
                n = i.apply(this, arguments);
            return Bm(this, n)
        }
    }
    function Bm(t, e) {
        return !e || "object" !== Pm(e) && "function" != typeof e ? function(t) {
            if (void 0 === t)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }
    function km(t) {
        return (km = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        }
        )(t)
    }
    var zm = function(t) {
        !function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }),
            e && Nm(t, e)
        }(a, t);
        var e, n, o, s = Im(a);
        function a() {
            var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return Rm(this, a),
            (t = s.call(this, e)).slug = "single",
            t
        }
        return e = a,
        (n = [{
            key: "onEnter",
            value: function() {
                Fm(km(a.prototype), "onEnter", this).call(this)
            }
        }, {
            key: "onEnterCompleted",
            value: function() {
                Fm(km(a.prototype), "onEnterCompleted", this).call(this),
                this.addElements(),
                this.addEvents(),
                this.animateIn()
            }
        }, {
            key: "addElements",
            value: function() {
                var t, e, n, o, s, a, l, c, u, h, d, p, f, m, g, v, y, _, x, b;
                this.heroAnimation = (t = xm(),
                e = $p.timeline({
                    paused: !0,
                    onComplete: function() {
                        Pc.emit("animation-in")
                    }
                }),
                n = i(".single"),
                o = i(".hero"),
                s = r(".t-mask", o),
                a = r(".word-0", o),
                l = i(".info-services", o),
                c = i(".info-description", o),
                u = i(".p-title", l),
                h = i(".p-title", c),
                d = r(".word-1", l),
                p = r(".line-0", c),
                f = i(".hero-image", o),
                m = i(".scroll-circle", o),
                g = i(".arrow-line", o),
                v = i(".arrow-left", o),
                y = i(".arrow-right", o),
                _ = parseInt(g.getTotalLength()),
                x = parseInt(v.getTotalLength()),
                b = parseInt(y.getTotalLength()),
                $p.set(g, {
                    strokeDasharray: _,
                    strokeDashoffset: _
                }),
                $p.set(v, {
                    strokeDasharray: x,
                    strokeDashoffset: x
                }),
                $p.set(y, {
                    strokeDasharray: b,
                    strokeDashoffset: b
                }),
                $p.set(n, {
                    autoAlpha: 1
                }),
                e.add(t, "+=0.1"),
                e.from(a, {
                    duration: 1.2,
                    autoAlpha: 1,
                    skewX: 45,
                    x: -0,
                    y: "102%",
                    ease: "power3.out",
                    stagger: {
                        amount: .5,
                        from: "center"
                    },
                    onComplete: function() {
                        s && $p.set(s, {
                            overflow: "visible"
                        }),
                        bc.sniff.isDevice && bc.body.classList.remove("is-fixed")
                    }
                }, "0.5"),
                e.from(u, {
                    duration: .5,
                    autoAlpha: 0,
                    y: 20
                }, "-=0.5"),
                e.from(h, {
                    duration: .5,
                    autoAlpha: 0,
                    y: 20
                }, "-=0.4"),
                e.from(d, {
                    duration: .5,
                    autoAlpha: 0,
                    y: "101%",
                    stagger: .1
                }, "-=0.3"),
                e.from(p, {
                    duration: .5,
                    autoAlpha: 0,
                    y: "101%",
                    stagger: .1
                }, "-=0.3"),
                e.from(f, {
                    duration: .8,
                    autoAlpha: 0
                }, "-=0.5"),
                e.from(m, {
                    duration: 1.8,
                    autoAlpha: 0,
                    rotate: 60,
                    ease: "power3.inOut"
                }, "-=1.2"),
                e.to(g, {
                    duration: 1,
                    strokeDashoffset: 0,
                    ease: "power3.inOut"
                }, "-=1.2"),
                e.to(v, {
                    duration: 1,
                    strokeDashoffset: 0,
                    ease: "power3.inOut"
                }, "-=1"),
                e.to(y, {
                    duration: 1,
                    strokeDashoffset: 0,
                    ease: "power3.inOut"
                }, "-=1"),
                e)
            }
        }, {
            key: "addEvents",
            value: function() {}
        }, {
            key: "animateIn",
            value: function() {
                this.heroAnimation.play()
            }
        }, {
            key: "removeEvents",
            value: function() {}
        }, {
            key: "onLeave",
            value: function() {
                Fm(km(a.prototype), "onLeave", this).call(this),
                this.removeEvents()
            }
        }, {
            key: "onLeaveCompleted",
            value: function() {}
        }]) && Om(e.prototype, n),
        o && Om(e, o),
        a
    }(_m);
    function Um(t) {
        return (Um = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        }
        : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        }
        )(t)
    }
    function Hm(t, e) {
        if (!(t instanceof e))
            throw new TypeError("Cannot call a class as a function")
    }
    function Gm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    function Vm(t, e) {
        return (Vm = Object.setPrototypeOf || function(t, e) {
            return t.__proto__ = e,
            t
        }
        )(t, e)
    }
    function jm(t) {
        var e = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}
                ))),
                !0
            } catch (t) {
                return !1
            }
        }();
        return function() {
            var n, i = qm(t);
            if (e) {
                var r = qm(this).constructor;
                n = Reflect.construct(i, arguments, r)
            } else
                n = i.apply(this, arguments);
            return Wm(this, n)
        }
    }
    function Wm(t, e) {
        return !e || "object" !== Um(e) && "function" != typeof e ? function(t) {
            if (void 0 === t)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }
    function qm(t) {
        return (qm = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        }
        )(t)
    }
    var Xm = function(t) {
        !function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }),
            e && Vm(t, e)
        }(s, t);
        var e, n, r, o = jm(s);
        function s() {
            return Hm(this, s),
            o.apply(this, arguments)
        }
        return e = s,
        (n = [{
            key: "in",
            value: function(t) {
                var e = t.from
                  , n = t.to
                  , r = t.done
                  , o = $p.timeline({
                    paused: !0
                })
                  , s = i(".page-transition");
                e.remove(),
                r(),
                o.fromTo(n, {
                    autoAlpha: 0
                }, {
                    duration: .4,
                    autoAlpha: 1
                }),
                o.to(s, {
                    duration: .5,
                    autoAlpha: 0
                }),
                o.play()
            }
        }, {
            key: "out",
            value: function(t) {
                var e = t.from
                  , n = t.done
                  , r = $p.timeline({
                    paused: !0,
                    onComplete: function() {
                        return n()
                    }
                })
                  , o = i(".page-transition");
                r.fromTo(e, {
                    autoAlpha: 1
                }, {
                    duration: .4,
                    autoAlpha: 0,
                    onComplete: function() {
                        bc.raf.setScroll(0)
                    }
                }),
                r.to(o, {
                    duration: .5,
                    autoAlpha: 1
                }),
                r.play()
            }
        }]) && Gm(e.prototype, n),
        r && Gm(e, r),
        s
    }(Cc.Transition);
    function Ym(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    var Zm = function() {
        function t() {
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            s(this, "nav"),
            this.init()
        }
        var e, n, i;
        return e = t,
        (n = [{
            key: "addHighway",
            value: function() {
                this.highway = new Cc.Core({
                    renderers: {
                        page: Lm,
                        single: zm
                    },
                    transitions: {
                        default: Xm
                    }
                })
            }
        }, {
            key: "els",
            value: function() {
                this.links = r(".menu-link")
            }
        }, {
            key: "l",
            value: function() {
                this.els(),
                this.highway.on("NAVIGATE_IN", this.nav)
            }
        }, {
            key: "nav",
            value: function(t) {
                var e = t.to
                  , n = t.location
                  , i = (t.trigger,
                e.view);
                this.links = r(".menu-link", i),
                this.links.forEach((function(t) {
                    t.href === n.href && t.classList.add("is-active")
                }
                ))
            }
        }, {
            key: "activeLink",
            value: function() {
                this.links.forEach((function(t) {
                    t.classList.remove("is-active"),
                    t.href === location.href && t.classList.add("is-active")
                }
                ))
            }
        }, {
            key: "init",
            value: function() {
                this.addHighway(),
                this.els(),
                this.activeLink(),
                this.l()
            }
        }]) && Ym(e.prototype, n),
        i && Ym(e, i),
        t
    }();
    function Jm(t, e) {
        for (var n = 0; n < e.length; n++) {
            var i = e[n];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i)
        }
    }
    new (function() {
        function t() {
            !function(t, e) {
                if (!(t instanceof e))
                    throw new TypeError("Cannot call a class as a function")
            }(this, t),
            console.log("%c".concat(bc.title, " \nMade with ❤️ by ").concat(bc.author, " \n↳ https://twitter.com/mariosmaselli"), "color: #6a6a6a"),
            bc.preload = new Df,
            bc.raf = new cf,
            bc.mouse = new ff,
            bc.scroll = new _f({
                smooth: d.sniff.isDesktop
            }),
            bc.resize = new df({
                cb: this.onResize,
                throttle: {
                    delay: 150
                }
            }),
            bc.resize.on(),
            this.preloaded()
        }
        var e, n, i;
        return e = t,
        (n = [{
            key: "preloaded",
            value: function() {
                bc.sniff.isDevice && bc.body.classList.add("is-fixed"),
                new Zm,
                bc.raf.on(),
                bc.scroll.on(),
                bc.mouse.on()
            }
        }, {
            key: "onResize",
            value: function() {
                d.update(),
                bc.flags.resize = !0,
                bc.vw = u().width,
                bc.vh = u().height,
                bc.window = h(),
                bc.sniff = d.sniff,
                bc.scroll.setScrollBounds(),
                Pc.emit("GlobalResize")
            }
        }, {
            key: "init",
            value: function() {}
        }]) && Jm(e.prototype, n),
        i && Jm(e, i),
        t
    }())
}
]);
                